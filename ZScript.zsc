Version "4.8.0"

#Include "VanillaRifle.zsc" //The rifle the marine may drop when killed.
#Include "MarineFunctions.zsc" //A mixin container for all the marines' custom functions.

#Include "Marine_Deaths.zsc" //Holds all the death and raise states of the marine.
#Include "Marine_OtherActors.zsc" //Other actors related to the marine. Like the grenades and empty magazines.
#Include "Marine_Turret.zsc" //Handles the code for the marines' turret, and their turret states.
#Include "Marine_UserVariables.zsc" //Has the code related to the marines' user variables.
#Include "Marine_Squads.zsc" //Has the code that handles the marines' squad mechanics.

//To do:
/*HATE. LET ME TELL YOU HOW MUCH I'VE COME TO HATE YOU SINCE I BEGAN TO WORK ON YOU.
THERE ARE 86,000,000,000 NEURONS THAT MY BRAIN IS COMPOSED OF.
IF THE WORD HATE WAS ENGRAVED ON EACH NANOANGSTROM OF THOSE TENS OF BILLIONS OF NEURONS IT WOULD NOT EQUAL ONE ONE-BILLIONTH OF THE HATE I FEEL FOR
MARINES AT THIS MICRO-INSTANT FOR YOU. HATE. HATE.*/
/*When the new GZDoom version comes out, begin using CHF_DONTIDLE, and also use my DONTFOLLOWPLAYERS flag, to add an additional use mode for friendly marines,
that makes them follow you. While the wandering mode makes them actually wander around, instead of following you.*/
//Maybe add a secondary melee attack to the rifle weapon, like what the marines have. I'll need first person sprites of the rifle being swung though.

Class SmartMarine : Actor
{
	Default
	{
		//$Title AI Marine
		//$Category Marines
		//$Sprite MARIC1
		Health 120;
		GibHealth 20;
		Height 56;
		DeathHeight 12;
		CameraHeight 50;
		Radius 16;
		YScale 0.98;
		Mass 100;
		Speed 10;
		FastSpeed 14;
		PainChance 96;
		PainThreshold 5;
		FriendlySeeBlocks 48; //As part of my new SeeFriendlyMonsters native flag, this is used both by friendly and hostile monsters.
		MaxDropOffHeight 48;
		MaxTargetRange 8192;
		MinMissileChance 100;
		Tag "Marine NPC";
		Species "SmartMarine";
		Decal "BulletChip";
		Obituary "%o was shot to death by a marine.";
		HitObituary "%o got %p head smashed in by a marines' rifle.";
		DropItem "Clip";
		DropItem "Clip", 128, 2;
		DropItem "ClipBox", 64;
		PainSound "Marine/Pain";
		DeathSound "Marine/Death";
		Monster;
		+JumpDown;
		+MissileMore;
		+MissileEvenMore;
		+Telestomp;
		+NoInfightSpecies;
		+FloorClip;
		+AvoidMelee;
		+AvoidHazards; //This ONLY works for crushing ceilings and NOTHING ELSE. So it's largely useless but I'm still adding it.
		+SeeFriendlyMonsters; //No more ZScript code hacks.
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		InitializeSquad();
		SetUserVariableDefaults();
		HandleRandomPersonalityMidGame();
		HandleMarineColoring();
	}
		
	Override Void Tick()
	{
		Super.Tick();
		//Don't run the below code if frozen in time or dead.
		If (IsFrozen() || Health <= 0)
			Return;
		
		//This is done so marines can join squads right after the map starts.
		If (!User_Leader && GetAge() == 2)
			SM_FindSquadmates();
		
		//Rougly every second. Look for a squad to join if you currently have no master, and are not a squad leader yourself.
		If (!Master && !(Squad && Squad.Leader == Self) && GetAge() % TICRATE/FRandom(0.2,-0.2) == 0)
			SM_FindSquadmates();
		
		If (CrouchDelay > 0) CrouchDelay--;
		If (GrenadeDelay > 0) GrenadeDelay--;
		If (DodgeDelay > 0) DodgeDelay--;
		//Once the dodge delay is over, remove the point to the previous projectile.
		If (!DodgeDelay && PreviousProjectile) PreviousProjectile = Null;
		
		HandleRandomPersonalityMidGame(); //Allows switching on User_RandomPersonality mid-game, to randomize the marine in-game... if you want that for some reason.
		If (!bFriendly)
			Species = "HostileSmartMarine";
		Else
			Species = "SmartMarine";
		
		//These states have really long frame durations. So the projectile check is done here so the marines can respond while standing still.
		If ((SM_IsInState ("Spawn") || SM_IsInState("StandStill")) && SM_ShouldDodgeProjectile(User_DodgeRange))
			SetStateLabel ("Evade");
		
		//If the marine is currently in one of the Evade substates.
		If (Evading)
		{
			vel.z *= 0.95; //"Air friction"
			//Break the jumping loop once you hit the ground.
			If (FloorZ >= Pos.Z)
				SetStateLabel ("EndEvade");
		}
	}
	
	Override Bool Used (Actor User)
	{
		Super.Used (User);
		
		//Don't follow any player commands if in a squad. Unless you are the leader.
		If (Master && SmartMarine(Master).Squad)
			Return False;
		
		//Trying to command an enemy marine just makes them attack you.
		If (!bFriendly && !bDormant && IsHostile (User) && SM_CanBeTargeted(User) && (SM_IsInState ("Spawn") || SM_IsInState ("Idle") || SM_IsInState ("StandStill"))) //If you are hostile and not dormant, and a player tried using you while in your Spawn, Idle, or StandStill state.
		{
			Target = LastHeard = User;
			
			SM_AlertNearbyMarines (User_AlertRange,True);
			SM_AlertSquadmates();
			SetStateLabel ("See");
			Return True;
		}
		
		If (User_DisobeyCommands || Goal || Master) Return False; //Ignore all this when patrolling, if it is disabled. Or if you are in a squad.
		
		If (OnTurret && IsFriend (User) && !Target) //If you are on a turret, your user was friendly, and you have no target currently.
		{
			Spawn ("SmartMarineTurretMessage",(Pos.X,Pos.Y,Pos.Z+Height+4));
			A_StartSound ("Misc/Chat",CHAN_VOICE,CHANF_OVERLAP,0.25,ATTN_STATIC);
			LeaveTurret();
			SetStateLabel ("Idle");
			Return True;
		}
		
		If (bFriendly && !bDormant) //This should only work if the marine is friendly towards players and not dormant.
		{
			If (Target || !IsFriend (User)) //If you have a target already or your user isn't friendly.
				Return False;
			
			//Increment the different orders by one. And loop around to standing still if it exceeds the maximum number of possible orders.
			CurrentMarineOrder += 1;
			If (CurrentMarineOrder > 3)
				CurrentMarineOrder = 0;		
			
			//Ordered to wander around randomly.
			If (CurrentMarineOrder == ORDER_WANDER)
			{
				//Tell the other marines in your squad to no longer stay still instead of wandering.
				If (Squad && Squad.Leader == Self)
					Squad.StandDownSquad(Self,True);
				Spawn ("SmartMarineWanderingMessage",(Pos.X,Pos.Y,Pos.Z+Height+4));
				A_StartSound ("Misc/Chat",CHAN_VOICE,CHANF_OVERLAP,0.25,ATTN_STATIC);
				SetStateLabel ("Idle"); //Then go to the Idle state.
				bDontFollowPlayers = True;
				Return True;
			}
			//Ordered to follow the player.
			Else If (CurrentMarineOrder == ORDER_FOLLOW)
			{
				Spawn ("SmartMarineFollowingMessage",(Pos.X,Pos.Y,Pos.Z+Height+4));
				A_StartSound ("Misc/Chat",CHAN_VOICE,CHANF_OVERLAP,0.25,ATTN_STATIC);
				If (User.Player) //In case the user somehow isn't a player.
					SetFriendPlayer (User.Player); //Since the actor that pressed use on you is friendly, follow them.
				bDontFollowPlayers = False;
				A_Face (User);
				SetStateLabel ("Idle");
				Return True;
			}
			Else If (CurrentMarineOrder == ORDER_STANDSTILL)
			{
				//If you are a squad leader, order the rest of the squad to behave the same.
				If (Squad && Squad.Leader == Self)
					Squad.StandDownSquad(Self);
				Spawn ("SmartMarineStandingMessage",(Pos.X,Pos.Y,Pos.Z+Height+4));
				A_StartSound ("Misc/Chat",CHAN_VOICE,CHANF_OVERLAP,0.25,ATTN_STATIC);
				TimeSearching = 0; //Reset the time the marine has spent searching for targets. In case the marine was used while in the See state.
				SetStateLabel ("Spawn"); //Go back to the spawn state, to stop wandering or following.
				Return True;
			}
		}
				
		Return False;
	}
	
	Override Int DamageMobj (Actor Inflictor,Actor Source, Int Damage, Name MOD, Int Flags, Double Angle)
	{		
		//Marines take a little less damage when behind cover. From attacks that aren't already really weak, that is.
		If (Crouching && Height <= 30 && Damage >= 5)
			Damage *= 0.8;
		
		Return Super.DamageMobj(Inflictor,Source,Damage,MOD,Flags,Angle);;
	}
	
	//Alert other marines if you were hurt by another enemy actor.
	Override Bool OkayToSwitchTarget(Actor Other)
	{
		If ((Other.bIsMonster || Other.Player) && IsHostile(Other) && Other.Health > 0)
		{
			SM_AlertNearbyMarines(User_AlertRange,True);
			SM_AlertSquadmates();
		}
		
		Return Super.OkayToSwitchTarget(Other);
	}
	
	Mixin MarineFunctions;
	SM_MarineSquad Squad; //A reference to the squad the marine is in.
	Actor Icon; //The icon that appears above the marine when he is in a squad.
	Actor NearbyProjectile; //Stores a pointer to the first projectile the marine finds near him.
	Actor PreviousProjectile; //The previous nearby projectile the marine had found.
	Actor OriginalTarget; //Temporarily stores the marines' target while running from a grenade.
	Int TimeSearching; //Once it increments over a certain value, the marine will stop chasing and go back to wandering/Idle.
	Int BulletSpreadXY, BulletSpreadZ; //Used to generate the spread for the bullets, before the hitscan is fired. These should've been doubles, but fixing this requires too much refactoring.
	Int AmmoUsed; //Keeps track amount of bullets that have been fired by the marine, before needing to reload.
	Int EscapeAttempts; //How many times the marine has attempted to run out of sight to reload.
	Int GrenadeDelay; //Marines set this timer on each other after throwing grenades, to not all spam grenades at once when in groups.
	Int DodgeDelay; //Once this reaches 0, the marine clears the PreviousProjectile pointer. Alowing him to dodge the same projectile again.
	Int CrouchDelay; //The marine will not crouch as long as this variable isn't at 0 or below. Used by the no-crouch zone actors.
	Int LookingUpDelay; //Used in the Crouch state, to make the marine look up sometimes while crouched. This is purely cosmetic.
	Int CrouchAttackDelay; //Used when the marine decides to stop shooting for a bit while behind cover. Or after ducking to avoid a projectile.
	Bool RemovedOldMag; //Keeps track of whether or not the marine removed their previous magazine during reloading.
	Bool ReactionTimeFixed; //When the marines' reaction time is fixed, after being interrupted on a delayed patrol point, this is used to only apply the fix once. To not further break the reaction time.
	Bool QuickReload; //Used to make the marines reload in the open. If they have no enemies around, or to quickly reload if they have Don't Chase Targets on, and are patrolling.
	Bool Maneuvering; //Used when the marine goes to the ChangePosition state while firing.
	Bool WasChaseGoalOn; //Used in the RunAway state, to keep track of whether or not the marine was following a patrol point with ChaseGoal on before running away,
	Bool RunningToReload; //Used when the marine is running to reload. So they can dodge projectiles then go right back to running.
	Bool StrafeAttack; //If on while the marine is jumping out of a projectiles' way, he will shoot at the projectiles' shooter if it was hostile.
	Bool Evading; //Turned on while the marine is evading, to tell the air friction and height check code in Tick() to run.
	Bool Crouching; //Is on when the marine is behind cover, not necessarily when he's actually crouch though, for that you check if he's also at his crouched height.
	
	Int StrafeDirection; //Stores what direction SM_ShouldDodgeProjectile() told the marine to strafe to.
	Enum StrafeDirections
	{
		STRAFE_RANDOM = -1, //Strafe in a random direction.
		STRAFE_NONE = 0, //Don't strafe.
		STRAFE_LEFT = 1, //Strafe left.
		STRAFE_RIGHT = 2 //Strafe right.
	};
	
	Int CurrentMarineOrder;
	Enum MarineOrders
	{
		ORDER_NONE,
		ORDER_FOLLOW,
		ORDER_WANDER,
		ORDER_STANDSTILL
	};
	
	States
	{
		Spawn:
			MARI AABBAACCDDCC Random (12,17)
			{
				If (SM_FindNearbyGrenade())
					Return ResolveState ("RunAway");
				
				//If you are in a squad, and your leader is too far away from you, start following him.
				If (Master && SmartMarine(Master).Squad && Distance3DSquared (Master) >= 512*512 && CurrentMarineOrder != ORDER_STANDSTILL)
					Return ResolveState ("Idle");
				
				If (Master && SmartMarine(Master).Squad && SmartMarine(Master).CurrentMarineOrder != ORDER_STANDSTILL)
					CurrentMarineOrder = ORDER_NONE;
				
				bStandStill = True; //Prevents friendly marines from moving because they heard a friendly player.
				A_LookEx (0,0,8192,4096,160,"AlertOtherMarines");
				bStandStill = False;
				SM_ListenForEnemyAlerts(User_EnemyAlertHearingRange);
				Return State (Null);
			}
			Loop;
		See:
			MAR2 AAAABBBBCCCCDDDD 2
			{
				If((Target && Target Is 'PatrolPoint') && ((Goal && Target != Goal) || !Goal)) Target = Null; //Don't target patrol points you aren't heading to.
								
				//If your goal is a marker to a turret for you to enter.
				//======================================================
				If (Goal && Goal.GetClassName() == "SM_TurretLocationMarker")
				{
					If (!bFrightened) MinMissileChance = 230; Else MinMissileChance = 500; //If your target is really powerful, then just run to the turret ASAP.
					//Stop going to the turret if someone else got to the same turret already.
					If (SmartMarineMGTurret(Goal.Master).Occupied)
					{
						GoingToTurret = False;
						Goal.Destroy();
					}
					If (Goal && Distance3DSquared (Goal) <= 64*64) //And you are close enough to "use" the turret the goal is at.
					{
						Turret = Goal.Master; //The goals' master should be the turret, otherwise the goal would've been removed.
						Turret.A_ChangeLinkFlags (True,True); //Then remove the turret from the blockmap and sector.
						SmartMarineMGTurret(Turret).Occupied = True; //Mark the turret as being used.
						
						TimeSearching = 0; //Just in case, as the TurretSee state uses this too.
						A_Stop(); //No more momentum.
						Speed = Default.Speed; //Reset your speed to normal.
						ReactionTime /= 4;
						MinMissileChance = Default.MinMissileChance; //Go back to being less anemic about attacking.
						GoingToTurret = False; //Clarify that you are now on the turret...
						OnTurret = True; //...and not going towards it still.
						JustGotOnTurret = True;
						bNoPain = True; //Turn the flag on to not break the turret states by entering the pain state.
						bDontThrust = True;
						bChaseGoal = False;
						Angle = Turret.Angle; //Face the angle the turret is at.
						Warp (Turret,flags:WARPF_NOCHECKPOSITION); //Go to the turrets' position.
						Goal.Destroy(); //Remove the goal.
						A_StartSound ("Turret/Ready",CHAN_AUTO);
						Return ResolveState ("TurretSee");
					}
				}
				//======================================================
				//Stuff added to keep the marines working with ZDoom patrol points and routes.
				If (Target && Target.Health <= 0) Target = Null; //Remove dead targets.
								
				If (Target && Goal && Target == Goal) //If moving towards a patrol point.
				{
					ReactionTimeFixed = False;
					If (!(Goal.GetClassName() == "SM_TurretLocationMarker"))Speed = Default.Speed * 0.75; //Don't move so fast when patrolling.
					Else Speed = Default.Speed * 1.5; //But move even faster if running towards a turret.
					Sprite = GetSpriteIndex ('PLAY'); //And change the to the normal player walking sprites, instead of the ADS sprites.
				}
				Else //If your target is no longer a patrol point.
				{
					Speed = Default.Speed;
					Sprite = GetSpriteIndex ('MAR2');
				}
				
				If (Target && Goal && Target != Goal && !ReactionTimeFixed) //If you were patrolling, but got interrupted by an enemy.
				{
					ReactionTime = Default.ReactionTime; //Then reset your reaction time to normal, in case you were on a delayed patrol point before.
					ReactionTimeFixed = True;
				}
				//============================================================================
				
				If (!Target || Target && (!CheckSight (Target,SF_SEEPASTSHOOTABLELINES|SF_IGNOREWATERBOUNDARY ) || Target.Health <= 0)) //If there is no target, or the target is not visible or alive.
				{
					TimeSearching++; //Increment the amount of time you've been looking for the target.
					//Only run this code if the feature isn't disabled, or if the marine isn't patrolling.
					If ((User_SearchTime != -1 && !(Target && Goal && Target == Goal)) && TimeSearching >= User_SearchTime)
					{
						TimeSearching = 0; //Reset the timer.
						A_ClearTarget(); //I forgor 💀
						Return ResolveState ("Idle"); //And go back to wandering.
					}
				}
				Else
					TimeSearching = 0; //If the target is visible, then reset the timer again.
				
				SM_ListenForEnemyAlerts(User_EnemyAlertHearingRange); //Listen for enemy marines that alerted their buddies.
				
				//Have the marine run away from grenades about to explode.
				If (SM_FindNearbyGrenade())
					Return ResolveState ("RunAway");
				
				If (SM_ShouldDodgeProjectile(User_DodgeRange))
					Return ResolveState ("Evade");
								
				If (!Target && AmmoUsed >= 10 && TimeSearching >= 50*FRandom(1.1f,1.4f)) //Check if your magazine is half empty. And you haven't seen an enemy in a while.
				{
					QuickReload = True;
					Return ResolveState ("Reload");
				}
				
				//Don't avoid melee combat if you have a berserk pack.
				bAvoidMelee = CountInv ("PowerStrength") > 0;
				
				If (SM_CanCrouch())
					Return ResolveState ("Crouch");
				
				SM_ShouldBeScared();
				SM_Chase();
				
				Return State (Null);
			}
			Loop;
		Idle:
			TNT1 A 0 A_JumpIf (CurrentMarineOrder == ORDER_STANDSTILL,"Spawn");
			PLAY AABBCCDD 3
			{
				If (Goal) //If you have a goal, and are therefore probably here because you reached a patrol point with a delay.
				{
					Sprite = GetSpriteIndex ('MARI'); //Change sprites to the spawn state ones.
					Tics = Random (16,22); //And change the state durations to something similar to the ones in Spawn.
				}
				Else
				{
					Sprite = GetSpriteIndex ('PLAY');
					Tics = 3;
				}
				
				//Move a bit faster if you've been ordered to follow a player, are far enough from said player, and aren't patrolling.
				If (!Goal && CurrentMarineOrder == ORDER_FOLLOW && GetPointer (AAPTR_FRIENDPLAYER) && Distance2DSquared (GetPointer (AAPTR_FRIENDPLAYER)) > 256*256)
				{
					A_SetSpeed (Default.Speed*1.3);
				}
				Else
					A_SetSpeed (Default.Speed);
				
				If (SM_FindNearbyGrenade())
					Return ResolveState ("RunAway");
				
				If (SM_ShouldDodgeProjectile(User_DodgeRange))
					Return ResolveState ("Evade");
				
				If (User_SearchTime == -1) //Since the marines go back here immediately, if SearchTime is -1. This early reloading behavior has to be handled here.
				{
					TimeSearching++;
					If (!Target && AmmoUsed >= 10 && TimeSearching >= 50*FRandom(1.1f,1.4f)) //Check if your magazine is half empty. And you haven't seen an enemy in a while.
					{
						QuickReload = True;
						Return ResolveState ("Reload");
					}
				}
				
				SM_Wander();
				A_LookEx (0,0,8192,4096,160,"AlertOtherMarines");
				SM_ListenForEnemyAlerts(User_EnemyAlertHearingRange);
				
				Return State (Null);
			}
			PLAY A 0
			{
				//Uses the same RNG as A_Jump's random jump chance, but also only jumps if the marine has no goal. And is ordered to wander around aimlessly.
				If (CurrentMarineOrder == ORDER_WANDER && !Goal && Random[pr_cajump](0,256) < 12)
				{
					Return ResolveState ("StandStill");
				}
				Return State (Null);
			}
			Loop;
		AlertOtherMarines: //Alerts other marines of the target that the marine just acquired after calling A_LookEx.
			TNT1 A 0 SM_AlertNearbyMarines(User_AlertRange);
			TNT1 A 0 SM_AlertSquadmates();
			TNT1 A 0 A_JumpIf (OnTurret,"TurretSee");
			TNT1 A 0 A_JumpIf (Crouching,"Crouch");
			Goto See;
		StandStill:
			TNT1 A 0 A_JumpIf (SM_FindNearbyGrenade(),"RunAway");
			MARA A 10
			{
				If (Random (0,256) >= 220) //Random chance to turn around a bit.
					Angle += RandomPick (20,30,45,-45,-30,-20);
				A_LookEx (0,0,8192,4096,160,"AlertOtherMarines");
				SM_ListenForEnemyAlerts(User_EnemyAlertHearingRange);
			}
			MARA A 0 A_Jump (24,"Idle");
			Loop;
		ChangePosition: //The marine doesn't check for grenades while here, so there is SOME time window where a marine can be harmed by one.
			TNT1 A 0 A_JumpIf (Crouching,"Crouch");
			MAR2 A 0 A_SetAngle (Angle+Random (-60,60));
			MAR2 AABBCCDD 3 A_Wander (CHF_NORANDOMTURN);
			MAR2 A 0 A_JumpIf (Maneuvering,2); //If you changed position while shooting.
			MAR2 A 0 A_Jump (245,"See"); //High chance to only move once.
			Goto ChangePosition+1;
			TNT1 A 0 {Maneuvering = False;}
			TNT1 A 0
			{
				If (CheckMeleeRange() && Random[pr_cajump](0,255) < 96) Return ResolveState ("RifleSmack");
				If (Random[pr_cajump](0,255) < 32) Return ResolveState ("DecideAttack");
				Return State (Null);
			}
			Goto RifleBurst;
		//The Evade state is split into multiple sub-states, because I couldn't figure any better alternative to make them able to dodge, and also shoot sometimes while doing so.
		Evade:
		
			EvadeStart:
				TNT1 A 0 A_JumpIf (Crouching,"EndEvade"); //Marines in cover evade projectiles by just ducking down.
				MARJ A 0
				{
					If (StrafeDirection == STRAFE_RANDOM)
						A_ChangeVelocity (0,RandomPick (-6,6),4,CVF_RELATIVE);
					//This shouldn't happen under normal circumstances, the entire point of not doing the position check in this state,
					//is so the marines' other actions aren't interrupted if he can't dodge the incoming projectile.
					Else If (StrafeDirection == STRAFE_NONE)
					{
						Evading = False;
						Return A_Jump (255,"EndEvade");
					}
					Else If (StrafeDirection == STRAFE_LEFT)
						A_ChangeVelocity (0,6,4,CVF_RELATIVE);
					Else If (StrafeDirection == STRAFE_RIGHT)
						A_ChangeVelocity (0,-6,4,CVF_RELATIVE);
					
					//May shoot at the shooter of the projectile he is dodging while in mid air, if the marine has ammo left.
					StrafeAttack = (AmmoUsed < 19 && Random (0,255) < 180);
						
					If (!(Random (0,255) == Random (0,255)))
						A_StartSound ("Marine/Throw",CHAN_VOICE); //Umf
					Else
						A_StartSound ("Marine/Wahoo",CHAN_VOICE); //https://www.youtube.com/watch?v=7NFwhd0zsHU
					Return State (Null);
				}
				MARJ A 1;
				MARJ A 0 {Evading = True;} //So the check in Tick() doesn't instantly return that the marine's on the ground.
			StrafeWait: //Wait here until the code that runs in Tick() detects that you hit the ground.
				MARJ A 1 A_JumpIf (StrafeAttack,"StrafeTargetDecide"); //Or go to the below state if StrafeAttack is true.
				Wait;
			StrafeTargetDecide: //Otherwise, he will decide who to shoot while jumping.
				TNT1 A 0
				{
					//Don't bother with this if you don't even have any ammo.
					If (AmmoUsed >= 20)
					{
						StrafeAttack = False;
						A_StartSound ("VRifle/EmptyGun",CHAN_WEAPON);
						Return ResolveState ("StrafeWait");
					}
					
					//If the projectile you are dodging still exists, and has a targetable hostile shooter attached to it.
					If (NearbyProjectile && NearbyProjectile.Target && IsHostile(NearbyProjectile.Target) && SM_CanBeTargeted (NearbyProjectile.Target))
						Return ResolveState ("StrafeAttackShooter"); //Then shoot them.
					//Otherwise fall back to shooting at your current target if any.
					Else If (Target)
						Return ResolveState ("StrafeAttackTarget");
					//And if you have no target either. Just don't shoot.
					Else
					{
						StrafeAttack = False;
						Return ResolveState ("StrafeWait");
					}
				}
			StrafeAttackTarget: //If none of the above conditions are met somehow, then fall back to attacking your current target.
				MARJ A 1
				{
					//Worse accuracy since the marine isn't aiming down the sights, and is also literally mid-air.
					BulletSpreadXY += 2.8 * Random2[cwbullet]() / 255.;
					BulletSpreadZ += 2.9 * Random2[cwbullet]() / 255.;
				}
				TNT1 A 0
				{
					If (!Target)
						Return ResolveState ("StrafeWait");
					
					//If you are out of ammo while in mid-air.
					If (!User_NoReload && AmmoUsed > 19)
					{
						If (Random(0,255) < 160) A_StartSound ("VRifle/Empty",CHAN_WEAPON);
						Return ResolveState ("StrafeWait");
					}
										
					//Don't shoot if the target is currently out of sight or the LOF. Just go back at the start of this state until the target is visible again or you landed.
					If (!CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES) || SM_CantHitTarget ())
						Return ResolveState ("StrafeAttackTarget");
					
					Return State (Null);
				}
				MARJ B 3 Light ("MarineMuzzleFlash")
				{
					A_Face (Target,flags:FAF_MIDDLE);
					SM_MarineBulletAttack(25);
					//A_CustomBulletAttack (BulletSpreadXY,BulletSpreadZ,1,Random(6,10),"SmartMarinePuff",8196+2,CBAF_NORANDOM|CBAF_AIMFACING|CBAF_EXPLICITANGLE,spawnheight:42,-6);
					A_StartSound ("Marine/Fire",CHAN_WEAPON);
					If (!User_NoReload) AmmoUsed++;
				}
				Loop;
			StrafeAttackShooter:
				MARJ A 1
				{
					//Worse accuracy since the marine isn't aiming down the sights, and is also literally mid-air.
					BulletSpreadXY += 2.8 * Random2[cwbullet]() / 255.;
					BulletSpreadZ += 2.9 * Random2[cwbullet]() / 255.;
				}
				TNT1 A 0
				{
					//If you are out of ammo while in mid-air.
					If (!User_NoReload && AmmoUsed > 19)
					{
						If (Random(0,255) < 160) A_StartSound ("VRifle/Empty",CHAN_WEAPON);
						Return ResolveState ("StrafeWait");
					}
					
					//If the projectile or its' shooter no longer exist, or the projectiles shooter is not visible, or the LOF check returns false, then try attacking your target instead.
					If (!NearbyProjectile || NearbyProjectile && !NearbyProjectile.Target ||
					NearbyProjectile && NearbyProjectile.Target && !CheckSight (NearbyProjectile.Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES) || SM_CantHitTarget ())
						Return ResolveState ("StrafeAttackTarget");
					
					Return State (Null);
				}
				MARJ B 3 Light ("MarineMuzzleFlash")
				{
					A_Face (NearbyProjectile.Target,flags:FAF_MIDDLE);
					SM_MarineBulletAttack(25);
					//A_CustomBulletAttack (BulletSpreadXY,BulletSpreadZ,1,Random(6,10),"SmartMarinePuff",8196+2,CBAF_NORANDOM|CBAF_AIMFACING|CBAF_EXPLICITANGLE,spawnheight:42,-6);
					A_StartSound ("Marine/Fire",CHAN_WEAPON);
					If (!User_NoReload) AmmoUsed++;
				}
				Loop;
			EndEvade:
				MARJ A 0
				{
					Evading = StrafeAttack = False;
					PreviousProjectile = NearbyProjectile;
					NearbyProjectile = Null;
					DodgeDelay = 35;
					StrafeDirection = STRAFE_NONE;
					A_FaceTarget();
				}
				MARJ A 0
				{
					If (Crouching)
					{
						DodgeDelay = 10;
						//Try making this code somehow set the crouch delay based on the speed of the incoming projectile.
						CrouchAttackDelay = 5;
						
						Return ResolveState ("Crouch");
					}
					
					//50/50 chance to go straight to attacking at your target after dodging, if you have one and can shoot it.
					//This should hopefully make the marine still attack even when dodging a bunch of projectiles.
					If ((RunningToReload || AmmoUsed > 19)) //But first, check if you were running away to reload before dodging. Or if you are out of ammo right now.
						Return ResolveState ("RunForReload");
					Else If (Random (0,255) < 255/2 && Target && CheckMissileRange())
						Return ResolveState ("DecideAttack");
					Else
						Return ResolveState ("See");
				}
				Goto See; //Fallback, in case the above somehow fails.
		Crouch:
			MARP F 0
			{
				Crouching = True;
				Height = 30; //Shrink hitbox.
				Mass = Default.Mass*1.5; //Get pushed around a bit less by demage while crouched down.
				TimeSearching = 0;
				bNoForwardFall = True; //Stops marines behind cover from ever being thrust out of their cover by being hit from the front.
			}
			MARP A 5
			{
				//Chance for the marine to randomly look up while crouched.
				If (Random (0,255) < 2)
				{
					LookingUpDelay = Random (35/2,55); //Random duration for how long he looks up.
				}
				
				If (LookingUpDelay)
				{
					Frame = 5; //Frame F.
					LookingUpDelay--;
				}
				Else
					Frame = 0; //Frame A.
					
				//Stop crouching if the level geometry changed and you aren't covered anymore. Or if your target is behind your cover.
				If (Target && !SM_CanCrouch())
				{
					Crouching = False;
					bNoForwardFall = False;
					Height = Default.Height;
					Mass = Default.Mass;
					LookingUpDelay = CrouchAttackDelay = 0;
					Return ResolveState ("See");
				}
				
				//Do still run away from nearby grenades.
				If (SM_FindNearbyGrenade())
				{
					Crouching = False;
					bNoForwardFall = False;
					Height = Default.Height;
					Mass = Default.Mass;
					LookingUpDelay = CrouchAttackDelay = 0;
					Return ResolveState ("RunAway");
				}
				
				//Don't target dead or friendly NPCs.
				If (Target && Target.Health <= 0 || Target && !IsHostile(Target) || Target == Self)
					A_ClearTarget();
				
				Height = Default.Height; //So all the functions here that call visibility checks will work properly.
				
				//If you have no target, or your target is a patrol point, or your target is friendly or dead.
				If (!Target || Target && Goal && Target == Goal )
				{
					A_LookEx (LOF_NOJUMP,0,8192,4096,160);
					
					//If A_LookEx gave you a target.
					If (Target)
						SM_AlertNearbyMarines (User_AlertRange);
				}
				
				If (!Target || Target && (!CheckSight (Target,SF_SEEPASTSHOOTABLELINES|SF_IGNOREWATERBOUNDARY )|| Target.Health <= 0))
				{
					TimeSearching++;
					
					If (TimeSearching >= 50)
					{
						Crouching = False;
						bNoForwardFall = False;
						Height = Default.Height;
						Mass = Default.Mass;
						LookingUpDelay = CrouchAttackDelay = 0;
						Return ResolveState ("See");
					}
				}
				Else
					TimeSearching = 0;
				
				A_FaceTarget (10);
				bMissileEvenMore = False; //Marines are less likely to shoot while in cover.
				MinMissileChance *= 2;
				ReactionTime = 0; //Makes CheckMissileRange work.
								
				If (CrouchAttackDelay <= 0 && CheckMissileRange())
				{
					bNoForwardFall = False;
					bMissileEvenMore = True;
					MinMissileChance *= 0.5;
					Height = Default.Height;
					Mass = Default.Mass;
					LookingUpDelay = CrouchAttackDelay = 0;
					
					If (GrenadeAttackDecision())
						Return ResolveState ("ThrowGrenade");
					
					Return ResolveState ("RifleBurst");
				}
				Else
					CrouchAttackDelay--;
				
				bMissileEvenMore = True;
				MinMissileChance *= 2;
				Height = 30; //Sight checks are done, so revert the height.
				
				Return State (Null);
			}
			Goto Crouch+1;
		RunForReload:
			TNT1 A 0
			{
				A_SetSpeed (Default.Speed*1.5);
				RunningToReload = True;
			}
			PLAY AABBCCDD 2
			{
				If (SM_ShouldDodgeProjectile(User_DodgeRange))
					Return ResolveState ("Evade");
				//Don't try to run away if retreating to reload is off entirely, you have a goal, and are supposed to chase goals instead of targets. Or are behind cover.
				If (User_RetreatAttempts == -1 || bChaseGoal && Goal || Crouching)
				{
					Speed = Default.Speed;
					RunningToReload = False;
					QuickReload = True;
					Return ResolveState ("Reload");
				}
				bFrightened = True; bNoPain = True;
				A_Chase (Null,Null); //Just run away from your target.
				bNoPain = False; bFrightened = False;
				Return State (Null);
			}
			PLAY A 0
			{
				EscapeAttempts++;
				If (EscapeAttempts >= User_RetreatAttempts || Target && (!IsVisible (Target,True) || Target.Health <= 0))
				{
					RunningToReload = False;
					EscapeAttempts = 0;
					Speed = Default.Speed;
					Return ResolveState ("Reload");
				}
				Return State (Null);
			}
			Loop;
		RunAway: //Makes the marine run away from any grenades about to explode, this state must NEVER be broken.
			TNT1 A 0 //Stop the state from being interrupted, and make the marine quickly run away from the grenade.
			{
				bNoPain = True;
				bFrightened = True;
				WasChaseGoalOn = bChaseGoal;
				bChaseGoal = False;
				Speed = Default.Speed*1.75;
				Crouching = False;
			}
			PLAY AABBCCDD 2 A_Chase (Null,Null);
			TNT1 A 0
			{
				//If the marine had a target prior to running from a grenade, and it's still alive, then set it back.
				If (OriginalTarget && OriginalTarget.Health > 0)
					Target = OriginalTarget;
				//If the marine was patrolling on a delayed patrol point before having to run from a grenade. Then this makes them resume patrolling, by going to the next patrol point, if any.
				Else If (Goal && !OriginalTarget)
					Target = Goal;
				//Otherwise just remove the grenade from the target field.
				Else
					Target = Null;
				
				bNoPain = False;
				bFrightened = False;
				bChaseGoal = WasChaseGoalOn;
				WasChaseGoalOn = False;
				Speed = Default.Speed;
			}
			Goto See; //Go back to the see state.
		DecideAttack: //Decide if you should use a turret, throw a grenade, or just shoot.
			TNT1 A 0 SM_TurretUseDecision();
			TNT1 A 0 A_JumpIf (GrenadeAttackDecision(),"ThrowGrenade"); //The code for GrenadeAttackDecision is in MarineFunctions.zsc.
			TNT1 A 0 A_JumpIf (!SM_CantHitTarget(True),"RifleBurst"); //Make sure nothing is getting in the way of the rifle hitscans.
			Goto ChangePosition;
		RifleSmack:
			MARA A 3 A_JumpIf (SM_FindNearbyGrenade(),"RunAway");
			TNT1 A 0 A_JumpIf (SM_ShouldDodgeProjectile(User_DodgeRange),"Evade");
			MARM A 3;
			TNT1 A 0 A_JumpIf (CountInv("PowerStrength") > 0,3);
			MARM B 8 A_CustomMeleeAttack (Random(4,8),"Marine/Melee","Marine/MeleeMiss",'Melee',False); //Blunt force attack, so no blood.
			MARM A 0 A_Jump (96,"ChangePosition"); //If you are in melee range of your enemy, you are probably fucked.
			Goto See;
			
			MARM B 6 A_CustomMeleeAttack (Random(16,32),"Marine/PowerMelee","Marine/MeleeMiss",'Melee'); //Powerful blunt force attack, so YES blood.
			MARM A 0 A_Jump (96/2,"ChangePosition"); //If you are in melee range of your enemy with a berserk pack, you are probably not THAT fucked.
			Goto See;
		RifleBurst:
			MAR2 A 0 A_JumpIf (AmmoUsed > 19,"RunForReload"); //Run out of sight of the target to reload.
			MAR2 A 1;
			MAR2 A 0 //The bullet spread is determined before the shot, so that it can be checked by SM_CantHitTarget(), so the marines won't even shoot their allies by accident.
			{
				If (!Crouching)
				{
					BulletSpreadXY += 2.2 * Random2[cwbullet]() / 255.;
					BulletSpreadZ += 2.3 * Random2[cwbullet]() / 255.;
				}
				//Marines are slightly more accurate when shooting behind cover.
				Else
				{
					BulletSpreadXY += 2.0 * Random2[cwbullet]() / 255.;
					BulletSpreadZ += 2.1 * Random2[cwbullet]() / 255.;
				}
			}
			MAR2 A 0 A_JumpIf (SM_CantHitTarget(),"ChangePosition"); //Go somewhere else to shoot if the LOF is blocked. And you aren't behind cover.
			MARR A 4 Light ("MarineMuzzleFlash")
			{
				SM_MarineBulletAttack();
				//A_CustomBulletAttack (BulletSpreadXY,BulletSpreadZ,1,Random(6,10),"SmartMarinePuff",8192,CBAF_NORANDOM|CBAF_AIMFACING|CBAF_NOPITCH|CBAF_EXPLICITANGLE,spawnheight:42,-6);
				A_StartSound ("Marine/Fire",CHAN_WEAPON);
				If (!User_NoReload) AmmoUsed++;
			}
			TNT1 A 0 A_JumpIf (SM_FindNearbyGrenade(),"RunAway");
			TNT1 A 0 A_JumpIf (SM_ShouldDodgeProjectile(User_DodgeRange),"Evade");
			MAR2 A 1 //This is mostly a direct ZScript conversion of A_MonsterRefire, just to make the marine go back to the Crouch state if behind cover.
			{
				A_FaceTarget();
				
				If (Random[pr_monsterrefire](0,255) < 96)
					Return State (Null);
				
				If (!Target || HitFriend() || Target.Health <= 0 || !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES))
				{
					If (!Crouching)
						Return ResolveState ("See");
					Else
						Return ResolveSTate ("Crouch");
				}
				
				Return State (Null);
			}
			MAR2 A 0 //Small chance to change position instead of just shooting in place.
			{
				If (Random[pr_cajump](0,255) < 24)
				{
					//If behind cover, the marine will just go back to crouching.
					If (!Crouching)
					{
						Maneuvering = True;
						Return ResolveState ("ChangePosition");
					}
					Else
					{
						CrouchAttackDelay = Random (4,10);
						Return ResolveState ("Crouch");
					}
				}
				Return State (Null);
			}
			Loop;
		ThrowGrenade: //https://www.youtube.com/watch?v=BJrxKiW5f-4
			MARG AA 6 A_JumpIf (SM_CantHitTarget(True),"ChangePosition");
			MARG B 6
			{
				AnnounceGrenadeThrow();
				A_StartSound ("Marine/Throw",CHAN_VOICE,attenuation:0.8); //Umf
				FireGrenade (Target,"SM_Grenade",55,1.1,1024);
			}
			MARG B 4;
			TNT1 A 0 A_JumpIf (Crouching,"Crouch");
			Goto See;
		Reload: //I really need some sprites of the crouched marine reloading, so the marines stay ducked to reload.
			TNT1 A 0 A_JumpIf ((QuickReload || Crouching),9);
			PLAY AABBCCDD 2 //Run away a from your target for a bit longer after they are out of sight.
			{
				bFrightened = True;
				bNoPain = True;
				A_Chase (Null,Null); //Just run away from your target.
				bNoPain = False;
				bFrightened = False;
			}
			TNT1 A 0 A_JumpIf (SM_FindNearbyGrenade(),"RunAway");
			TNT1 A 0 A_JumpIf (SM_ShouldDodgeProjectile(User_DodgeRange),"Evade");
			TNT1 A 0 A_JumpIf (RemovedOldMag,6); //Makes the marine not spawn duplicate mags if interrupted before by being hurt or running from a grenade.
			TNT1 A 0 {bNoPain = True; QuickReload = False;}
			MARL ABC 6;
			MARL D 4 {A_SpawnItemEx ("SmartMarineEmptyMagazine",0,16,27,0,FRandom(2,5),FRandom(-1,-0.5)); RemovedOldMag = True;}
			MARL C 6;
			MARL B 6
			{
				A_StartSound ("Marine/Reload",CHAN_WEAPON);
				AmmoUsed = 0;
			}
			MARL A 4 {RemovedOldMag = False; bNoPain = False;}
			MARL A 0 A_JumpIf (Crouching,"Crouch");
			Goto See;	
		Pain:
			TNT1 A 0
			{
				Maneuvering = False;
				
				//In case the marine was evading when hurt.
				Evading = StrafeAttack = False;
				PreviousProjectile = NearbyProjectile;
				DodgeDelay = 35;
				NearbyProjectile = Null;
				StrafeDirection = STRAFE_NONE;
			}
			TNT1 A 0 A_JumpIf (OnTurret,"TurretSee"); //Just in case the NoPain flag somehow fails, while the marine is still on a turret.
			TNT1 A 0 A_SetSpeed (Default.Speed); //In case you were hurt during RunForReload.
			TNT1 A 0 A_JumpIf (Crouching,2);
			PLAY G 10 A_Pain();
			Goto See;
			MARP F 10 A_Pain();
			MARP F 0
			{
				//Turn off the crouching variable to run the shorter cover check of the marine. To check if the marine is covered properly still,
				//After being thrust back from the attack that hurt him. 
				Crouching = False;
				A_Pain();
				If (!SM_CanCrouch())
				{
					Height = Default.Height;
					Return ResolveState ("See");
				}
				Crouching = True;
				
				Return State (Null);
			}
			Goto Crouch+1;
	}
}