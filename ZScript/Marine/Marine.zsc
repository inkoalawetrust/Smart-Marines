//TODO:
//Add a User_NoReload variable, making marines not use their magazine ammo when shooting, and by extension not needing to ever reload. 

//IDEA:
//Give them Flashbangs.
//Make marines fire at dangerous objects near their target like explosive barrels.

Class SM_Marine : KAI_Humanoid
{
	Default
	{
		//$Title AI Marine
		//$Category Marines
		//$Sprite MARIH1
		Health 100;
		GibHealth 20;
		Height 56;
		DeathHeight 12;
		CameraHeight 50;
		Radius 16;
		YScale 0.98;
		Mass 100;
		Speed 10;
		FastSpeed 12;
		MeleeRange 64;
		PainChance 96;
		PainThreshold 5;
		FriendlySeeBlocks 64;
		MaxDropOffHeight 64;
		MaxTargetRange 8192;
		MinMissileChance 100;
		ShadowAimFactor 0.7; //Marines can somewhat see through shadows.
		Tag "Marine NPC";
		Species "Military";
		Decal "BulletChip";
		Obituary "%o was shot to death by a marine.";
		HitObituary "%o got %p head smashed in by a marines' rifle.";
		DropItem "Clip";
		DropItem "Clip", 128, 2;
		DropItem "ClipBox", 64;
		PainSound "Marine/Pain";
		DeathSound "Marine/Death";
		KAI_Actor.ThreatLevel THREAT_ABOVENORMAL;
		KAI_Actor.ThreatLevelThreshold THREAT_VERYDANGEROUS; //Marines are only really scared of super dangerous enemies like bosses and enemy vehicles.
		KAI_Actor.Inaccuracy (8,8,8);
		KAI_Actor.InaccuracyFrequency 0.8;
		Monster;
		//+JumpDown;
		+MissileMore;
		+MissileEvenMore;
		+Telestomp;
		+NoInfightSpecies;
		+FloorClip;
		+AvoidMelee;
		+AvoidHazards; //This ONLY works for crushing ceilings and NOTHING ELSE. So it's largely useless but I'm still adding it.
		+SeeFriendlyMonsters; //No more ZScript code hacks.
		//+DropOff;
	}
	
	Override Void BeginPlay ()
	{
		Super.BeginPlay();
		
		//Height variation, very realistic.
		Double XMul = FRandom (0.95f,1.05f);
		Double YMul = FRandom (0.90f,1.10f);
		Scale.X *= XMul; //Dwarfmaxxing
		Scale.Y *= YMul;
		//The biggest marines are slightly stronger.
		If (YMul >= 1.06)
			Health += 5;
		If (XMul >= 1.03)
			Health += 5;
		StartHealth = Health;
		
		//Head facing variation, very non-deterministic.
		State LeState = SpawnState;
		Int Forwards = Random (0,8);
		For (Int I; I < Forwards*8; I++)
		{
			LeState = LeState.NextState;
		}
		SetState (LeState,True);
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		MarineState = MARINE_IDLING;
		/*If (bFriendly)*/ CurrentOrder = ORDER_FOLLOW; //Marines follow whoever their boss is by default, including hostile ones.
		FollowDist = 128+Random (-16,48);
		FollowDist = Clamp (FollowDist,0, INT.MAX); //In case the variable becomes configurable.
		AmmoCount = MAGAZINE_SIZE;
		
		If (!(User_Armor ~== "None" || User_Armor ~== "Nothing")) //If the marine doesn't explicitly spawn unarmored.
		{
			If (!User_Armor || User_Armor ~== "" || User_Armor ~== " ") //Default armor.
				GiveInventory ("GreenArmor",1);
			Else
				GiveInventory (User_Armor,1); //Try giving whatever armor available in the current session that the mapper wants.
		}
		
		//Set attack states.
		MissileState = FindState ("Fire",True);
		MeleeState = FindState ("Melee",True);
		//The melee state should be passed automatically, since I have a state just called "Melee"
		AttackStates.Push (FindState ("Fire",True));
		AttackStates.Push (FindState ("Fire.Loop",True));
		AttackStates.Push (FindState ("Jump.Dodge.Attack",True));
		AttackStates.Push (FindState ("Grenade",True));
		
		//That's a lot of melee states.
		AttackStates.Push (FindState ("Melee",True));
		AttackStates.Push (FindState ("Melee.Smack",True));
		AttackStates.Push (FindState ("Melee.Kick",True));
		AttackStates.Push (FindState ("Melee.Kick.Run",True)); //Technically an attack state, since he enters this to get up into melee range.
		AttackStates.Push (FindState ("Marine.Jumpkick",True));
		AttackStates.Push (FindState ("Marine.Jumpkick.Attack",True));
		AttackStates.Push (FindState ("Marine.Jumpkick.End",True));
		
		NearbyCoverPos = (Double.NaN, Double.NaN, Double.NaN);
		LastSeenPos = (Double.NaN, Double.NaN, Double.NaN);
	}
	
	Override Void Tick()
	{
		Super.Tick ();
		
		If (IsFrozen() || IsDead(Self) || Alternative) Return;
		
		//Every tic that the marine is in a non-melee attack state, and not attacking mid-dodge, perform target prediction.
		//NOTE: Hmm, should they do target prediction when throwing grenades too ?
		If (/*GetAge() % 4 == 0 && */!(MarineState & MARINE_MELEE) && IsInAttackState() && !IsInState (Self,"Jump.Dodge.Attack"))
		{
			If (!IsInState (Self,"Grenade"))
				AimAtTarget (8/**4*/,8/**4*/,flags:AimPos,attackspeed:170,200);
			Else //Grenade target prediction.
				AimAtTarget (8/**4*/,8/**4*/,flags:AimPos,attackspeed:30,30);
		}
		
		//The SpriteRotation render property is only ever used to make marines visually back off from enemies when chasing them in See:.
		If (SpriteRotation != 0 && !IsInState(Self,"See"))
			SpriteRotation = 0;
		
		Int Age = GetAge();
		//Update on whether or not the marine is berserking.
		If (Age % GameTicRate == 0)
		{
			If (DeadDogTimer || CountInv("PowerStrength"))
			{
				HasBerserk = True;
				bAvoidMelee = False;
			}
			Else
			{
				HasBerserk = False;
				bAvoidMelee = True;
			}
			HasNods = CountInv("PowerLightAmp");
			bSeeInvisible = !HasNods ? Default.bSeeInvisible : True;
		}
		//if (debugpoint) debugpoint.setorigin(getattacklocation(),true);
		If (CountInv("SM_DogRageToken") && IsInState (Self,"AskDog"))
		{
			Actor Killer = SM_DogRageToken(FindInventory("SM_DogRageToken",True)).DogKiller;
			If (Killer && Killer.Player && FindDeadDogs (384,Killer) >= 3) //Killed too many dogs, probably at once.
			{
				Actor a = Spawn ("c65d3dfcb9b85e04ea7e82f81789b569");
				If (a) a.target = Killer;
				Killer = Null;
			}
			If (Killer)
			{
				DaDog = Null;
				Target = Killer;
				TakeInventory ("SM_DogRageToken",1);
				SetStateLabel ("Melee.OnePunch");
			}
		}
		
		//If (KAI_DebugPrintMessages)Console.Printf ("Current marine velocity %.2f %.2f %.2f, gravity %.3f, altitude %.2f, height %.2f",Vel,GetGravity(),GetZAt (),pos.z);
		
		//The clocks.
		If (NextFireDelay && !(MarineState & MARINE_FIRING)) //Decrement the firing delay, if any, for as long as the marine is not shooting.
			NextFireDelay--;
		
		If (JumpKickDelay && !(MarineState & MARINE_MELEE)) //Time before the marine does a flying kick again.
			JumpKickDelay--;
		
		If (GrenadeDelay && !(MarineState & MARINE_FIRING)) //Time until next grenade throw.
			GrenadeDelay--;
		
		If (HealDelay) //Time until next heal.
			HealDelay--;
		
		If (ReloadDelay)
			ReloadDelay--;
		
		If (DeadDogTimer) //RAAAAAAH
			DeadDogTimer--;
		
		If (TurretDelay > 0)
		{
			//Check every half second that we're waiting before using a turret again for anything that should decrement the timer faster.
			If (Age % GameTicRate/2 == 0)
			{
				//The more dangerous, the quicker the cooldown ends.
				Switch (AssessThreatLevel(Target) >= ThreatLevel)
				{
					Case THREAT_UNSTOPPABLE:
					Case THREAT_SUPERDANGER:
						TurretDelay = 0; //Search NOW.
						Break;
					Case THREAT_VERYDANGEROUS:
						TurretDelay -= 20;
						Break;
					Case THREAT_DANGEROUS:
						TurretDelay -= 10;
						Break;
					Default:
						Break;
				}
			}
			TurretDelay--;
		}
		
		//Check if the turret we wanna go to is occupied or unreachable.
		If (TargetTurret && Age % 8 == 0 && !ShouldUseTurret(TargetTurret,False,True))
			TargetTurret = KAI_Emplacement(FindEmplacements());
		
		//Update primary hazard to avoid every 4 ticks. Also handle altering target prediction inaccuracy here. And EMITING hazards when shooting.
		If (Age % 4 == 0)
		{
			HazardToAvoid = GetStrongestHazard(Hazards);
			
			If (MarineState & MARINE_FIRING)
			{
				Bool Aeiou; TraceResults Data;
				[Aeiou, Data] = SM_CheckLOF(FirePos,0,True);
				//Don't alert other marines, they can just dodge it, so don't make each other get stuck aim dodging.
				If (Data && Data.HitActor && !(Data.HitActor Is "SM_Marine"))
				{
					HazardInfo Hazard = New ("HazardInfo"); //Create hazard information.
					If (Hazard)
					{
						Array <String> Tags;
						Tags.Push ("Bullet");
						Hazard.Position = Data.HitPos;
						Hazard.Origin = Self;
						Hazard.Range = 32;
						Hazard.Type = HazardInfo.HAZARD_ATTACK;
						Hazard.Level = HazardInfo.HAZARD_MEDIUM;
						//Hazard.Flags = Flags;
						Hazard.CustomTags.Copy (Tags);
					}
					HazardInfo.GiveHazard(Data.HitActor,Hazard);
				}
			}
			
			//Note: Lol, literally all of this is my own code.
			//Handle increasing the marines' inaccuracy when attacking at shadow actors or through shadow blockers like smoke screens.
			If (IsInAttackState())
			{
				Bool Found; Actor Ghost; Double Penalty = 1.0;
				[Found, Ghost, Penalty] = PerformShadowChecks(Null,Level.Vec3Offset(Pos,FirePos));
				If (!bSeeInvisible || bSeeInvisible && !bShadowAim)
					Penalty = 1;
				
				//Predict the targets' trajectory with less noise when locking in.
				If (MarineState & MARINE_INCOVER || MarineState & MARINE_KNEELING || MarineState & MARINE_LYINGDOWN)
					Inaccuracy = (2,2,2)*Penalty;
				Else
					Inaccuracy = Default.Inaccuracy*Penalty;
				
				If (!Found && Target && Target.bShadow && !bSeeInvisible)
					Inaccuracy *= Target.ShadowPenaltyFactor != 1.0 ? Target.ShadowPenaltyFactor : 2;
			}
		}
		
		//Check dodging every 2 ticks.
		If (Age % 2 == 0)
		{
			//Don't dodge if in any of the pain or jump states (Already), or if climbing.
			If (!InStateSequence (CurState,FindState("Pain")) &&
			!InStateSequence (CurState,FindState("Jump")) &&
			!IsInState (Self,"Climb"))
			{
				Actor Misl = SM_ShouldDodgeProjectile(ignore:LastDodged);
				If (SM_HandleDodging (Misl))
				{
					LastDodged = Misl;
					If (MarineState & MARINE_INCOVER) //Marines in cover can hide from the same projectile.
						LastDodged = Null;
				}
			}
		}
	}
	
	Override Int TakeSpecialDamage (Actor Inflictor, Actor Source, Int Damage, Name DamageType)
	{
		Int Dam = Super.TakeSpecialDamage (Inflictor, Source, Damage, DamageType);
		
		If (MarineState & MARINE_INCOVER || HasBerserk && DeadDogTimer) //Take less damage when John Wick, or when crouching.
			Dam *= 0.8;
		
		Return Dam;
	}
	
	Override Bool OkayToSwitchTarget (Actor Other)
	{
		Bool DoSwitch = Super.OkayToSwitchTarget (Other);
		
		//If behind cover and damaged by an enemy that's not already your target, be very likely to switch to them, to get out of cover.
		If (MarineState & MARINE_INCOVER && Other != Target && IsActorHostile (Other) && Random (0,255) < 200)
			Return True;
		
		Return DoSwitch;
	}
	
	Override Void Die (Actor Source, Actor Inflictor,Int DMGFlags,Name MeansOfDeath)
	{
		Super.Die (Source,Inflictor,DMGFlags,MeansOfDeath);
		
		SM_EndFiring();
		QuickMelee = False;
		UseSec = Null;
		HealTarget = DaDog = Null;
		ChaseTimer = 0;
		bNoFriction = Default.bNoFriction;
		bNoGravity = Default.bNoGravity;
		RetreatPos = NearbyCoverPos = (Double.NaN, Double.NaN, Double.NaN);
		TauntTarget = Null;
	}
	
	Override Bool CanCollideWith (Actor Other, Bool Passive)
	{
		If (User_AllyClip && Other && !IsInanimateObject(Other) && !IsActorHostile (Other)) Return False;
		
		Return Super.CanCollideWith(Other, Passive);
	}
	
	Override Void UserVariableDefaults()
	{
		Super.UserVariableDefaults();
		
		If (User_HealCooldown == 0)
			User_HealCooldown = 40;
		If (User_AlertRange == 0)
			User_AlertRange = 512;
		If (User_GrenadeThreshold == 0)
			User_GrenadeThreshold = MARINE_GRENADECHANCE;
		If (User_RetreatFactor == 0)
			User_RetreatFactor = 1.0;
		If (User_TurretDelay == 0)
			User_TurretDelay = 8*GameTicRate;
		If (User_TauntChance == 0)
			User_TauntChance = 64;
		
		SM_HandleMarineColoring (User_Color);
	}
	
	//Marines have 3 attacks, shooting, throwing a grenade, and melee. The first two need to return where those attacks will actually go.
	Override Vector3 GetAttackLocation()
	{
		If (MarineState & MARINE_FIRING || MarineState & MARINE_THROWING && GrenadeType != GRENADE_SMOKE)
		{
			Bool Ok; TraceResults Result;
			[Ok, Result] = SM_CheckLOF(FirePos,AttackType == FIRE_SINGLE ? 0 : 50,True);
			Return Result.HitPos; //Return where the LOF trace ended up at.
		}
		Return Super.GetAttackLocation(); //Return default KAI_Humanoid function, presumably just the targets' position.
	}
	
	//Hack variables to handle when the area ally alerts should be emitted, since I'm not sure where they should even be handled lol.
	Private Actor SMOldTarget;
	
	Vector3 FirePos; //Exists in general, for GetAttackLocation().
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!Target || Target == Goal) Return False; //Don't attack if you have no target or just following a goal.
		If (!CanAttack() || !CanBeTargeted(Self,Target) || IsInanimateObject (Target)) Return False;
		If (SMOldTarget != Target)
		{
			SMOldTarget = Target;
			SM_AlertNearbyAllies (User_AlertRange); //Alert friends of each new target.
		}
		FirePos = (0,-6,42); //Default firing position.
		Int Threat = AssessThreatLevel (Target,False);
		
		//Check if you should fire your gun.
		Double Dist = Distance3D (Target);
		
		GrenadeType = DecideGrenadeType (Target, User_GrenadeThreshold);
		
		Double OldHeight = Height;
		If (Crouching && MarineState & MARINE_INCOVER)
		{
			Height = Default.Height; //Uncrouch marine for the firing check if he's behind cover.
			FirePos.Z += 4; //Give a more leeway when firing out of cover.
		}
		
		//Random chance that the marine might decide to fire lying down. Like kneeling, this scales with distance as well, but less, for even larger distances.
		Bool MightLie = (Random (0,255) < 24 + KAI_Math.LinearMap(Dist,0,MaxTargetRange,0,255));
		Vector3 LiePos = FirePos; LiePos.Z = 14;
		If (!(MarineState & MARINE_INCOVER) && MightLie && PitchTo (Target,Height/2,Target.Height/2) >= -15 && SM_CheckLOF (LiePos)) //If you decided to lie down and can do so, then we are good.
		{
			SM_SetMarineState (MARINE_LYINGDOWN,0);
			FirePos = LiePos;
		}
		
		//If (Random (0,255) < 192 && DetermineHitChance (Target,False,Dist,1.1,10,FirePos,range:MaxTargetRange,GetAimPosOffset()) <= Random (6,9))
		//Decide to sometimes fire kneeling down, particularly scaling linearly with distance.
		If (!(MarineState & MARINE_LYINGDOWN) && Random (0,255) < 32 + KAI_Math.LinearMap(Dist,0,MaxTargetRange/2,0,255) && SM_CheckLOF ((0,0,30)))
		{
			SM_SetMarineState (MARINE_KNEELING,0);
			FirePos.Z = 30; //Lower firing height.
		}
		
		//Sometimes, be less afraid to do melee if the enemy is weak enough. Even without berserk.
		If (bAvoidMelee && NearestEnemy && Random (0,255) < 64 && AssessThreatLevel (NearestEnemy) <= THREAT_ABOVENORMAL)
		{
			If (!NearestEnemy.MissileState && NearestEnemy.Health <= 50 || //If they are melee only and weak enough.
			NearestEnemy.MissileState && NearestEnemy.Health <= 20) //But even if they are ranged, but VERY weak.
				MeleeNearest = True;
		}
		If (!NearestEnemy) MeleeNearest = False;
		
		//If low on ammo, do a quick melee attack on your enemy instead, if its' close enough and less dangerous than you. And then retreat to reload.
		QuickMelee = (AmmoCount <= 4 && Threat < Self.ThreatLevel && Dist <= MeleeRange*3);
		If ((GrenadeType == GRENADE_NONE || Crouching) && !QuickMelee && !MeleeNearest && !NextFireDelay && SM_CheckLOF (FirePos,50))
		{
			Height = OldHeight;
			Double Buff = SM_IsCrouched() ? 0.5 : 1.0;
			Vector4 SSpread = (0.4*Buff,-0.4*Buff,0.4*Buff,-0.4*Buff); //Single shot spread.
			Vector4 BSpread = (1.1*Buff,-1.1*Buff,1.1*Buff,-1.1*Buff); //Burst fire spread.
			Vector4 FSpread = (2.2*Buff,-2.2*Buff,2.2*Buff,-2.2*Buff); //Full auto spread.
			
			//NOTE: The random numbers allow marines to sometimes decide to use a different sub-optimal firing mode, for variety.
			If (!NoStateJump)
			{
				//If the target is dangerous, or it's at least above normal, and you'd hit it at least 8 times (Counts multiple enemies too, for "crowd control").
				//Fire a burst instead too sometimes.
				Int FullAutoThreshold = (Health <= SpawnHealth()/6) ? 6 : 12; //If low on health, the marines will more desperately fire full auto.
				
				Int AutoChance = 128;
				If (Dist >= 4096) AutoChance -= 64; //Lower chance of firing full auto even at dangerous enemies, if they are too far.
				If (TargetTurret) AutoChance -= 96; //Even lower if we're kinda supposed to be going to superior firepower.
				Bool DoFullAuto = (Random (0, 255) < AutoChance);
				
				If ((DoFullAuto && Threat >= THREAT_DANGEROUS ||
				DetermineHitChance (Target,!SM_DumbHitCheck,Dist,2.2,15,FirePos,FSpread,MaxTargetRange,GetAimPosOffset(),DHC_THRUHOSTILES) >= FullAutoThreshold))
				{//https://youtu.be/LPAEgHsJYxk?si=4EdaE-oCczn5ehDD&t=75
					BurstSize = MAGAZINE_SIZE;
					AttackType = FIRE_FULLAUTO;
				}
				//If your enemy is weak.
				Else If (Random (0, 255) >= 3 && (/*Threat < THREAT_ABOVENORMAL ||*/
				//Or you decided against full auto, but would hit the non-weak enemy at least twice.
				DetermineHitChance (Target, !SM_DumbHitCheck, Dist, 1.1, 3, FirePos, BSpread, MaxTargetRange, GetAimPosOffset()) >= 2))
				{//Then fire a burst.
					BurstSize = 3;
					AttackType = FIRE_BURST;
				}
				Else
				{//Fall back to single accurate shots if neither full auto or bursts would work. Or just fire single shots instead sometimes.
					BurstSize = 1;
					AttackType = FIRE_SINGLE;
				}
				
				ChaseTimer = 0;
				SetStateLabel ("Fire");
			}
			FirePos = (0,-6,42);
			Return True;
		}
		Height = OldHeight;
		FirePos = (0,-6,42);
		
		If ((!Crouching || MarineState & MARINE_INCOVER) && GrenadeType != GRENADE_NONE)
		{
			If (!NoStateJump)
				SetStateLabel ("Grenade");
			Return True;
		}
		
		//Check if you should do melee. But only on weak-ish enemies.
		Int MeleeChance = bAvoidMelee ? 32 : 128;
		If (QuickMelee && Health < SpawnHealth()/4) //Additional melee chance if you are low on ammo but not on health.
			MeleeChance += 32;
		If (!HasBerserk && Health >= SpawnHealth()/3)
			MeleeChance -= 32; //Lower melee chance if you are low on health.
		If (HasBerserk && Health <= SpawnHealth ()/3) //Unless you have berserk, in which case be MORE likely to melee because it does more damage.
			MeleeChance += 64;
		If (!Crouching && (Random (0,255) < MeleeChance || MeleeNearest) && Threat < THREAT_DANGEROUS)
		{
			Bool CanSee = CheckSight(Target,SF_IGNOREWATERBOUNDARY);
			If (!CanSee) MeleeNearest = False;
			
			If (KAI_CheckMeleeRange (Target) && CanSee) //Check the standard melee range.
			{
				If (!NoStateJump)
				{
					FCheckPosition TM;
					Int DropkickChance = (bAvoidMelee ? 32 : 72)*FRandom (1.0f,2.0f);
					//It's not safe to jump this far, so don't do this.
					If (!CheckMove (Vec2Angle (64,AngleTo(Target)),PCM_NOACTORS|PCM_DROPOFF))
						DropkickChance = -1;
					//Check if the enemy can move this far back. And doesn't fly.
					If (!IsFlying (Target) && DropkickChance != -1 && CheckMove ( Target.Vec2Angle(128, AngleTo(Target) ),tm:TM))
					{
						//If there is a dropoff bigger than the targets' height, 128 MU from the direction you will face him at, be extra likely to punt him.
						If ((TM.FloorZ+Target.Height) <= Target.FloorZ)
							DropkickChance += RandomPick (20,30,40);
						
						//Major points if the enemy will actually be HURT by falling off.
						If ((Level.MonsterFallingDamage || Target.bFallDamage) && !(TM.CurSector.Flags & Sector.SECF_NOFALLINGDAMAGE))
							If (Target.ApplyDamageFactor ("Falling",100) > 0) //Also check if it has a damage factor making it immune to this damage.
								Dropkickchance += 50;
					}
					ChaseTimer = 0;
					//Might do a flying kick that knocks actors around.
					If (Random (0,255) < DropkickChance)
					{
						SetStateLabel ("Melee.Jumpkick");
						Return True;
					}
					//Randomly choose between kicks and rifle butts.
					If (Random (False,True) == True)
						SetStateLabel ("Melee.Smack");
					Else
						SetStateLabel ("Melee.Kick");
				}
				Return True;
			}
			//Check 4 times further sometimes. To do a running kick to the target, or the nearest enemy if meleenearest is true.
			Else If (!TargetTurret && CanSee && (Random (0,255) < (bAvoidMelee ? 88 : 224) || MeleeNearest) && KAI_CheckMeleeRange (Target,MeleeRange*4))
			{
				ChaseTimer = 0;
				If (!NoStateJump)
					SetStateLabel ("Melee.Kick.Run");
				Return True;
			}
		}
		
		Return False;
	}
	
	//Marines have identical criteria for if an actor is hostile as my MVP vehicles do.
	Override Bool IsActorHostile (Actor Other)
	{
		Return (Other && (IsHostile (Other) || IsTargetingAllies (Self, Other)));
	}
	
	Override Vector3, Actor HandleFollowingActor (Vector3 BasePos, Bool IgnoreDontFollowPlayers)
	{
		Vector3 Vec; Actor Act; [Vec, Act] = Super.HandleFollowingActor (BasePos, IgnoreDontFollowPlayers);
		
		//Friendly marine is too close to the friendplayer. So just wander instead to avoid overcrowding.
		If (FollowDist && Act && CurrentOrder == ORDER_FOLLOW && bFriendly && !Master)
		{
			Bool DistCheck = Distance3DSquared (Act) <= FollowDist*FollowDist;
			If (Act.Player) 
				bDontFollowPlayers = DistCheck;
			Else
			{
				bDontFollowPLayers = True;
				If (DistCheck) Return BasePos, Null;
			}
			If (DistCheck)
				Return BasePos, Null;
		}
		console.printf ("returning vec %d %d %d, actor %p",vec,act);
		Return Vec, Act;
	}
	
	Override Bool OnWander()
	{
		Super.OnWander();
		
		//BUG: Currently it seems that this code doesn't make them properly go back to See:, or at least, they don't actually chase the target despite having it.
		/*//Check if the friend player currently in sight of you is being attacked.
		If (bFriendly && Random(0,255) < 16 && KAI_Chase_FriendsAttackPlayerEnemies(0))
		{
			Actor PMo = Players[KAI_GetFriendPlayer()].Mo;
			If (Target && PMo && !CheckSight(PMo))
				Target = Null;
			Else 
			{
				console.printf ("coming to the rescue of inkoalawetrust");
				SetStateLabel ("See");
				Return False;
			}
		}*/
		
		If (CurrentOrder == ORDER_STAY)
		{
			SetStateLabel ("Spawn");
			Return False;
		}
		
		
		//Check if there's a line in front of us to use. If there is, go to the interact state and wait for it to finish.
		If (SM_MarineUseLine(faceline:True)) 
		{
			SetStateLabel ("Interact");
			Return False;
		}
		
		If (!SM_IsRestricted (RESTRICT_CROUCHING)) Crouching = KAI_HandleCrouching (Default.Height,MARINE_CROUCHHEIGHT);
		
		If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) && KAI_HandleClimbing(ClimbPos,JumpPos,"Climb","Jump.Up",1.1,1.75))
			Return False;
		
		If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) && SM_HandleClimbDown(Height*1.75)) //Handle jumping down any ledges that you can still climb up to if you want.
			Return False;
		
		Vector2 JumpPosition = (Double.NaN,Double.NaN);
		If (!SM_IsRestricted (RESTRICT_JUMPING)) JumpPosition = KAI_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
		If (JumpPosition == JumpPosition && !Crouching) //We have a valid position we must jump to, AKA the returned vector isn't null.
		{
			JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
			Bool Reachable = True; //Assume we can jump there by default.
			//The jump destination is longer than half the jump distance, so do a long jump if there's space behind you for it.
			If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5 && (Reachable = SM_CanRunBack()))
			{
				PreJumpPos = Vec3Angle(MARINE_JUMPRUNLENGTH,Angle-180);
				SetStateLabel ("Jump.Running");
				Return False;
			}
			Else If (Reachable) //If the gap is too short to do a running jump, do a normal one, but don't fall back to normal jumps for large gaps.
			{
				SetStateLabel ("Jump");
				Return False;
			}
		}
		
		//Handle avoiding major hazards first.
		If (SM_RunFromHazards())
			Return False;
		
		//Handle walking around minor hazards.
		RunAwayTypes HazardAvoidType = SM_ShouldRunFromHazard (HazardToAvoid);
		If (HazardAvoidType == RUN_WALK)
		{
			KAI_MoveAway (Null,anglelimit:20,TargPos:GetHazardOriginPos(HazardToAvoid));
			Return False;
		}
		
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		//Decide to help a pal out.
		If (!HealDelay && !HealTarget)
		{
			If (Random (0,255) < 24)
				HealTarget = SM_FindAllyToHelp();
		}
		Else If (HealTarget && !Crouching && Distance3DSquared (HealTarget) <= (MeleeRange + HealTarget.Radius)*(MeleeRange + HealTarget.Radius))
		{
			SetStateLabel ("HealAlly");
			Return False;
		}
		
		If (HealTarget) //We have someone to heal, so go do that instead of wandering or following a player.
		{
			KAI_MoveTowards (HealTarget.Pos, 0.5, 20, 0, 0);
			//Actor is back to full-ish health by the time we got there or dead.
			If (SM_GetMaxHealth (HealTarget) - 7 < HealTarget.Health || IsDead(HealTarget))
				HealTarget = Null;
			Return False;
		}
		
		If (Random (0,2048) == Random (0,2048) && !IsActorPlayingSound (CHAN_VOICE,"Marine/WhatDaDogDoin") && (DaDog = IsDogNearby()))
		{
			SetStateLabel ("AskDog");
			Return False;
		}
		
		//Sometimes just get on a nearby turret for shits and giggles, or in case something appears I guess.
		If (CurrentOrder == ORDER_WANDER && !TurretDelay && Random (0,255) < 8)
		{
			If (!TargetTurret) TargetTurret = KAI_Emplacement(FindEmplacements(512));
			Else
			{
				KAI_MoveTowards (TargetTurret.Pos,anglelimit:20);
				//We're in range to try using the turret we're heading to.
				If (TargetTurret && Distance3DSquared(TargetTurret) <= MeleeRange*MeleeRange)
				{
					TargetTurret.EnterEmplacement(Self);
					//We're on the machine gun the mod comes with in particular, so make us stay on it longer when idling.
					If (Emplacement && Emplacement Is "SM_MGTurret" && Emplacement.OperatorMorph)
						SM_MGTurretMarine(Emplacement.OperatorMorph).MarineFuckingAround = True;
				}
				Return False;
			}
		}
		
		//If the stars align and you are in the players' peripheral vision without them being in third person.
		PlayerInfo Client = Players[ConsolePlayer];
		Actor ClientMo = Client.Mo;
		If (Random (0,2048) == Random (0,2048) && !(Client.Cheats & CF_CHASECAM) && !SM_CheckFOV (ClientMo,Self,Players[ConsolePlayer].FOV/1.5) )
		{
			SetStateLabel ("MarineShaker");
			Return False;
		}
		
		Actor FollowTarget;
		Vector3 FollowPos;
		[FollowPos, FollowTarget] = HandleFollowingActor(FollowPos);
		//Marine is set to follow. Following the friendplayer is already handled by KAI_Wander() itself, so we just need to handle following the followtarget.
		If (CurrentOrder == ORDER_FOLLOW && FollowTarget)
		{
			//Only follow if you aren't too close to the FollowTarget already, to avoid crowding... unless you're supposed to be HEALING them!
			If (HealTarget != FollowTarget && Distance3DSquared(FollowTarget) >= FollowDist*FollowDist)
			{
				If (!bFriendly || bFriendly && bDontFollowPlayers)
				{
					If (IsDead (FollowTarget))
					{
						FollowTarget = Null;
						If (!bFriendly) SetNPCOrder (ORDER_WANDER);
						Else SetNPCOrder (ORDER_FOLLOW); //Friendly marines just begin following their player.
					}
					If (FollowTarget)
					{
						KAI_MoveTowards (FollowPos,anglelimit:20);
						Return False;
					}
				}
			}
		}
		
		Return True;
	}
	
	Override Bool OnOrderChange (NPCOrders NewOrder, Bool Increment, Actor Commander, Bool IgnoreAllegiance, Bool FromACS)
	{
		//We are being commanded by a player, so join their NPC group if you aren't in already, if the player doesn't have a group yet, make one for them.
		If (Commander && Commander.Player)
		{
			Array <KAI_NPCGroup> OtherGroups;
			Bool HasPlayerGroup;
			KAI_NPCGroup.FindGroupsImIn (Commander,OtherGroups);
			ForEach (Group : OtherGroups)
			{
				If (Group Is "SM_MarineGroup" && SM_MarineGroup(Group).IsPlayerGroup) //Player has a group for us to join.
				{
					If (KAI_DebugPrintMessages) Console.Printf ("OnOrderChange(): I was ordered by a player who already has their own group, so I'll join it.");
					PlayerGroup = SM_MarineGroup(Group);
					Group.AddNPCToGroup (Self);
					HasPlayerGroup = True;
					Break;
				}
			}
			
			If (!HasPlayerGroup)
			{
				If (KAI_DebugPrintMessages) Console.Printf ("OnOrderChange(): I was ordered by a player with no group, creating one for them.");
				Array <Actor> Members; Members.Push (Self); //Start by adding the ordered marine to the group.
				String TheName = Commander.Player.GetUsername ();
				TheName.AppendFormat ("'s fireteam"); //Default group name is "(Player names)'s fireteam", the fireteam string updates based on group size.
				KAI_NPCGroup.CreateGroup (TheName,Members,Commander,0,"SM_MarineGroup");
			}
		}
		Return True;
	}
	
	Override Void AfterOrderChange (NPCOrders OldOrder, Bool Increment, Actor Commander, Bool IgnoreAllegiance, Bool FromACS)
	{
		//Have marine idle to follow whatever actor, or if they are in the spawn state and set to wander aimlessly.
		If ((CurrentOrder == ORDER_FOLLOW || CurrentOrder == ORDER_WANDER) && IsInState (Self,"Spawn"))
			SetStateLabel ("Idle");
		
		//Make all actors in the groups you are follow your order, if you are leading.
		ForEach (Group : Groups)
		{
			If (Group.Leader != Self) Continue;
			ForEach (Member : Group.Members)
			{
				If (Member Is "KAI_Actor" && Member != Self)
				{
					If (KAI_DebugPrintMessages) console.printf ("AfterOrderChange(): setting order to %d for %p (%s)",currentorder,member,member.getclassname());
					KAI_Actor(Member).SetNPCOrder (CurrentOrder,False,Self);
					If (Member Is "SM_Marine")
					{
						If ((KAI_Actor(Member).CurrentOrder == ORDER_FOLLOW || KAI_Actor(Member).CurrentOrder == ORDER_WANDER) && IsInState (Member,"Spawn"))
							Member.SetStateLabel ("Idle");
					}
				}
			}
		}
	}
	
	Override Void OnEmplacementExit()
	{
		Super.OnEmplacementExit();
		TargetTurret = Null;
		If (!RetreatedFromTurret) TurretDelay = User_TurretDelay; //Don't constantly enter turrets. Unless we left because of a threat
		Else RetreatedFromTurret = False;
		If (MarineState & MARINE_RELOAD) SetStateLabel ("Reload"); //We needed to reload before getting on, in case we got to a turret in place of reloading.
	}
	
	Override Bool Used (Actor User)
	{
		Super.Used(User);
		
		If (!User || bDormant || IsDead(Self) || IsPatrolling (Self) || User_IgnoreOrders) //Ignore commands when busy patrolling or dormant.
			Return False;
		
		Bool Enemy = IsActorHostile (User);
		//Marines attack anyone (Almost certainly an enemy player.) trying to boss them by pressing use on them.
		If (!Target && MarineState & MARINE_IDLING && Enemy && CanBeTargeted (Self,User))
		{
			Target = User;
			Return True;
		}
		
		SetNPCOrder (0,True,User); //Loop through the order list.
		If (Enemy)
			Return False;
		A_StartSound ("Marine/Radio",CHAN_AUTO);
		
		Actor Text = Spawn ("SM_OrderText",Pos.PlusZ(Height));
		If (Text)
		{
			Switch (CurrentOrder)
			{
				Case ORDER_STAY:
					Text.SetStateLabel ("Standing");
					Break;
				Case ORDER_WANDER:
					Text.SetStateLabel ("Wandering");
					Break;
				Case ORDER_FOLLOW:
					Text.SetStateLabel ("FollowingPlayer");
					Break;
				Default: //Only got lines for the above commands.
					Text.Destroy();
					Break;
			}
		}
		
		Return True;
	}
	
	//Actions the marine is performing, can be stacked on each other like flags.
	Enum MarineStates
	{
		MARINE_IDLING 	= 1 << 0, //Bing chilling
		MARINE_CHASING	= 1 << 1, //Chasing someone.
		MARINE_FIRING 	= 1 << 2, //Shooting
		MARINE_THROWING	= 1 << 3, //Throwing a grenade
		MARINE_MELEE	= 1 << 4, //Beating someone up
		MARINE_RELOAD 	= 1 << 5, //Reloading
		MARINE_RETREAT	= 1 << 6, //GTFOing, assumed to be from some danger by default.
		MARINE_KNEELING	= 1 << 7, //Kneeling down.
		MARINE_LYINGDOWN= 1 << 8, //Lying down on the ground.
		MARINE_INCOVER	= 1 << 9, //Taking cover
		//MARINE_PATROL	= 1 << 10, //Patrolling
	}
	
	Const MARINE_HEARDIST = 4096; //How far can the marine hear.
	Const MARINE_FOV = 120; //How wide the marine can see.
	Const MAGAZINE_SIZE = 30; //How much ammo does the marine have per magazine ?
	Const MARINE_USEPATIENCE = 10; //How long the marine stays in the interact state before giving up and beginning to move again.
	Const MARINE_CHASETIME = 350; //Chase your target for approximately 30 seconds after he has gone out of sight or died, before going to your idle state.
	Const MARINE_GRENADECHANCE = 96; //The default chance threshold over which the marine will throw a grenade if in range.
	Const MARINE_GRENADERANGE = 1024; //How far can the marine roughly throw a grenade?
	Const MARINE_JUMPLENGTH = 288; //How far the marine can jump to cross obstacles.
	Const MARINE_JUMPRUNLENGTH = 256; //How far back the marine runs to do a running jump for particularly long obstacles.
	Const MARINE_CROUCHHEIGHT = 30; //The height the marine crouches down to.
	
	Mixin SM_SplashFunctions;
	
	//AI variables
	Int MarineState; //What the marine doin'.
	Actor NearestEnemy; //The marines' closest enemy, used to stay away from enemies.
	Int RetreatLoops; //How many times the retreat state should be called.
	UInt8 InteractWaits; //Keeps track of how many times the interact state loops before the marine gives up waiting on the sector he used to stop.
	Int AimPos; //Where is the marine aiming ? Similar to the TurretAimPos on the vehicles.
	Int AimTimer; //If the marine has been trying to aim and fire at the target for this long, then it's not working.
	Int ChaseTimer; //How long has the marines' target being dead or out of sight ?
	Actor TauntTarget; //The guy we are taunting.
	
	//Hardcore parkour stuff.
	Vector3 ClimbPos; //Where the marine will move at after climbing up a sector in his climb state.
	Vector3 JumpPos; //Where the marine must jump to in his jump state.
	Vector3 PreJumpPos; //Where the marine will start his running jump. Used to make the marine walk back and run forward to jump over very big gaps.
	/*Private*/ Bool Crouching; //If true, the marine is currently crouching.
	
	HazardInfo HazardToAvoid; //What hazard from his Hazards array should the marine be currently trying to avoid ?
	Vector3 RetreatPos; //The position the marine retreats from, if this is not NaN, the retreat state runs from this coordinate instead of the target actor.
	Actor LastDodged; //The last projectile the marine dodged.
	Bool DodgingHomingProjectile; //The marine is in his Retreat: state because he is dodging a homing projectile, AKA running away.
	Vector3 LastSeenPos; //The last position the target was seen at while chased by the marine. Used to make them head there first before resuming normal chasing.
	KAI_Emplacement TargetTurret; //The turret the marine is trying to go to.
	
	SM_MarineGroup PlayerGroup; //The group of the player you're following.
	
	//Healing variables
	Actor HealTarget; //Who to walk up to and heal.
	//Int HealTravelTime; //Decrement while the marine goes to heal an ally, in case he gets stuck or something.
	Int HealDelay; //Time until next heal.
	
	//Shooting variables.
	Int AmmoCount; //How much ammo the marine has.
	Int BurstCounter; //Used by the burst fire tracking.
	Int BurstSize; //How many shots to fire.
	UInt8 NextFireDelay; //How long until the marine can shoot again, so that they don't shoot constantly. This can only be a ~7 second delay at most.
	Int AttackType; //How is the marine firing his gun ?
	Bool RemovedOldMag; //Used for reloading, if the marine was interrupted by flinching mid-reload, this skips the part where he throws the old magazine out.
	UInt8 ReloadDelay; //Wait before the marine can try reloading. Prevents them from sometimes being stuck in a loop of
	Bool HasNods; //Marine has the light amp goggles, meaning he can see through shadows.
	Enum RifleFireModes
	{
		FIRE_BURST, //Fire a 3 round burst like the base M4 Carbine. Decently accurate.
		FIRE_SINGLE, //Fire a single accurate shot.
		FIRE_FULLAUTO, //Fire everything, pretty inaccurate, adds recoil, and faster than normal fire.
	}
	
	//Other attacks, melee, grenade, emplacements.
	Bool HasBerserk; //Has an active berserk pack.
	Int JumpkickDelay; //How long before the marine does a flying kick again.
	Bool QuickMelee; //If the marine does a melee attack while this is on, he will retreat a bit before going back to See.
	Bool MeleeNearest; //Hit the closest enemy realy quick.
	Bool QuickGrenade; //Marine quickly throws a grenade in front of him to retreat.
	Int GrenadeDelay; //How long until the marine throws another grenade.
	UInt8 GrenadeType; //What grenade are we throwing exactly ?
	Int TurretDelay; //How long until we decide to go on a turret again?
	Bool RetreatedFromTurret; //The marine left his last emplacement (Almost certainly the ones in this mod) because a of a threat, so do NOT set a turret delay.
	
	//Dawg
	Int DeadDogTimer; //Incremented up by SM_MarineHandler when a friendly dog dies near a friendly marine, makes the marine furious.
	Vector3 PreOnePunchPos;
	Actor DaDog;
	
	Enum GrenadeTypes
	{
		GRENADE_NONE, //No grenade
		GRENADE_HEFRAG, //Exploding+Fragmenting grenades, useful both for crowds and +NORADIUSDMG foes like Cyberdemons due to the hitscan shrapnel.
		GRENADE_HE, //Pure exploding with no frag jacket. Bigger boom and even better for crowds, AND powerful enemies vulnerable to blasts like the MBT. But not +NORADIUSDMG.
		GRENADE_SMOKE, //No damage, just throws off +DOSHADOWBLOCK monsters, allowing marines to conceal themselves against powerful enemies and/or while retreating.
		GRENADE_STUN, //Flashbang, useful for stunning/painlocking anything without +NOPAIN, including players. Stun time depends on threat level.
	}
	
	String User_Armor; //The name of the armor the marine should be equipped with upon spawning. Default is the vanilla green armor.
	String User_Color; //What color is the marine ?
	Bool User_IgnoreOrders; //Marine ignores orders given to them by players trying to press use on them.
	Bool User_NoWeaponDrop; //The marines never drop their rifles. When I implement other marine types, they won't drop their respective weapons either.
	Bool User_NoParkour; //Marine only has normal monster movement.
	Int User_HealCooldown; //How often, in seconds, the marine can give stimpacks to friends, default is 40 seconds.
	Bool User_NoCover; //Marines never take cover from enemies.
	Double User_AlertRange; //How far away marines can alert KAI NPC allies. For group members that can be alerted regardless of distance, that is turned off if the range is -1s or less.
	Int User_GrenadeThreshold; //How likely is the marine to throw a grenade? The lower it is the more likely he is. -1 means no grenades, default is 96
	Double User_RetreatFactor; //A multiplier for how much marines run away, i.e a value of 0.5 makes them take half the amount of retreat steps, roughly.
	Int User_TurretDelay; //The delay, in tics, that the marine waits for before using a turret again, default is 8 seconds.
	Int User_TauntChance; //How likely the marine is to taunt a powerful enemy they killed if safe to do so, twice as likely if beaten to death. Default is 64; 
	Bool User_NoReload; //Marine does not use ammo when firing, essentially never needing to reload.
	Bool User_AllyClip; //Marine can phase through NPCs and players friendly to them.
	
	States
	{
		Crouch_Sprites: //Caching to not have GetSpriteIndex() crash shit.
			MARC ABCEDF 0;
		//When the marine is looking around with this animation, he actually changes his sight angle.
		Spawn:
			MARI EEEEEEEE 3 //Look 80 degrees to your left.
			{
				Angle += 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle -= 80;
				If (Target) SetStateLabel ("See");
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			MARI FFFFFFFF 3 //Look 20 degrees to your right.
			{
				Angle -= 20;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 20;
				If (Target) SetStateLabel ("See");
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			MARI GGGGGGGG 3 //Look 80 degrees to your right.
			{
				Angle -= 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 80;
				If (Target) SetStateLabel ("See");
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			MARI HHHHHHHH 3
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV); //Just look straight.
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			Loop;
		Idle:
			MARI A 0 SM_SetMarineState (MARINE_IDLING,0,True); //No more acting, only bing chilling.
			MARI AABBCCDD 3
			{
				If (Crouching) Sprite = GetSpriteIndex ('MARC');
				Else If (!Crouching && Sprite == GetSpriteIndex ('MARC')) Sprite = GetSpriteIndex ('MARI');
				
				Double NormalSpeed = Speed;
				If (HealTarget || CurrentOrder == ORDER_FOLLOW) //Run to heal someone, or if following someone.
					Tics = 2;
				KAI_Wander(8,768,anglelimit:20); //See the OnWander() override.
				Speed = NormalSpeed;
				
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET);
			}
			MARI D 0 
			{
				//Dump the heal target if it's out of reachable.
				If (!HealDelay && HealTarget && (!CheckSight (HealTarget,SF_IGNOREWATERBOUNDARY) || !SM_IsPosReachable(HealTarget.Pos,ignoreactors:True)))
					HealTarget = Null;
				
				If (!Crouching && !HealTarget && !IsPatrolling (Self) && (CurrentOrder != ORDER_FOLLOW && (Master || bFriendly))) //Might stand around if not busy.
					Return A_Jump (4,"Idle.Stay","Idle.Stay.Alert"/*,"Idle.Stay.Kneel"*/);
				
				If (Random (0,255) < 8 && !Target && AmmoCount <= MAGAZINE_SIZE/2 && !Crouching && !HealTarget) //Go and pre-emptively reload.
					Return FindState ("Reload",True);
				
				Return State (Null);
			}
			Loop;
		Idle.Decide: //Decide a random stay state to enter, for when patrolling and you reach a delayed point.
			TNT1 A 0 A_Jump (127,"Idle.Stay.Alert");
		Idle.Stay: //Staying around idle. Exactly like in the spawn state.
			MARI EEEEEEEE 3 //Look 80 degrees to your left.
			{
				Angle += 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle -= 80;
				If (Target) SetStateLabel ("See");
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			MARI FFFFFFFF 3 //Look 20 degrees to your right.
			{
				Angle -= 20;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 20;
				If (Target) SetStateLabel ("See");
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			MARI GGGGGGGG 3 //Look 80 degrees to your right.
			{
				Angle -= 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 80;
				If (Target) SetStateLabel ("See");
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			MARI HHHHHHHH 3
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV); //Just look straight.
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			TNT1 A 0
			{
				If (Random (0,255) < 48 && !IsPatrolling (Self)) Return FindState ("Idle",True);
				Return State (Null);
			}
			Loop;
		Idle.Stay.Alert: //Standing there, menacingly.
			MARI IIIIIIIIIII 3
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET); //Roughly 1 second of staying still.
				If (HazardToAvoid) SetStateLabel ("Idle");
			}
			TNT1 A 0 A_SetAngle (Angle+RandomPick (40,30,20,10,0,0,-10,-20,-30,40));
			TNT1 A 0
			{
				If (Random (0,255) < 48 && !IsPatrolling (Self)) Return FindState ("Idle",True);
				Return State (Null);
			}
			Loop;
		//Idle.Stay.Kneel: //Standing around while kneeling down, can randomly pick this one. TG5 needs to make sprites for me to be able to add it though.
		See:
			TNT1 A 0 SM_SetMarineState (MARINE_CHASING,0,True,MARINE_INCOVER/*|MARINE_PATROLLING*/);
			MARF JJKKLLMM 3
			{
				//Handle taking cover, if you are not already crouching to move.
				If (!(Crouching && !(MarineState & MARINE_INCOVER) ))
				{
					If (SM_UpdateCover (Target,MarineState & MARINE_INCOVER))
						SM_StartCrouch();
					Else
						SM_EndCrouch();
				}
				
				Bool Reversing = SpriteRotation != 0; //Marine is backing off in SM_Chase().
				//Bloodied marine sprites.
				Bool Wounded = Health <= SpawnHealth()/4;
				If (!Crouching && Wounded)
				{
					Sprite = GetSpriteIndex('MARA');
					Switch (Frame)
					{
						Default:
							Break;
						Case 9: //J
							Frame = !Reversing ? 16 : 18; //Q or S
							Break;
						Case 10: //K
							Frame = 17; //R
							Break;
						Case 11: //L
							Frame = !Reversing ? 18 : 16; //S or Q
							Break;
						Case 12: //M
							Frame = 17; //R
							Break;
					}
				}
				
				//Remap movement animation, the actual hitbox change is handled by SM_Chase(). Unless this is for running to cover or to a turret that is.
				If (Crouching || !KAI_Math.IsEmptyVector3 (NearbyCoverPos) && !Wounded || TargetTurret && !Wounded)
				{
					If (Crouching) Sprite = GetSpriteIndex ('MARC');
					Else If (!Crouching && (Sprite == GetSpriteIndex ('MARC') || !KAI_Math.IsEmptyVector3 (NearbyCoverPos)) ) Sprite = GetSpriteIndex ('MARI');
					If (!(MarineState & MARINE_INCOVER))
					{
						//Remap sprite frames, man this shit looks incomprehensible if you don't have like 4 years of experience making GZDoom mods.
						Switch (Frame)
						{
							Default:
								Break;
							Case 9: //J
								Frame = !Reversing ? 0 : 3; //A or D
								Break;
							Case 10: //K
								Frame = !Reversing ? 1 : 2; //B or C
								Break;
							Case 11: //L
								Frame = !Reversing ? 2 : 1; //C or B
								Break;
							Case 12: //M
								Frame = !Reversing ? 3 : 0; //D or A
								Break;
						}
					}
					Else
						Frame = 0; //Sit still, no movement animation when sitting behind cover.
				}
				
				//Don't look for cover when running to a turret.
				Int Flags = (!TurretDelay && !TargetTurret) ? SMC_SEARCHFORCOVER : 0;
				SM_Chase ("Idle.Decide","RunFromMelee",Flags,chaseflags:CHF_DONTIDLE);
			}
			TNT1 A 0 A_JumpIf (Random (0,255) < 8 && !Target && AmmoCount <= MAGAZINE_SIZE/2,"Reload"); //Reload if we have half ammo.
			Goto See+1;
		RunFromMelee:
			TNT1 A 0
			{
				If (Health > SpawnHealth()/3)
					RetreatLoops = 2;
				Else
					RetreatLoops = 4;
				
				If (Target)
				{
					If (Target.MeleeState && !Target.MissileState)
						RetreatLoops += 2; //Run extra far for melee-only monsters.
					
					RetreatLoops += Int (Target.Speed/5); //Also add additional retreats for each additional bit of speed the target has, to run further from faster monsters.
				}
				RetreatLoops -= CheckSpaceSize (384,384,16);
			}
		Retreat: //Run away a certain number of steps.
			TNT1 A 0
			{
				SM_SetMarineState (MARINE_RETREAT, MARINE_IDLING|MARINE_CHASING|MARINE_INCOVER);
				NearbyCoverPos = (Double.NaN, Double.NaN, Double.NaN);
			}
			MARI AAABBBCCCDDD 1
			{
				Double RealSpeed = Speed;
				If (Crouching)
				{
					Sprite = GetSpriteIndex ('MARC');
					Speed *= 0.85;
				}
				If (DodgingHomingProjectile && LastDodged)
				{
					RetreatPos = LastDodged.Pos; //Update the retreat position every step, since the projectile moves.
					Speed *= 1.1; //Also move a little FASTER.
					//Homing projectile is very close, duck down to try throwing it off.
					If (!SM_IsRestricted (RESTRICT_CROUCHING))
					{
						Bool Dist = (Distance3DSquared (LastDodged) <= (MeleeRange*MeleeRange)*2);
						If (Dist && !Crouching)
							SM_StartCrouch();
						Else If (!Dist)
							SM_EndCrouch();
					}
					
				}
				SM_RunAway (Target,192);
				Speed = RealSpeed;
			}
			TNT1 A 0
			{
				RetreatLoops--;
				If (RetreatLoops <= 0 || !Target && !(DodgingHomingProjectile && LastDodged)) //Once we are done running like a bitch. Or if there's no target left.
				{
					RetreatPos = (Double.NaN, Double.NaN, Double.NaN);
					DodgingHomingProjectile = False;
					SM_SetMarineState (0,MARINE_RETREAT);
					//We are supposed to be reloading, so do that.
					If (MarineState & MARINE_RELOAD)
						Return FindState ("Reload",True);
					
					Return FindState ("See",True);
				}
				//Decrement twice as fast whenever the target is out of sight or dead. Unless we're running away from a homing projectile.
				If (!(DodgingHomingProjectile && LastDodged) && (IsDead (Target) || !CheckSight (Target,SF_IGNOREWATERBOUNDARY)))
					RetreatLoops--;
				Return State (Null);
			}
			Goto Retreat+1;
		Fire: //Aim up.
			TNT1 A 0
			{
				If (Crouching && MarineState & MARINE_INCOVER) //Marine is taking cover, but get up to actually shoot.
					Crouching = False;
				
				bNoFriction = Default.bNoFriction; //Just in case the marine somehow started firing mid-jump.
			}
			MARF A 0 SM_SetMarineState (MARINE_FIRING,MARINE_IDLING|MARINE_THROWING|MARINE_IDLING|MARINE_CHASING); //Set marine actions.
			MARF JJJ 2
			{
				SM_RunFromHazards();
				If (Health <= SpawnHealth()/4)
				{
					Sprite = GetSpriteIndex ('MARA');
					Frame = 16; //Q
				}
			}
			MARF A 2 //Wait until you can actually aim properly at the enemy.
			{
				SM_RunFromHazards();
				Frame = SM_UpdateElevation (13, 21, 17, 14, 23, 18, 7); //Standing up: N, V, R : Kneeling down: O, X, S : Lying down: H
				If (++AimTimer >= GameTicRate * 3) //https://www.youtube.com/watch?v=VX5gXHcbJAk
					Return FindState ("Fire.End",True);
				If (Target && CheckFOV(Target,160/2) && AimingAheadOfTarget())
					Return FindState ("Fire.Loop");
				Return State (Null);
			}
			Wait;
		Fire.Loop:
			MARF V 3 //Delay
			{
				If (SM_RunFromHazards()) //Handle abruptly running away from hazards when firing.
					SM_EndFiring();
				SM_UpdateHeight();
				Frame = SM_UpdateElevation (13, 21, 17, 14, 23, 18, 7); //Standing up: N, V, R : Kneeling down: O, X, S : Lying down: H
				If (Crouching)
					Sprite = GetSpriteIndex ('MARC');
				If (AttackType == FIRE_FULLAUTO)
					Tics = 2; //Fire faster in full auto.
				If (AmmoCount <= 0) //Out of ammo.
				{
					A_StartSound ("VRifle/EmptyGun",CHAN_WEAPON,attenuation:ATTN_STATIC); //Marine tried dry firing.
					Return FindState ("Fire.End");
				}
				
				Return State (Null);
			}
			MARF E 3 Light ("MarineMuzzleFlash")
			{
				SM_UpdateHeight();
				Frame = SM_UpdateElevation (15, 22, 19, 16, 24, 20, 8); //Standing up: P, W, T : Kneeling down: Q, Y, U : Lying down: I
				If (Crouching)
					Sprite = GetSpriteIndex ('MARC');
				SM_FireBullet();
			}
			MARF A 0
			{
				//Look for a new target. Also taunt if nothing was found.
				If (AttackType == FIRE_FULLAUTO && !Target || IsDead (Target))
				{
					Actor OldTarget = Target;
					Bool FoundOtherEnemy = LookForPlayers (True);
					//No new enemy found, so the coast is clear. Decide to taunt or not.
					If (OldTarget && !FoundOtherEnemy && SM_CheckTaunt(OldTarget,User_TauntChance))
					{
						TauntTarget = OldTarget;
						Target = Null; //Target is dead.
						Return FindState ("Fire.End",True);
					}
				}
				
				//When firing, be likely to engage in melee if an enemy got too close.
				//The target itself is out of range, so search for some other nearby enemy we may need to melee.
				If (!Target || !KAI_CheckMeleeRange (Target))
				{
					Actor Nearest = FindNearestEnemy (MeleeRange);
					
					If (Nearest) //If there is a monster that got too close, just begin targeting that.
						Target = Nearest;
				}
				
				If (Target && KAI_CheckMeleeRange (Target))
				{
					UInt SpaceFactor = CheckSpaceSize (640,640,8); //Store how many iterations were left once the function found crammed space. If any.
					If ((SpaceFactor < 6 || SpaceFactor == -1) && AssessThreatLevel (Target) >= ThreatLevelThreshold) //Target is WAY too dangerous.
					{
						RetreatLoops = 5;
						RetreatLoops -= SpaceFactor;
						Return FindState ("Retreat",True);
					}
					
					//We don't have berserk and are at half health with an enemy very close.
					If (SpaceFactor <= 2 && !HasBerserk && Health <= SpawnHealth ()/2 && Random (0,255) < 128)
					{
						SM_EndFiring();
						Return FindState ("RunFromMelee",True);
					}
					
					Double BerserkMul = (Health <= SpawnHealth ()/3) ? 2 : 1; //More likely to melee if berserking and low on health.
					Double FacMul = (Target.ApplyDamageFactor ("Melee",80) < 30) ? 0.5 : 1; //Take melee penalty if the target is too resilient against it.
					
					If (bAvoidMelee && Random (0,255) < 12*FacMul || HasBerserk && Random (0,255) < 32*BerserkMul*FacMul)
					{
						QuickMelee = True;
						SM_EndFiring();
						Return FindState ("Melee",True);
					}
				}
				//====================================================================
				
				BurstCounter++;
				//Run line of fire checks.
				Vector3 CheckPos = (0,-6,42);
				If (MarineState & MARINE_LYINGDOWN)
					CheckPos.Z = 14;
				Else If (Crouching)
					CheckPos.Z = 25;	
				Else If(MarineState & MARINE_KNEELING)
					CheckPos.Z = 32;
				
				If (!SM_CheckLOF (CheckPos)) //The default parameters for this function are for marines firing bursts.
					Return FindState ("Fire.End",True);
				
				Return SM_CheckRefire (10,"Fire.End",MARINE_FOV); //Since we are firing a short burst, be very likely to stop if anything is in the way.
			}
			MARF A 0 A_JumpIf (BurstCounter >= BurstSize,"Fire.End");
			Goto Fire.Loop;
		//Run some checks before you stop firing fully, like making sure you aren't out of ammo right after stopping.
		Fire.End:
			TNT1 A 0
			{
				SM_EndFiring();
				SM_SetMarineState (0,MARINE_FIRING);
				If (TauntTarget)
					Return FindState ("Taunt",True);
				If (AmmoCount <= 0) //Out of ammo.
				{
					RetreatLoops = 0; //RESET THE AMOUNT OF RETREATS, DO NOT FUCKING STACK THEM.
					//Target is alive and in sight and you are not in cover, if you are, then don't run.
					If (!(MarineState & MARINE_INCOVER) && !IsDead (Target) && CheckSight (Target,SF_IGNOREWATERBOUNDARY))
					{
						Bool NoRetreat = SM_IsRestricted(RESTRICT_RELOADRUN);
						If (!NoRetreat)
						{
							//Determine how much to run away based on how dangerous your enemy is.
							Switch (AssessThreatLevel (Target))
							{
								Case THREAT_UNSTOPPABLE:
								Case THREAT_SUPERDANGER:
									//RetreatLoops = Random (32,48);If (KAI_DebugPrintMessages)a_log ("now this is an avengers level threat");
									//Break;
								Case THREAT_VERYDANGEROUS:
									RetreatLoops = Random (12,24);
									Break;
								Case THREAT_DANGEROUS:
									RetreatLoops = Random (8,12);
									Break;
								Default:
									RetreatLoops = Random (4,8);
									Break;
							}
							
							If (Distance3DSquared(Target) <= 320*320)
								RetreatLoops += 2; //Too close.
						
							//Don't run as far away if you are supposed to stay on the beaten path.
							If (IsPatrolling (Self) && bChaseGoal)
								RetreatLoops /= 2;
						}
						
						SM_SetMarineState (MARINE_RELOAD,0); //Tell the Retreat state we need to reload, so it goes there once the RetreatLoops end.
						If (!NoRetreat && Random (0,255) < 4) A_StartSound ("Marine/Boolet",CHAN_VOICE,CHANF_OVERLAP);
						
						//Might instead quickly throw a smoke grenade before backing off, especially after firing full auto.
						Int SmokeChance = Random (0,128)+((AttackType == FIRE_FULLAUTO) ? 32 : 0);
						If (NoRetreat) SmokeChance -= 32; //Less likely to throw smoke if set to never retreat.
						
						RetreatLoops *= User_RetreatFactor;
						If (!NoRetreat) //Remove or add retreat loops after the initial calculation.
						{
							RetreatLoops = Clamp (RetreatLoops,1,INT.MAX); //Clamp for the reduction factor.
							RetreatLoops = AlterRetreatLoops(RetreatLoops);
						}
						
						If (PrepareForSmokeThrow (SmokeChance))
							Return FindState ("Grenade");
						
						If (RetreatLoops > 0) Return FindState ("Retreat"); //Run either far enough or out of sight, to reload.
						Else Return FindState ("Reload");
					}
					Else //Dead or out of sight, reload now.
					{
						SM_SetMarineState (MARINE_RELOAD,0);
						Return FindState ("Reload");
					}
				}
				Return State (Null);
			}
			Goto See;
		Reload: //Reload the rifle.
			TNT1 A 0 SM_SetMarineState (MARINE_RELOAD,0);
			TNT1 A 0 A_JumpIf (RemovedOldMag,5); //We probably flinched mid reload or some shit, so go right to the end of the reload sequence.
			MARA ABC 6 Fast Slow
			{
				SM_UpdateHeight();
				//lookhere
				SM_RunFromHazards();
				If (MarineState & MARINE_KNEELING || MarineState & MARINE_INCOVER)
				{
					Switch (Frame)
					{
						Default:
							Break;
						Case 1: //Frame A
							Frame = 13; //Frame N
							Break;
						Case 2: //Frame B
							Frame = 14; //Frame O
							Break;
						Case 3: //Frame C
							Frame = 15; //Frame P
							Break;
					}
				}
			}
			MARA D 4 Fast Slow
			{
				A_SpawnItemEx ("SM_EmptyMagazine",0,-16,27,0,FRandom(-2,-5),FRandom(-1,-0.5));
				RemovedOldMag = True;
				If (MarineState & MARINE_KNEELING || MarineState & MARINE_INCOVER)
					Frame = 16; //Frame Q
			}
			MARA C 6 Fast Slow
			{
				If (MarineState & MARINE_KNEELING || MarineState & MARINE_INCOVER)
					Frame = 15; //Frame P
			}
			MARA B 6 Fast Slow
			{
				A_StartSound ("Marine/Reload",CHAN_WEAPON);
				AmmoCount = MAGAZINE_SIZE; //Reset counter to the magazine size.
				If (MarineState & MARINE_KNEELING || MarineState & MARINE_INCOVER)
					Frame = 14; //Frame O
			}
			MARA A 4 Fast Slow
			{
				SM_SetMarineState (0,MARINE_RELOAD); //We're done here.
				RemovedOldMag = False;
				If (MarineState & MARINE_KNEELING || MarineState & MARINE_INCOVER)
					Frame = 13; //Frame N
			}
			TNT1 A 0 A_JumpIf (MarineState & MARINE_IDLING,"Idle");
			TNT1 A 0 //If your target is weak enough and within melee range after reloading, have a chance to decide to smack 'em.
			{
				If (bAvoidMelee && Random (0,255) < 220 || (!bAvoidMelee || HasBerserk) && Random (0,255) < 128) //Don't always do this, especially if your melee is weak.
					Return State (Null);
				
				//Just reloaded, and the target is in melee range and vulnerable.
				If (Target && (!Target.MissileState && Target.Health <= 60 || Target.MissileState && Target.Health <= 30) )
				{
					Int Chance = HasBerserk ? 128 : 64;
					If (Random (0,255) < Chance && KAI_CheckMeleeRange (Target))
					{
						QuickMelee = True;
						Return FindState ("Melee",True);
					}
				}
				Return State (Null);
			}
			Goto See;
		Grenade: //https://www.youtube.com/watch?v=BJrxKiW5f-4
			TNT1 A 0 SM_SetMarineState (MARINE_THROWING,MARINE_MELEE|MARINE_IDLING|MARINE_FIRING|MARINE_IDLING);
			MARF F 6
			{
				//Get out of cover to throw a grenade.
				If (MarineState & MARINE_INCOVER)
				{
					Crouching = False;
					SM_UpdateHeight();
				}
			}
			MARF G 4
			{
				Class <Actor> GrenCls;
				Switch (GrenadeType) //Pick the right grenade type.
				{
					Case GRENADE_HEFRAG:
						GrenCls = "SM_FragGrenade";
						Break;
					Case GRENADE_HE:
						GrenCls = "SM_HEGrenade";
						Break;
					Case GRENADE_SMOKE:
						GrenCls = "SM_SmokeGrenade";
						Break;
					/*Case GRENADE_STUN:
						GrenCls = "SM_StunGrenade";
						Break;*/
					Default:
						GrenCls = "SM_FragGrenade";
						Break;
				}
				A_StartSound ("Marine/Throw",CHAN_VOICE,CHANF_OVERLAP,attenuation:0.8); //Umf
				
				If (!QuickGrenade)
				{
					SM_AnnounceGrenadeThrow ();
					Actor Grenade = SM_FireGrenade (Target,GrenCls,65,0.5,128);
					//Faster proximity fuze for dangerous enemies.
					If (Grenade && GrenadeType != GRENADE_SMOKE && AssessThreatLevel (Target,False) >= ThreatLevelThreshold) SM_FragGrenade(Grenade).Proximity = True;
				}
				Else
				{
					Bool Useless; Actor Gren;
					[Useless, Gren] = A_ThrowGrenade (GrenCls,Height/2,4,1);
					If (Gren) Gren.ReactionTime /= 2;
					QuickGrenade = False;
				}
				GrenadeDelay = 40; //Don't throw a grenade again until at least a second has passed.
			}
			TNT1 A 0
			{
				Int OldType = GrenadeType;
				GrenadeType = GRENADE_NONE; //Reset GrenadeType
				Bool NoRetreat = (OldType == GRENADE_SMOKE && QuickGrenade && RetreatLoops <= 0);
				If (!(MarineState & MARINE_INCOVER) && !NoRetreat) RetreatLoops += Random (2,5)*User_RetreatFactor;
				
				Int Iterations; Double Rad; Double Eh;
				[Iterations, Rad, Eh] = CheckSpaceSize (512,512,8);
				If (Rad != -1 && Rad < 256) RetreatLoops = 1;
				
				SM_SetMarineState (0,MARINE_THROWING); //Were done.
				
				If (MarineState & MARINE_INCOVER) //Don't retreat if behind cover.
					Return SeeState;
				
				//If (NoRetreat && MarineState & MARINE_RELOAD)
				//	Return FindState ("Reload");
				
				Return State (Null);
			}
			Goto Retreat; //Run a way a little.
		Melee:
			#### # 0 A_Jump (255,"Melee.Smack","Melee.Kick","Melee.Jumpkick"); 
		Melee.Smack: //Smack enemy with your rifle.
			#### # 0 A_FaceTarget();
			MARI A 3 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_IDLING);
			MARM A 2 A_FaceTarget();
			MARM B 8
			{
				Double DmgMul = HasBerserk ? 10 : 1;
				If (DeadDogTimer)
					DmgMul += 5;
				Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
				A_CustomMeleeAttack (Random[Punch](4,8)*DmgMul,HitSound,"Marine/MeleeMiss",'Melee',HasBerserk);
				If (HasBerserk) Target.A_Recoil (2*Cos(Target.PitchTo(Self,Target.Height/2)));
			}
			Goto Melee.End;
		Melee.Kick: //Kick enemy in place, 50/50 chance on which one the marine will use since they are more or less the same.
			#### # 0 A_FaceTarget();
			MARI A 2 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_IDLING);
			#### # 0 A_JumpIf ((Distance2D(Target) >= (MeleeRange/2)+Target.Radius),"Melee.Kick.Run");
			MARM F 8
			{
				Actor ActualTarget = Target;
				If (MeleeNearest && NearestEnemy) Target = NearestEnemy; //We're kicking the shit out of our nearest enemy instead.
				Double DmgMul = HasBerserk ? 6 : 1;
				If (DeadDogTimer)
					DmgMul += 5;
				Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
				A_CustomMeleeAttack (Random[Punch](6,10)*DmgMul,HitSound,"Marine/MeleeMiss",'Melee',HasBerserk);
				Target.TriggerPainChance ('Melee'); //Additional pain chance.
				If (HasBerserk)
				{
					Target.TriggerPainChance ('Melee'); //Even more pain.
					Target.A_Recoil (5*Cos(Target.PitchTo(Self,Target.Height/2))); //Produce recoil from the bottom of the marine to the middle of the victim.
					Target.Vel.Z += 10; //Wee
					Target.bBlasted = True; //Even more damage.
				}
				Target = ActualTarget;
			}
			Goto Melee.End;
		Melee.Kick.Run: //Too far to kick, run to the enemy.
			MARM DDEE 2
			{
				Actor PuntVictim = Target;
				If (MeleeNearest && NearestEnemy) PuntVictim = NearestEnemy; //We're kicking the shit out of our nearest enemy instead.
				//Give up on the target if its' dead, nonexistent, or way too far away.
				Int RunSeconds = HasBerserk ? 6 : 3; //How many seconds to run before giving up.
				If (!KAI_CheckMeleeRange(PuntVictim,1024) || IsDead (PuntVictim) || ++ChaseTimer >= (GameTicRate*RunSeconds)/CurState.Tics)
				{
					ChaseTimer = 0;
					Return SeeState;
				}
				
				Double OldSpeed = Speed;
				If (!HasBerserk)
					A_SetSpeed (Speed*2.5); //The marine is just slightly faster than the stock players' walking speed.
				Else
					A_SetSpeed (Speed*3);
				KAI_MoveTowards (PuntVictim.Pos,0.25,25);
				A_SetSpeed (OldSpeed);
				If (Distance2D(PuntVictim) <= (MeleeRange/2)+PuntVictim.Radius)
					Return FindState ("Melee.Kick",True); //Now we can punt it.
				Return State (Null);
			}
			Loop;
		Melee.Jumpkick: //Do a flying kick to your enemy, pushing them back in the process.
			MARI A 1 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_IDLING);
			#### # 0
			{
				A_FaceTarget();
				A_StartSound ("Marine/Throw");
				A_Recoil (-10);
				Vel.Z += 6;
			}
			MARI A 1; //One tick delay for the ground check to not immediately return true.
			Marine.Jumpkick.Loop: //Flying loop.
				MARM C 1
				{
					//If we land or hit an actor.
					If (GetZAt () >= Pos.Z || BlockingMobj)
						Return FindState ("Marine.Jumpkick.Attack");
					Return State (Null);
				}
				Wait;
		Marine.Jumpkick.Attack: //Where the magic happens
			MARM C 1
			{
				If (BlockingMobj)
				{
					Double DmgMul = HasBerserk ? 4 : 1;
					If (DeadDogTimer)
						DmgMul += 5;
					Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
					A_StartSound (HitSound,CHAN_WEAPON);
					Int Dmg = BlockingMobj.DamageMobj (Self,Self,Random[Punch](8,12)*DmgMul,'Melee');
					BlockingMobj.TraceBleed (Dmg,Self);
					If (!bDontThrust) //Push the enemy back.
					{
						Double MassMul = KAI_Math.LinearMap (BlockingMobj.Mass,1000,0,0.0,1.0);
						Double XVel , YVel, ZVel;
						XVel = YVel = 8*MassMul;
						ZVel = 4*MassMul;
						Double BuffMul = 1;
						If (HasBerserk) //Change velocities.
							BuffMul = 2;
						
						//Double Ang = BlockingMobj.AngleTo (Self);
						BlockingMobj.Vel.X += (XVel * Cos (Angle) + YVel * Sin (Angle)) * BuffMul;
						BlockingMobj.Vel.Y += (XVel * Sin (Angle) - YVel * Cos (Angle)) * BuffMul;
						BlockingMobj.Vel.Z += ZVel*BuffMul;
						BlockingMobj.bBlasted = True;
					}
				}
				JumpKickDelay = GameTicRate*Random(1,4);
			}
			Goto Melee.End;
		Melee.OnePunch:
			MARM D 0 A_JumpIf (!Target,"Melee.End");
			MARM D 30
			{
				DeadDogTimer = 0;
				A_StartSound ("Marine/Death1",CHAN_VOICE,CHANF_OVERLAP,attenuation:0);
				A_StartSound ("Marine/Death1",CHAN_VOICE,CHANF_OVERLAP,attenuation:0);
				A_StartSound ("Marine/Death1",CHAN_VOICE,CHANF_OVERLAP,attenuation:0);
				A_StartSound ("Marine/Death1",CHAN_VOICE,CHANF_OVERLAP,attenuation:0);
				A_StartSound ("Marine/Death1",CHAN_VOICE,CHANF_OVERLAP,attenuation:0);
				A_QuakeEx (5,5,5,35,0,8192,QF_SCALEDOWN,falloff:1,rollintensity:5);
				bNoDamage = bNoGravity = bDontThrust = True;
			}
			MARM D 0 //Nothin personnel, kiddo.
			{
				PreOnePunchPos = Pos;
				Vector3 TeleportPos = (Target.Vec2Angle (Target.Radius + MeleeRange,Target.Angle-180),Target.Pos.Z);
				Teleport (TeleportPos,Angle,TELF_SOURCEFOG|TELF_DESTFOG);
			}
			MARM D 5;
			MARA JJ 8
			{
				//Massive skill issue.
				If (Target.Player)
					Target.Player.Cheats &= ~(CF_GODMODE|CF_GODMODE2|CF_BUDDHA|CF_BUDDHA2);
				
				Target.bNoDamage = Target.bBuddha = Target.bInvulnerable = False;
				
				//Die
				Bool XTreme = bExtremeDeath;
				bExtremeDeath = True;
				Target.DamageMobj (Self,Self,INT.MAX,"Massacre",DMG_FORCED);
				bExtremeDeath = XTreme;
				
				//Send the enemy flying, regardless of bDontThrust.
				Double MassMul = KAI_Math.LinearMap (Target.Mass,100000,0,0.0,1.0);
				Double XVel , YVel, ZVel;
				XVel = YVel = 64*MassMul;
				ZVel = 24*MassMul;
				Double BuffMul = 1;
				
				Target.Vel.X += (XVel * Cos (Angle) + YVel * Sin (Angle))*BuffMul;
				Target.Vel.Y += (XVel * Sin (Angle) - YVel * Cos (Angle))*BuffMul;
				Target.Vel.Z += ZVel*BuffMul;
				Target.bBlasted = True;
				
				//Summon giant explosion.
				String TankBlast = "MVP_MBTFireEffect";
				If (CheckActorExists ('MVP_MBTFireEffect'))
					Spawn (TankBlast,Target.Pos);
				Else
					Spawn ("SM_OnePunchBlast",Target.Pos);
			}
			MARM D 0 Teleport (PreOnePunchPos,Angle,TELF_SOURCEFOG);
			MARA D 10;
			MARM D 0
			{
				bNoDamage = Default.bNoDamage;
				bNoGravity = Default.bNoGravity;
				bDontThrust = Default.bDontThrust;
			}
			Goto Melee.End;
		Melee.End:
			#### # 0 SM_SetMarineState (0,MARINE_MELEE); //We are no longer doing melee.
			#### # 0
			{
				ChaseTimer = 0;
				
				//Melee taunt handling. Marines are twice as likely to taunt if they meleed a power foe to death.
				If (Target && IsDead(Target))
				{
					Actor RealTarget = Target;
					If (SM_CheckTaunt (RealTarget,User_TauntChance*2) && !LookForPlayers(True)) //Look for any enemies in sight.
					{
						QuickMelee = MeleeNearest = False;
						Target = Null;
						TauntTarget = Target;
						Return FindState ("Taunt",True);
					}
					Else //Found one? Abort.
						Target = RealTarget;
				}
				
				If (MarineState & MARINE_RELOAD)
				{
					QuickMelee = MeleeNearest = False;
					Return FindState ("Reload",True);
				}
				
				If (QuickMelee || MeleeNearest) //We came here to just do a quick attack.
				{
					QuickMelee = MeleeNearest = False;
					RetreatLoops += Random (1,3);
					Return FindState ("Retreat",True);
				}
				Return State (Null);
			}
			Goto See;
		HealAlly:
			TNT1 A 0 A_JumpIf (!HealTarget,17); //Skip this if we have no heal target for some reason.
			MARA IIIIII 1 A_Face (HealTarget);
			TNT1 A 0 //Now actually heal the target.
			{
				If (HealTarget.Player) //Straight up give an item to players.
				{
					Inventory Stimmy = Inventory (Spawn("SM_MarineStimpack",Pos));
					If (Stimmy)
					{
						Stimmy.SetGiveAmount (HealTarget,10,False);
						If (!Stimmy.CallTryPickup (HealTarget))
							Stimmy.Destroy();
						Else
						{
							If (Stimmy.PickupFlash) Spawn(Stimmy.PickupFlash, HealTarget.Pos, ALLOW_REPLACE);
							Stimmy.PrintPickupMessage (HealTarget.CheckLocalView(), Stimmy.PickupMessage());
							Stimmy.PlayPickupSound (HealTarget);
							HealTarget.Player.BonusCount = 6; //Screen flash.
							Spawn ("SM_MarineHealAllyIcon",HealTarget.Pos.PlusZ(Height),ALLOW_REPLACE);
						}
					}
					//HealTarget.GiveInventory ("SM_MarineStimpack",1);
				}
				Else
				{
					HealTarget.GiveBody (10,HealTarget.SpawnHealth());
					HealTarget.A_StartSound ("misc/i_pkup",34859,CHANF_OVERLAP,1.0,ATTN_STATIC);
					Spawn ("SM_MarineHealAllyIcon",HealTarget.Pos.PlusZ(Height),ALLOW_REPLACE);
				}
				HealTarget = Null;
				HealDelay = User_HealCooldown*GameTicRate;
			}
			MARA JJJJJJJJJJ 1;
			TNT1 A 0 A_JumpIf (MarineState & MARINE_IDLING,"Idle");
			Goto See;
		//The marine is interacting with a door or the likes, so stop in place. This has no MarineState since if the marine flinches during this, he should move anyway.
		//Door thinkers (That we have to ASSUME are there because they AREN'T EXPOSED TO ZSCRIPT) take precedence over platforms.
		Interact:
			MARA J 10 A_StartSound ("switches/normbutn",CHAN_AUTO,CHANF_OVERLAP,attenuation:ATTN_STATIC);
			MARI EEEEFFFFGGGGHHHH 3
			{
				LookExParams MarineSight;
				MarineSight.FOV = MARINE_FOV;
				
				//Wait until you either run out of patience, or the sector is high or low enough for you to cross!
				If (InteractWaits >= MARINE_USEPATIENCE || SM_DoorOrLiftFinished() ||
				//Or you can see your target again.
				Target && IsVisible (Target,False,MarineSight))
				{
					InteractWaits = 0;
					If (Target) //Had a target, go back to chasing.
						Return SeeState;
					Else //Bing chilling
						SetIdle();
				}
				
				Return State (Null);
			}
			TNT1 A 0 {InteractWaits++;}
			Goto Interact+1;
		Climb:
			MARA F 6 Fast Slow //Stop the marines momentum and turn on no gravity, to allow him to ledge grab when jumping, or if the sector below him begins moving down.
			{
				SetOrigin ((ClimbPos.XY,Pos.Z),True);
				Crouching = False;
				A_Stop();
				bNoGravity = True;
			}
			MARA G 5 Fast Slow A_StartSound ("Marine/Throw",CHAN_VOICE,attenuation:0.8); //Umf
			TNT1 A 0
			{
				WorldOffset.Z = -31; //MARAG has the mid-climb sprite offset, so when the marine actually moves to the climb pos, it looks like he's flying without this.
				A_SetAngle (GetAngleToPos(Vec3Angle (Speed,Angle))); //Face in front of where you climbed to.
				SetOrigin (ClimbPos,False); //There's a slight delay in the worldoffset with interpolation on.
			}
			MARA G 1
			{
				bNoGravity = Default.bNoGravity;
				GiveInventory ("SM_DropoffToken",1); //HACK: Zandronum Moment
			}
			TNT1 A 0 {WorldOffset = (0,0,0);}
			TNT1 A 0 A_JumpIf (MarineState & MARINE_IDLING,"Idle");
			TNT1 A 0
			{
				If (MarineState & MARINE_IDLING) //We were bing chilling, go back to that.
					Return FindState ("Idle",True);
				//We were looking to reload at the time of the climb.
				If (MarineState & MARINE_RELOAD)
					If (RetreatLoops) //Go back to retreating instead of reseting the retreat counter and shit.
						Return FindState ("Retreat");
					Else //Straight to reloading.
						Return FindState ("Reload");
				
				Return State (Null);
			}
			Goto See;
		Jump:
			MARA H 1
			{
				Crouching = False;
				If (JumpPos.Z != JumpPos.Z) //No Z coordinate passed, as is usually the case if JumpPos just becomes the return of GetJumpPosition().
					JumpPos.Z = GetZAt (JumpPos.X,JumpPos.Y); //So just get the Z at the XY coordinates.
				bNoFriction = True; //Get rid of the god forsaken friction.
				KAI_JumpTo (JumpPos);
				If (Random (0,255) < 253)
					A_StartSound ("Marine/Throw",CHAN_VOICE,attenuation:0.8); //Umf
				Else
					A_StartSound ("Marine/Wahoo",CHAN_VOICE,attenuation:0.8);
			}
			MARA H 1; //Wait one tick.
			Goto Jump.Loop;
		Jump.Dodge: //Jumping to dodge a projectile.
			MARA H 1
			{
				Crouching = False;
				If (JumpPos.Z != JumpPos.Z) //No Z coordinate passed, as is usually the case if JumpPos just becomes the return of GetJumpPosition().
					JumpPos.Z = GetZAt (JumpPos.X,JumpPos.Y); //So just get the Z at the XY coordinates.
				bNoFriction = True; //Get rid of the god forsaken friction.
				KAI_JumpTo (JumpPos,8);
				If (Random (0,255) < 250)
					A_StartSound ("Marine/Throw",CHAN_VOICE,attenuation:0.8); //Umf
				Else
				{
					A_StartSound ("Marine/AltDodge",CHAN_VOICE,attenuation:0.8);
					Actor Text = Spawn ("SM_OrderText",Pos.PlusZ(Height));
					If (Text) Text.SetStateLabel("Miss");
				}
			}
			MARA H 1;
			MARA H 0 //Decide if the marine should fire while mid-dodge, becoming more likely to do so the closer the marine is to death.
			{
				Int Chance = KAI_Math.LinearMap (Health,0,SpawnHealth(),192,96); //The closer we are to dying the more likely we are to fire while dodging.
				
				//Check if we should decide to strafe shoot, if we even can.
				If (Random (0,255) < Chance && (Target && !IsDead(Target) ||
				LastDodged && LastDodged.Target && !IsDead(LastDodged.Target) && IsActorHostile (LastDodged.Target)) && AmmoCount > 0 && !(CurSector.Flags & Sector.SECF_NOATTACK))
				{
					AttackType = FIRE_FULLAUTO;
					KAI_JumpTo (JumpPos.PlusZ(16),8); //Jump a bit higher to fire off a few more shot mid-air.
					SM_SetMarineState (MARINE_FIRING,0);
					Return FindState ("Jump.Dodge.Attack",True);
				}
				
				Return State (Null);
			}
			Goto Jump.Loop;
		Jump.Dodge.Attack:
			MARA HH 1 SM_JumpLoop(True);
			TNT1 A 0
			{
				If (AmmoCount > 0)
					SM_FireBullet(); //Shooting my shot.
				Else
					A_StartSound ("VRifle/EmptyGun",CHAN_WEAPON,attenuation:ATTN_STATIC);
			}
			MARA RR 1 Light ("MarineMuzzleFlash") SM_JumpLoop(True);
			Loop;
		Jump.Loop: //Not sure if this should really be interruptable by pain or if I should add a new marine state for jumping/falling. But I'm leaning to no.
			MARA H 1 SM_JumpLoop();
			Wait;
		Jump.Up: //Used when the marine needs to jump to reach a ledge just out of reach.
			MARA H 1
			{
				Crouching = False;
				If (JumpPos.Z != JumpPos.Z) //No Z coordinate passed, as is usually the case if JumpPos just becomes the return of GetJumpPosition().
					JumpPos.Z = GetZAt (JumpPos.X,JumpPos.Y); //So just get the Z at the XY coordinates.
				bNoFriction = True; //Get rid of the god forsaken friction.
				KAI_JumpTo (JumpPos,17.5); //Using the velocity altering negative value makes the jump fail.
				A_StartSound ("Marine/Throw",CHAN_VOICE,attenuation:0.8); //Umf
			}
			MARA H 1;
			Goto Jump.Loop;
		Jump.Running:
			MARI AABBCCDDAABBCCDDAABBCCDD 2 //Move back.
			{
				KAI_MoveTowards (PreJumpPos, 0.5, 0); 
				If (!CheckMove (Vec2Angle(Speed,Angle))) //Something is in the way.
				{
					If (MarineState & MARINE_IDLING)
						Return FindState ("Idle",True);
					
					Return SeeState;
				}
				Return State (Null);
			}
			TNT1 A 0
			{
				If (!IsPosReachable(Vec3Angle(MARINE_JUMPRUNLENGTH,Angle-180))) //Something is in the way as we run forward to jump.
				{
					If (MarineState & MARINE_IDLING)
						Return FindState ("Idle",True);
					
					Return SeeState;
				}
				Return State (Null);
			}
			//Begin running forward and jump.
			MARI AAABBBCCCDDDAAABBBCCCDDD 1
			{
				KAI_MoveTowards ((JumpPos.XY,GetZAt (JumpPos.X,JumpPos.Y)), 0.5, 0);
				If (!CheckMove (Vec2Angle(Speed,Angle))) //Something is in the way.
				{
					If (MarineState & MARINE_IDLING)
						Return FindState ("Idle",True);
					
					Return SeeState;
				}
				Return State (Null);
			}
			Goto Jump;
		MarineShaker: //SHIT, GRENADE! PRIVATE! THROW IT BACK!
			TNT1 A 0 {ChaseTimer = Random (1,8)*(GameTicRate/2);}
			MARA KKLLMM 1 //The private in question:
			{
				PlayerInfo Client = Players[ConsolePlayer];
				Actor Playa = Client.Mo; //HACK: Because using Client.Mo directly causes ZScript to bitch about CheckFOV having too many parameters passed.
				If (SM_CheckFOV (Playa,Self,Client.FOV/1.5))
					ChaseTimer -= 3; //Decrement 3 times as fast when in sight.
				If (ChaseTimer < 0/* || Distance3DSquared (Playa) <= 512*512*/ || Client.Cheats & CF_CHASECAM)
				{
					ChaseTimer = 0;
					If (MarineState & MARINE_IDLING)
						Return FindState ("Idle",True);
					
					Return SeeState;
				}
				ChaseTimer--;
				Return State (Null);
			}
			Goto MarineShaker+1;
		Taunt:
			TNT1 A 0
			{
				String TauntStates[] = {"Taunt.Twerk","Taunt.Wave1","Taunt.Wave2"};
				If (TauntTarget && !TauntTarget.bDontCorpse && Random (0,255) < 64 && Distance3DSquared(TauntTarget) <= 2048*2048 && SM_IsPosReachable(TauntTarget.Pos,ignoreactors:True))
					Return FindState ("Taunt.Teabag");
				Else
					Return FindStateByString (TauntStates[Random(0,TauntStates.Size()-1)]);
				
				Return State (Null);
			}
			//TNT1 A 0 A_Jump(255,"Taunt.Twerk","Taunt.Wave1","Taunt.Wave2");
		Taunt.Twerk:
			TNT1 A 0 {ChaseTimer = Random(4,8); A_Face(TauntTarget);}
			MARA KLMKLMKLMKLM 2
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET);
				If (HazardToAvoid) SetStateLabel ("Taunt.Finish");
			}
			TNT1 A 0 A_JumpIf (--ChaseTimer <= 0,"Taunt.Finish");
			Goto Taunt.Twerk+1;
		//Wave twice
		Taunt.Wave1:
			TNT1 A 0 {ChaseTimer = Random(2,5); A_StartSound ("Marine/Taunt",CHAN_VOICE); A_Face(TauntTarget);}
			MWAV ABCDEFGHGFEDCB 5
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET);
				If (HazardToAvoid) SetStateLabel ("Taunt.Finish");
			}
			TNT1 A 0 A_JumpIf (--ChaseTimer <= 0,"Taunt.Finish");
			TNT1 A 0 A_StartSound ("Marine/Taunt",CHAN_VOICE);
			Goto Taunt.Wave1+1;
		//Ditto, but for a different wave.
		Taunt.Wave2:
			TNT1 A 0 {ChaseTimer = Random(2,5); A_StartSound ("Marine/Taunt",CHAN_VOICE); A_Face(TauntTarget);}
			MWAV IJKLMNMLKJ 5
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET);
				If (HazardToAvoid) SetStateLabel ("Taunt.Finish");
			}
			TNT1 A 0 A_JumpIf (--ChaseTimer <= 0,"Taunt.Finish");
			TNT1 A 0 A_StartSound ("Marine/Taunt",CHAN_VOICE);
			Goto Taunt.Wave2+1;
		/*Taunt.Jump:
			TNT1 A 0 {ChaseTimer = Random(2,6);}
			TNT1 A 0 A_StartSound ("Marine/Throw",CHAN_VOICE,volume:0.25);
			MARA HHHHHHH 1 {SpriteOffset.Y += KAI_Math.LerpValue(0,-7,0.5); A_SetAngle(Angle+(360/28),SPF_INTERPOLATE);}
			MARA HHHHHHH 1 {SpriteOffset.Y -= KAI_Math.LerpValue(-7,0,0.5); A_SetAngle(Angle+(360/28),SPF_INTERPOLATE);}
			TNT1 A 0 A_JumpIf (--ChaseTimer <= 0,"Taunt.Finish");
			Goto Taunt.Jump+1;*/
		//Walk up to the dead enemy.
		Taunt.Teabag:
			MARI AABBCCDD 3
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET);
				If (HazardToAvoid)
					Return FindState ("Taunt.Finish",True);
				//Double RealSpeed = Speed;
				//Speed *= 2;
				KAI_MoveTowards (TauntTarget.Pos, 0.5, 20, 0, 0);
				//Speed = RealSpeed;
				If (Distance3DSquared  (TauntTarget) <= 16*16)
					Return FindState ("Taunt.Teabag.Loop");
				If (!TauntTarget)
					Return FindState ("Taunt.Finish",True);
				Return State (Null);
			}
			TNT1 A 0
			{
				If (!TauntTarget || !SM_IsPosReachable(TauntTarget.Pos,ignoreactors:True))
					Return FindState ("Taunt.Finish",True);
				Return State (Null);
			}
			Loop;
		Taunt.Teabag.Loop:
			TNT1 A 0 {ChaseTimer = Random(5,15);}
			MARI IIII 2
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET);
				If (HazardToAvoid) SetStateLabel ("Taunt.Finish");
			}
			TNT1 A 0 A_StartSound ("Marine/Throw");
			MARC AAAA 2
			{
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET);
				If (HazardToAvoid) SetStateLabel ("Taunt.Finish");
			}
			TNT1 A 0 A_JumpIf (--ChaseTimer <= 0,"Taunt.Finish");
			Goto Taunt.Teabag.Loop+1;
		Taunt.Finish:
			TNT1 A 0 {ChaseTimer = 0; TauntTarget = Null;}
			Goto Idle;
		AskDog: //What peculiar act is the domesticated canine performing.
			TNT1 A 0
			{
				A_StartSound ("Marine/WhatDaDogDoin",CHAN_VOICE);
				A_Face(DaDog);
			}
			MARI HHHHHHHHHHHHHH 5;
			MARI H 0 {DaDog = Null;}
			Goto Idle;
		Pain:
			//Being hurt interrupts staying idle, wandering, attacking (Except firing), and kneeling or lying down..
			MARA E 0 SM_SetMarineState (0,MARINE_IDLING|MARINE_THROWING|MARINE_IDLING|MARINE_MELEE|MARINE_KNEELING|MARINE_LYINGDOWN);
			MARA E Random (7,14) Fast
			{
				If (Crouching)
				{
					Sprite = GetSpriteIndex ("MARC");
					Frame = 5;
				}
				A_Pain();
			}
			MARA E 0
			{
				bNoFriction = Default.bNoFriction; //Reset the friction flag to the default, in case the marine flinched mid jump.
				bNoGravity = Default.bNoGravity;
				DaDog = Null;
				ChaseTimer = 0;
				RetreatPos = (Double.NaN, Double.NaN, Double.NaN);
				WorldOffset = (0,0,0);
				DodgingHomingProjectile = False;
				TauntTarget = Null;
				If ((MarineState & MARINE_RELOAD)) //We were reloading before retreating.
				{
					If (!RetreatLoops) //Go to reloading, like if the marine was hurt mid reload. But do run away a bit first.
					{
						RetreatLoops = Random (1,3);
						Int Iterations; Double Rad; Double Eh;
						[Iterations, Rad, Eh] = CheckSpaceSize (512,512,16);
						If (Rad != -1 && Rad < 192) RetreatLoops = 0;
						Return FindState ("Retreat",True);
					}
					Else //If we have retreat loops, that means we were actually running before reloading.
						Return FindState ("Retreat",True); //Go right back to that.
				}
				Return State (Null);
			}
			MARA E 0 A_JumpIf ((MarineState & MARINE_RETREAT),"Retreat"); //Or running.
			MARA E 0 A_JumpIf ((MarineState & MARINE_FIRING),"Fire.End"); //End shooting now that you flinched.
			MARA E 0 A_JumpIf ((MarineState & MARINE_MELEE),"Melee.End"); //End beating the shit out of your enemy too.
			Goto See;
	}
}

//Marine with berserk pack (Much stronger and less anemic melee)
Class SM_Marine_Berserk : SM_Marine
{
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		GiveInventory ("PowerStrength",1);
	}
}

//Marine with light amp goggles (Has +SEEINVISIBLE).
Class SM_Marine_Infrared : SM_Marine
{
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		GiveInventory ("PowerLightAmp",1);
	}
}

//Marine with no green armor.
Class SM_Marine_Unarmored : SM_Marine
{
	Override Void PostBeginPlay ()
	{
		User_Armor = "None";
		Super.PostBeginPlay();
	}
}

//Extra durable marine.
Class SM_Marine_BlueArmor : SM_Marine
{
	Override Void PostBeginPlay ()
	{
		User_Color = "Blue";
		User_Armor = "BlueArmor";
		Super.PostBeginPlay();
	}
}

//https://www.youtube.com/watch?v=18rZxvB5rDA
Class SM_GigaMarine : SM_Marine
{
	Default {KAI_Actor.ThreatLevel THREAT_DANGEROUS; +ALWAYSFAST;}
	Override Void PostBeginPlay ()
	{
		User_Color = "Blue";
		User_Armor = "BlueArmor";
		GiveInventory ("PowerStrength",1);
		GiveInventory ("PowerLightAmp",1);
		Health = 200;
		Super.PostBeginPlay();
		//Maxxed out height and width.
		Scale.X = Default.Scale.X * 1.05;
		Scale.Y = Default.Scale.Y * 1.10;
		StartHealth = 110;
		Health += 10;
	}
}