//TODO:

//IDEA:
//Try to make marines able to crouch under short ceilings once again, like I had once tried with my very first attempt at writing them.
//Give marines a dropkick melee, especially when a light enough non-flying enemy is over a ledge, and especially if fall damage is on.
//Give them 3 different grenade types depending on the situation, HE-FRAG, Smoke, and Flashbang.
//Give marines the ability to scale ledges that are almost their height ? Since there's sprites for that in Project Brutality I could use, like the kicks.
//Make marines able to jump over certain obstacles if they can ?
//Make some kind of extra handler addon with actual options, like spawning marines on map startup, replacing items with spawn beacons, etc.

Class SM_Marine : KAI_Humanoid
{
	Default
	{
		//$Title AI Marine
		//$Category Marines
		//$Sprite MARIC1
		Health 100;
		GibHealth 20;
		Height 56;
		DeathHeight 12;
		CameraHeight 50;
		Radius 16;
		YScale 0.98;
		Mass 100;
		Speed 8;
		FastSpeed 10;
		MeleeRange 64;
		PainChance 96;
		PainThreshold 5;
		FriendlySeeBlocks 64;
		MaxDropOffHeight 48;
		MaxTargetRange 8192;
		MinMissileChance 100;
		Tag "Marine NPC";
		Species "Military";
		Decal "BulletChip";
		Obituary "%o was shot to death by a marine.";
		HitObituary "%o got %p head smashed in by a marines' rifle.";
		DropItem "Clip";
		DropItem "Clip", 128, 2;
		DropItem "ClipBox", 64;
		PainSound "Marine/Pain";
		DeathSound "Marine/Death";
		KAI_Actor.ThreatLevel THREAT_ABOVENORMAL;
		KAI_Actor.ThreatLevelThreshold THREAT_VERYDANGEROUS; //Marines are only really scared of super dangerous enemies like bosses and enemy vehicles.
		//KAI_Actor.Inaccuracy (10,10,10);
		//KAI_Actor.InaccuracyFrequency 1;
		Monster;
		+JumpDown;
		+MissileMore;
		+MissileEvenMore;
		+Telestomp;
		+NoInfightSpecies;
		+FloorClip;
		+AvoidMelee;
		+AvoidHazards; //This ONLY works for crushing ceilings and NOTHING ELSE. So it's largely useless but I'm still adding it.
		+SeeFriendlyMonsters; //No more ZScript code hacks.
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		MarineState = MARINE_IDLING;
		AmmoCount = 30;
		MissileState = FindState ("Fire",True);
		//The melee state should be passed automatically, since I have a state just called "Melee"
		AttackStates.Push (FindState ("Fire",True));
		AttackStates.Push (FindState ("Fire.Loop",True));
		AttackStates.Push (FindState ("Melee",True));
		AttackStates.Push (FindState ("Melee.Smack",True));
		AttackStates.Push (FindState ("Melee.Kick",True));
		AttackStates.Push (FindState ("Melee.Kick.Run",True)); //Technically an attack state, since he enters this to get up into melee range.
		AttackStates.Push (FindState ("Marine.Jumpkick",True));
		AttackStates.Push (FindState ("Marine.Jumpkick.Attack",True));
		AttackStates.Push (FindState ("Marine.Jumpkick.End",True));
		
		//MeleeState = FindState (""); No melee attacks yet
	}
	
	Override Void Tick()
	{
		Super.Tick ();
		
		If (IsFrozen() || IsDead(Self)) Return;
		
		//Every 4 tics that the marine is in a non-melee attack state, perform target prediction.
		//NOTE: Hmm, should they do target prediction when throwing grenades too ?
		If (/*GetAge() % 4 == 0 && */!(MarineState & MARINE_MELEE) && IsInAttackState())
			AimAtTarget (8/**4*/,8/**4*/,attackspeed:170,200);
		
		//Update on whether or not the marine is berserking.
		If (GetAge() % GameTicRate == 0)
		{
			If (CountInv("PowerStrength"))
			{
				HasBerserk = True;
				bAvoidMelee = False;
			}
			Else
			{
				HasBerserk = False;
				bAvoidMelee = True;
			}
		}
		
		If (NextFireDelay && !(MarineState & MARINE_FIRING)) //Decrement the firing delay, if any, for as long as the marine is not shooting.
			NextFireDelay--;
		
		If (JumpKickDelay && !(MarineState & MARINE_MELEE))
			JumpKickDelay--;
	}
	
	Override Void Die (Actor Source, Actor Inflictor,Int DMGFlags,Name MeansOfDeath)
	{
		Super.Die (Source,Inflictor,DMGFlags,MeansOfDeath);
		
		SM_EndFiring();
	}
	
	Override Void UserVariableDefaults()
	{
		Super.UserVariableDefaults();
		If (!(User_Armor ~== "None" || User_Armor ~== "Nothing")) //If the marine doesn't explicitly spawn unarmored.
		{
			If (!User_Armor || User_Armor ~== "" || User_Armor ~== " ") //Default armor.
				GiveInventory ("GreenArmor",1);
			Else
				GiveInventory (User_Armor,1); //Try giving whatever armor available in the current session that the mapper wants.
		}
	}
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!Target) Return False;
		If (!CanAttack()) Return False;
		Vector3 FirePos = (0,-6,42); //Will be changable once I implement kneeling and lying down.
		Int Threat = AssessThreatLevel (Target);
		
		console.printf ("fire delay is %d tics",nextfiredelay);
		//TODO:
		//Use different height offsets if the marine decides to fire kneeling or lying down. Also double DetermineHitChance accuracy on the Vector4s.
		//Make it so if the marine is low on ammo (1-4 shots left), and is near an enemy weaker than him. He will melee it before running away.
		
		//Make the marines use HE-FRAG grenades:
			//With random RNG, for variety.
			//If the rifle is too ineffective against their target.
			//And/Or if they are attacking around a crowd of enemies.
			//If HE would be too ineffective (e.g against Cyberdemons or god mode players), but the target doesn't have +NOPAIN, they will throw flashbangs.
		//Check if you should fire your gun.
		Double Dist = Distance3D (Target);
		//If low on ammo, do a quick melee attack on your enemy instead, if its' close enough and less dangerous than you. And then retreat to reload.
		Bool QuickMelee = (AmmoCount <= 4 && Threat < Self.ThreatLevel && Dist <= MeleeRange*3);
		If (true == false &&!QuickMelee && !NextFireDelay && SM_CheckLOF (FirePos))
		{
			Double Buff = SM_IsCrouched() ? 0.5 : 1.0;
			Vector4 SSpread = (0.4*Buff,-0.4*Buff,0.4*Buff,-0.4*Buff); //Single shot spread.
			Vector4 BSpread = (1.1*Buff,-1.1*Buff,1.1*Buff,-1.1*Buff); //Burst fire spread.
			Vector4 FSpread = (2.2*Buff,-2.2*Buff,2.2*Buff,-2.2*Buff); //Full auto spread.
			
			//NOTE: The random numbers allow marines to sometimes decide to use a different sub-optimal firing mode, for variety.
			If (!NoStateJump)
			{
				//If the target is dangerous, or it's at least above normal, and you'd hit it at least 8 times (Counts multiple enemies too, for "crowd control").
				//Fire a burst instead too sometimes.
				Int FullAutoThreshold = (Health <= SpawnHealth()/6) ? 4 : 8; //If low on health, the marines will more desperately fire full auto.
				If (Random (0, 255) >= 8 && (Threat >= THREAT_DANGEROUS ||
				Threat < THREAT_NORMAL && DetermineHitChance (Target,!SM_DumbHitCheck,Dist,2.2,15,FirePos,FSpread,MaxTargetRange,DHC_THRUHOSTILES) >= FullAutoThreshold))
				{//https://youtu.be/LPAEgHsJYxk?si=4EdaE-oCczn5ehDD&t=75
					BurstSize = MAGAZINE_SIZE;
					AttackType = FIRE_FULLAUTO;
					a_log ("i have decided to fire in full auto");
				}
				//If your enemy is weak.
				Else If (Random (0, 255) >= 3 && (/*Threat < THREAT_ABOVENORMAL ||*/
				//Or you decided against full auto, but would hit the non-weak enemy at least twice.
				DetermineHitChance (Target, !SM_DumbHitCheck, Dist, 1.1, 3, FirePos, BSpread, MaxTargetRange) >= 2))
				{//Then fire a burst.
					BurstSize = 3;
					AttackType = FIRE_BURST;
					a_log ("i have decided to fire a burst");
				}
				Else
				{//Fall back to single accurate shots if neither full auto or bursts would work. Or just fire single shots instead sometimes.
					BurstSize = 1;
					AttackType = FIRE_SINGLE;
					a_log ("i have decided to fire a single shot");
				}
				
				//BurstSize = 3; AttackType = FIRE_BURST; //PLACEHOLDER !!!!!!
				SetStateLabel ("Fire");
			}
			Return True;
		}
		
		//Check if you should do melee. But only on weak-ish enemies.
		//MAYDO: Add a variable that forces the marine to reload if QuickMelee is true, after he finishes his melee ?
		Int MeleeChance = bAvoidMelee ? 32 : 128;
		If (Random (0,255) < MeleeChance && Threat < THREAT_DANGEROUS)
		{//if (!jumpkickdelay)SetStateLabel ("Melee.jumpKick"); //DEBUG
			Bool CanSee = CheckSight(Target,SF_IGNOREWATERBOUNDARY);
			If (KAI_CheckMeleeRange (Target) && CanSee) //Check the standard melee range.
			{
				If (!NoStateJump)
				{
					FCheckPosition TM;
					Int DropkickChance = (bAvoidMelee ? 32 : 144);
					//It's not safe to jump this far, so don't do this.
					If (!CheckMove (Vec2Angle (64,AngleTo(Target)),PCM_DROPOFF))
						DropkickChance = -1;
					//Check if the enemy can move this far back.
					If (DropkickChance != 1 && CheckMove (Target.Vec2Angle(88,Target.AngleTo(Self)),tm:TM))
					{
						//If there is a dropoff bigger than the targets' height, 88 MU from the direction you will face him at, be extra likely to punt him.
						If ((Target.Pos.Z - TM.FloorZ) >= Target.Pos.Z+Target.Height)
							DropkickChance += RandomPick (20,30,40);
						
						//Major points if the enemy will actually be HURT by falling off.
						If ((Level.MonsterFallingDamage || Target.bFallDamage) && TM.CurSector.Flags & Sector.SECF_NOFALLINGDAMAGE)
						{
							If (Target.ApplyDamageFactor ("Falling",100) > 0) //Also check if it has a damage factor making it immune to this damage.
								Dropkickchance += 50;
						}
					}
					//Might do a flying kick that knocks actors around.
					If (Random (0,255) < DropkickChance)
					{a_log ("the target is standing near a ledge i can punt him off of");
						{
							SetStateLabel ("Melee.Jumpkick");
							Return True;
						}
					}
					//Randomly choose between kicks and rifle butts.
					If (Random (False,True) == True)
						SetStateLabel ("Melee.Smack");
					Else
						SetStateLabel ("Melee.Kick");
				}
				Return True;
			}
			Else If (CanSee && Random (0,255) < (bAvoidMelee ? 88 : 224) && KAI_CheckMeleeRange (Target,MeleeRange*4)) //Check 4 times further sometimes.
			{a_log ("going to enter the kick chase state");
				If (!NoStateJump)
					SetStateLabel ("Melee.Kick.Run");
				Return True;
			}
		}
		
		Return False;
	}
	
	//Marines have identical criteria for if an actor is hostile as my MVP vehicles do.
	Override Bool IsActorHostile (Actor Other)
	{
		Return (Other && (IsHostile (Other) || IsTargetingAllies (Self, Other)));
	}
	
	//Actions the marine is performing, can be stacked on each other like flags.
	Enum MarineStates
	{
		MARINE_IDLING 	= 1 << 0, //Bing chilling
		MARINE_CHASING	= 1 << 1, //Chasing someone.
		MARINE_WANDER	= 1 << 2, //Wandering
		MARINE_FIRING 	= 1 << 3, //Shooting
		MARINE_THROWING	= 1 << 4, //Throwing a grenade
		MARINE_MELEE	= 1 << 5, //Beating someone up
		MARINE_RELOAD 	= 1 << 6, //Reloading
		MARINE_RETREAT	= 1 << 7, //GTFOing, assumed to be from some danger by default.
		MARINE_KNEELING	= 1 << 8, //Kneeling down.
		MARINE_LYINGDOWN= 1 << 9, //Lying down on the ground.
		//MARINE_PATROL	= 1 << 10, //Patrolling
	}
	
	Const MARINE_HEARDIST = 4096; //How far can the marine hear.
	Const MARINE_FOV = 120; //How wide the marine can see.
	Const MAGAZINE_SIZE = 30; //How much ammo does the marine have per magazine ?
	Const MARINE_FIREFOV = 60; //The FOV within which the marine can fire his VelInterceptEx() bullets without looking stupid.
	
	Mixin SM_SplashFunctions;
	
	Int MarineState; //What the marine doin'.
	Actor NearestEnemy; //The marines' closest enemy, used to stay away from enemies.
	Int RetreatLoops; //How many times the retreat state is called.
	Int AimPos; //Where is the marine aiming ? Similar to the TurretAimPos on the vehicles.
	Int AimTimer; //If the marine has been trying to aim and fire at the target for this long, then it's not working.
	
	//Shooting variables.
	Int AmmoCount; //How much ammo the marine has.
	Int BurstCounter; //Used by the burst fire tracking.
	Int BurstSize; //How many shots to fire.
	UInt8 NextFireDelay; //How long until the marine can shoot again, so that they don't shoot constantly. This can only be a ~7 second delay at most.
	Int AttackType; //How is the marine firing his gun ?
	Enum RifleFireModes
	{
		FIRE_BURST, //Fire a 3 round burst like the base M4 Carbine. Decently accurate.
		FIRE_SINGLE, //Fire a single accurate shot.
		FIRE_FULLAUTO, //Fire everything, pretty inaccurate, adds recoil, and faster than normal fire.
	}
	Bool SittingDown; //Is the marine firing while kneeling or lying down ? Adds an overall accuracy buff.
	//Other attacks
	Bool HasBerserk; //Has an active berserk pack.
	Int JumpkickDelay; //How long before the marine does a flying kick again.
	
	String User_Armor; //The name of the armor the marine should be equipped with upon spawning. Default is the vanilla green armor.
	
	vector3 OLDKICKPOSDEBUG;
	
	States
	{
		//When the marine is looking around with this animation, he actually changes his sight angle.
		Spawn:
			MARI EEEEEEEE 3 //Look 80 degrees to your left.
			{
				Angle += 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle -= 80;
				If (Target) SetStateLabel ("See");
			}
			MARI FFFFFFFF 3 //Look 20 degrees to your right.
			{
				Angle -= 20;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 20;
				If (Target) SetStateLabel ("See");
			}
			MARI GGGGGGGG 3 //Look 80 degrees to your right.
			{
				Angle -= 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 80;
				If (Target) SetStateLabel ("See");
			}
			MARI HHHHHHHH 3 KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV); //Just look straight.
			Loop;
		//Idle:
		//Idle.Stay: //Staying around idle. Basically like in the spawn state.
		//Idle.Stay.Alert: //Standing there, menacingly. Maybe use this for if the marine last saw an enemy a few seconds ago ?
		//Idle.Stay.Kneel: //Standing around while kneeling down, can randomly pick this one. TG5 needs to make sprites for me to be able to add it though.
		See:
			TNT1 A 0 SM_SetMarineState (MARINE_CHASING,0,True); //NOTE: Removing all marine stauses might cause problems if I implement the patrolling state ?
			MARF JJKKLLMM 3 SM_Chase (chaseflags:CHF_DONTIDLE);
			Goto See+1;
		//TODO: Add these to the attack states array.
		//MAYDO: Make a base Fire state, that just randomly decides a fire mode ?
		Fire: //Aim up.
			MARF JJJ 2; 
			MARF A 2 //Wait until you can actually aim properly at the enemy.
			{
				If (++AimTimer >= GameTicRate * 3) //https://www.youtube.com/watch?v=VX5gXHcbJAk
					Return FindState ("Fire.End",True);
				If (Target && CheckFOV(Target,160/2) && AimingAheadOfTarget())
					Return FindState ("Fire.Loop");
				Return State (Null);
			}
			Wait;
		Fire.Loop:
			MARF A 0 SM_SetMarineState (MARINE_FIRING,MARINE_IDLING|MARINE_THROWING|MARINE_WANDER); //Set marine actions.
			MARF A 3 //Delay
			{
				If (AttackType == FIRE_FULLAUTO)
					Tics = 2; //Fire faster in full auto.
				If (TRUE ==FALSE)//AmmoCount <= 0) //Out of ammo.
				{
					A_StartSound ("VRifle/EmptyGun",CHAN_WEAPON,attenuation:ATTN_STATIC); //Marine tried dry firing.
					Return FindState ("Fire.End");
				}
				
				Return State (Null);
			}
			MARF E 3 Light ("MarineMuzzleFlash") SM_FireBullet();
			MARF A 0
			{
				BurstCounter++;console.printf ("fired %d rounds",burstcounter);
				//Run line of fire checks.
				If (!SM_CheckLOF ((0,-6,42))) //The default parameters for this function are for marines firing bursts.
					Return FindState ("Fire.End",True);
				Return SM_CheckRefire (10,"Fire.End",MARINE_FIREFOV); //Since we are firing a short burst, be very likely to stop if anything is in the way.
			}
			MARF A 0 A_JumpIf (BurstCounter >= BurstSize,"Fire.End");
			Goto Fire.Loop;
		//Run some checks before you stop firing fully, like making sure you aren't out of ammo right after stopping.
		Fire.End:
			TNT1 A 0
			{
				SM_EndFiring();
				If (TRUE ==FALSE)//AmmoCount <= 0) //Out of ammo.
				{
					//Target is alive and in sight.
					If (!IsDead (Target) && CheckSight (Target,SF_IGNOREWATERBOUNDARY))
					{
						RetreatLoops = Random (6,12);
						Return FindState ("Retreat.Reload"); //Run either far enough or out of sight, to reload.
					}
					Else //Dead or out of sight, reload now.
						Return FindState ("Reload");
				}
				Return State (Null);
			}
			Goto See;
		//MAYDO: Make marines likely to retreat after melee, and less likely if they have berserk ?
		Melee:
			#### # 0 A_Jump (255,"Melee.Smack","Melee.Kick","Melee.Jumpkick"); 
		Melee.Smack: //Smack enemy with your rifle.
			#### # 0 A_FaceTarget();
			MARI A 3 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_WANDER);
			MARM A 2 A_FaceTarget();
			MARM B 8
			{
				Double DmgMul = HasBerserk ? 10 : 1;
				Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
				A_CustomMeleeAttack (Random[Punch](4,8)*DmgMul,HitSound,"Marine/MeleeMiss",'Melee',HasBerserk);
				If (HasBerserk) Target.A_Recoil (2*Cos(Target.PitchTo(Self,Target.Height/2)));
			}
			Goto See;
		Melee.Kick: //Kick enemy in place, 50/50 chance on which one the marine will use since they are more or less the same.
			#### # 0 A_FaceTarget();
			MARI A 2 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_WANDER);
			//#### # 0 A_JumpIf ((Distance2D(Target) >= (MeleeRange/2)+Target.Radius),"Melee.Kick.Run");
			MARM F 8
			{
				Double DmgMul = HasBerserk ? 6 : 1;
				Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
				A_CustomMeleeAttack (Random[Punch](4,8)*DmgMul,HitSound,"Marine/MeleeMiss",'Melee',HasBerserk);
				Target.TriggerPainChance ('Melee'); //Additional pain chance.
				If (HasBerserk)
				{
					Target.TriggerPainChance ('Melee'); //Even more pain.
					Target.A_Recoil (5*Cos(Target.PitchTo(Self,Target.Height/2))); //Produce recoil from the bottom of the marine to the middle of the victim.
					Target.Vel.Z += 10; //Wee
				}
			}
			Goto See;
		//TODO: When I add the chase timer, use it here to make it so if the marine has ran too long, he will just give up on the melee, like if the enemy fucks off.
		Melee.Kick.Run: //Too far to kick, run to the enemy.
			MARM DDEE 2
			{
				//Give up on the target if its' dead, nonexistent, or way too far away.
				If (!KAI_CheckMeleeRange(Target,1024) || IsDead (Target))
					Return SeeState;
				Double OldSpeed = Speed;
				If (!HasBerserk)
					A_SetSpeed (Speed*2.5); //The marine is just slightly faster than the stock players' walking speed.
				Else
					A_SetSpeed (Speed*3);
				KAI_MoveTowards (Target.Pos,0.25,25);
				A_SetSpeed (OldSpeed);
				If (Distance2D(Target) <= (MeleeRange/2)+Target.Radius)
					Return FindState ("Melee.Kick",True); //Now we can punt it.
				Return State (Null);
			}
			Loop;
		Melee.Jumpkick: //Jump.
			MARI A 1 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_WANDER);
			#### # 0
			{
				A_FaceTarget();
				A_StartSound ("Marine/Throw");
				A_Recoil (-10);
				Vel.Z += 6;
				console.printf ("start position %d %d %d",pos);
				OLDKICKPOSDEBUG = pos;
			}
			MARI A 1; //One tick delay for the ground check to not immediately return true.
			Marine.Jumpkick.Loop: //Flying loop.
				MARM C 1
				{a_log ("waiting to hit something");
					//If we land or hit an actor.
					If (GetZAt () >= Pos.Z || BlockingMobj)
					{
						Return FindState ("Marine.Jumpkick.Attack");
					}
					Return State (Null);
				}
				Wait;
		Marine.Jumpkick.Attack: //Where the magic happens
			MARM C 1
			{
				If (BlockingMobj)
				{
					Double DmgMul = HasBerserk ? 4 : 1;
					Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
					a_log ("THIS IS SPARTA");
					A_StartSound (HitSound,CHAN_WEAPON);
					Int Dmg = BlockingMobj.DamageMobj (Self,Self,Random[Punch](8,12)*DmgMul,'Melee');
					BlockingMobj.TraceBleed (Dmg,Self);
					If (!bDontThrust)
					{
						Double MassMul = KAI_Math.LinearMap (BlockingMobj.Mass,1000,0,0.0,1.0);
						console.printf ("mass %d, mass multiplier %.2f",blockingmobj.mass,massmul);
						Double XVel , YVel, ZVel;
						XVel = YVel = 8*MassMul;
						ZVel = 4*MassMul;
						//If (HasBerserk) //Change velocities.
						
						//Double Ang = BlockingMobj.AngleTo (Self);
						BlockingMobj.Vel.X += XVel * Cos (Angle) + YVel * Sin (Angle);
						BlockingMobj.Vel.Y += XVel * Sin (Angle) - YVel * Cos (Angle);
						BlockingMobj.Vel.Z += ZVel;
					}
				}console.printf ("end position %d %d %d, difference %d %d %d, difference distance %d",pos,level.vec3diff(pos,OLDKICKPOSDEBUG),
				level.vec3diff(pos,OLDKICKPOSDEBUG).length());
				JumpKickDelay = GameTicRate*Random(1,4);
			}
			Goto See;
		Pain:
			MARA E 0 SM_SetMarineState (0,MARINE_IDLING|MARINE_THROWING|MARINE_WANDER|MARINE_MELEE); //Being hurt interrupts staying idle, wandering, and throwing grenades.
			MARA E Random (7,14) A_Pain();
			//MARA E 0 A_JumpIf ((MarineState & MARINE_RELOAD),"Reload"); //Go back to reloading if you were doing that already. IDEA: Or run away a bit ?
			//MARA E 0 A_JumpIf ((MarineState & MARINE_RETREAT),"Retreat"); //Or running.
			MARA E 0 A_JumpIf ((MarineState & MARINE_FIRING),"Fire.End"); //End shooting now that you flinched.
			Goto See;
	}
}