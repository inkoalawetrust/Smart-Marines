//IDEA:
//Try to make marines able to crouch under short ceilings once again, like I had once tried with my very first attempt at writing them.
//Give marines a dropkick melee, especially when a light enough non-flying enemy is over a ledge, and especially if fall damage is on.
//Give them 3 different grenade types depending on the situation, HE-FRAG, Smoke, and Flashbang.
//Give marines the ability to scale ledges that are almost their height ? Since there's sprites for that in Project Brutality I could use, like the kicks.
//Make marines able to jump over certain obstacles if they can ?
//Make some kind of extra handler addon with actual options, like spawning marines on map startup, replacing items with spawn beacons, etc.

Class SM_Marine : KAI_Humanoid
{
	Default
	{
		//$Title AI Marine
		//$Category Marines
		//$Sprite MARIH1
		Health 100;
		GibHealth 20;
		Height 56;
		DeathHeight 12;
		CameraHeight 50;
		Radius 16;
		YScale 0.98;
		Mass 100;
		Speed 8;
		FastSpeed 10;
		MeleeRange 64;
		PainChance 96;
		PainThreshold 5;
		FriendlySeeBlocks 64;
		MaxDropOffHeight 48;
		MaxTargetRange 8192;
		MinMissileChance 100;
		Tag "Marine NPC";
		Species "Military";
		Decal "BulletChip";
		Obituary "%o was shot to death by a marine.";
		HitObituary "%o got %p head smashed in by a marines' rifle.";
		DropItem "Clip";
		DropItem "Clip", 128, 2;
		DropItem "ClipBox", 64;
		PainSound "Marine/Pain";
		DeathSound "Marine/Death";
		KAI_Actor.ThreatLevel THREAT_ABOVENORMAL;
		KAI_Actor.ThreatLevelThreshold THREAT_VERYDANGEROUS; //Marines are only really scared of super dangerous enemies like bosses and enemy vehicles.
		//KAI_Actor.Inaccuracy (10,10,10);
		//KAI_Actor.InaccuracyFrequency 1;
		Monster;
		//+JumpDown;
		+MissileMore;
		+MissileEvenMore;
		+Telestomp;
		+NoInfightSpecies;
		+FloorClip;
		+AvoidMelee;
		+AvoidHazards; //This ONLY works for crushing ceilings and NOTHING ELSE. So it's largely useless but I'm still adding it.
		+SeeFriendlyMonsters; //No more ZScript code hacks.
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		MarineState = MARINE_IDLING;
		AmmoCount = 30;
		MissileState = FindState ("Fire",True);
		//The melee state should be passed automatically, since I have a state just called "Melee"
		AttackStates.Push (FindState ("Fire",True));
		AttackStates.Push (FindState ("Fire.Loop",True));
		
		//That's a lot of melee states.
		AttackStates.Push (FindState ("Melee",True));
		AttackStates.Push (FindState ("Melee.Smack",True));
		AttackStates.Push (FindState ("Melee.Kick",True));
		AttackStates.Push (FindState ("Melee.Kick.Run",True)); //Technically an attack state, since he enters this to get up into melee range.
		AttackStates.Push (FindState ("Marine.Jumpkick",True));
		AttackStates.Push (FindState ("Marine.Jumpkick.Attack",True));
		AttackStates.Push (FindState ("Marine.Jumpkick.End",True));
		
		//MeleeState = FindState (""); No melee attacks yet
	}
	
	Override Void Tick()
	{
		Super.Tick ();
		
		If (IsFrozen() || IsDead(Self)) Return;
		
		//Every 4 tics that the marine is in a non-melee attack state, perform target prediction.
		//NOTE: Hmm, should they do target prediction when throwing grenades too ?
		If (/*GetAge() % 4 == 0 && */!(MarineState & MARINE_MELEE) && IsInAttackState())
			AimAtTarget (8/**4*/,8/**4*/,attackspeed:170,200);
		
		//Update on whether or not the marine is berserking.
		If (GetAge() % GameTicRate == 0)
		{
			If (CountInv("PowerStrength"))
			{
				HasBerserk = True;
				bAvoidMelee = False;
			}
			Else
			{
				HasBerserk = False;
				bAvoidMelee = True;
			}
		}
		
		If (NextFireDelay && !(MarineState & MARINE_FIRING)) //Decrement the firing delay, if any, for as long as the marine is not shooting.
			NextFireDelay--;
		
		If (JumpKickDelay && !(MarineState & MARINE_MELEE))
			JumpKickDelay--;
	}
	
	Override Void Die (Actor Source, Actor Inflictor,Int DMGFlags,Name MeansOfDeath)
	{
		Super.Die (Source,Inflictor,DMGFlags,MeansOfDeath);
		
		SM_EndFiring();
		QuickMelee = False;
		UseSec = Null;
		ChaseTimer = 0;
	}
	
	Override Void UserVariableDefaults()
	{
		Super.UserVariableDefaults();
		If (!(User_Armor ~== "None" || User_Armor ~== "Nothing")) //If the marine doesn't explicitly spawn unarmored.
		{
			If (!User_Armor || User_Armor ~== "" || User_Armor ~== " ") //Default armor.
				GiveInventory ("GreenArmor",1);
			Else
				GiveInventory (User_Armor,1); //Try giving whatever armor available in the current session that the mapper wants.
		}
		SM_HandleMarineColoring (User_Color);
	}
	
	Override Bool ShouldAttack (Bool NoStateJump)
	{
		If (!Target) Return False;
		If (!CanAttack()) Return False;
		Vector3 FirePos = (0,-6,42); //Will be changable once I implement kneeling and lying down.
		Int Threat = AssessThreatLevel (Target);
		
		//console.printf ("fire delay is %d tics",nextfiredelay);
		//TODO:
		//Use different fire heights if the marine decides to fire kneeling or lying down.
		//Make the marines use HE-FRAG grenades:
			//With random RNG, for variety.
			//If the rifle is too ineffective against their target.
			//And/Or if they are attacking around a crowd of enemies.
			//If HE would be too ineffective (e.g against Cyberdemons or god mode players), but the target doesn't have +NOPAIN, they will throw flashbangs.
		
		
		//Check if you should fire your gun.
		Double Dist = Distance3D (Target);
		//If low on ammo, do a quick melee attack on your enemy instead, if its' close enough and less dangerous than you. And then retreat to reload.
		QuickMelee = (AmmoCount <= 4 && Threat < Self.ThreatLevel && Dist <= MeleeRange*3);
		If (!QuickMelee && !NextFireDelay && SM_CheckLOF (FirePos))
		{
			Double Buff = SM_IsCrouched() ? 0.5 : 1.0;
			Vector4 SSpread = (0.4*Buff,-0.4*Buff,0.4*Buff,-0.4*Buff); //Single shot spread.
			Vector4 BSpread = (1.1*Buff,-1.1*Buff,1.1*Buff,-1.1*Buff); //Burst fire spread.
			Vector4 FSpread = (2.2*Buff,-2.2*Buff,2.2*Buff,-2.2*Buff); //Full auto spread.
			
			//NOTE: The random numbers allow marines to sometimes decide to use a different sub-optimal firing mode, for variety.
			If (!NoStateJump)
			{
				//If the target is dangerous, or it's at least above normal, and you'd hit it at least 8 times (Counts multiple enemies too, for "crowd control").
				//Fire a burst instead too sometimes.
				Int FullAutoThreshold = (Health <= SpawnHealth()/6) ? 4 : 8; //If low on health, the marines will more desperately fire full auto.
				Bool DoFullAuto = (Random (0, 255) < 200);
				If ((DoFullAuto && Threat >= THREAT_DANGEROUS ||
				DetermineHitChance (Target,!SM_DumbHitCheck,Dist,2.2,15,FirePos,FSpread,MaxTargetRange,DHC_THRUHOSTILES) >= FullAutoThreshold))
				{//https://youtu.be/LPAEgHsJYxk?si=4EdaE-oCczn5ehDD&t=75
					BurstSize = MAGAZINE_SIZE;
					AttackType = FIRE_FULLAUTO;
					a_log ("i have decided to fire in full auto");
				}
				//If your enemy is weak.
				Else If (Random (0, 255) >= 3 && (/*Threat < THREAT_ABOVENORMAL ||*/
				//Or you decided against full auto, but would hit the non-weak enemy at least twice.
				DetermineHitChance (Target, !SM_DumbHitCheck, Dist, 1.1, 3, FirePos, BSpread, MaxTargetRange) >= 2))
				{//Then fire a burst.
					BurstSize = 3;
					AttackType = FIRE_BURST;
					a_log ("i have decided to fire a burst");
				}
				Else
				{//Fall back to single accurate shots if neither full auto or bursts would work. Or just fire single shots instead sometimes.
					BurstSize = 1;
					AttackType = FIRE_SINGLE;
					a_log ("i have decided to fire a single shot");
				}
				
				ChaseTimer = 0;
				SetStateLabel ("Fire");
			}
			Return True;
		}
		
		//Check if you should do melee. But only on weak-ish enemies.
		Int MeleeChance = bAvoidMelee ? 32 : 128;
		If (QuickMelee) //Additional melee chance if you are low on ammo.
			MeleeChance += 32;
		If (Random (0,255) < MeleeChance && Threat < THREAT_DANGEROUS)
		{
			Bool CanSee = CheckSight(Target,SF_IGNOREWATERBOUNDARY);
			
			If (KAI_CheckMeleeRange (Target) && CanSee) //Check the standard melee range.
			{
				If (!NoStateJump)
				{
					FCheckPosition TM;
					Int DropkickChance = (bAvoidMelee ? 32 : 72)*FRandom (1.0f,2.0f);
					//It's not safe to jump this far, so don't do this.
					If (!CheckMove (Vec2Angle (64,AngleTo(Target)),PCM_NOACTORS|PCM_DROPOFF))
						DropkickChance = -1;spawn("kai_debugpoint",Vec3Angle (64,AngleTo(Target)));
					//Check if the enemy can move this far back.
					If (DropkickChance != 1 && CheckMove ( Target.Vec2Angle(128, AngleTo(Target) ),tm:TM))
					{
						//If there is a dropoff bigger than the targets' height, 128 MU from the direction you will face him at, be extra likely to punt him.
						If ((TM.FloorZ+Target.Height) <= Target.FloorZ)
							DropkickChance += RandomPick (20,30,40);
						
						//Major points if the enemy will actually be HURT by falling off.
						If ((Level.MonsterFallingDamage || Target.bFallDamage) && !(TM.CurSector.Flags & Sector.SECF_NOFALLINGDAMAGE))
							If (Target.ApplyDamageFactor ("Falling",100) > 0) //Also check if it has a damage factor making it immune to this damage.
								Dropkickchance += 50;
					}
					ChaseTimer = 0;
					//Might do a flying kick that knocks actors around.
					If (Random (0,255) < DropkickChance)
					{
						SetStateLabel ("Melee.Jumpkick");
						Return True;
					}
					//Randomly choose between kicks and rifle butts.
					If (Random (False,True) == True)
						SetStateLabel ("Melee.Smack");
					Else
						SetStateLabel ("Melee.Kick");
				}
				Return True;
			}
			Else If (CanSee && Random (0,255) < (bAvoidMelee ? 88 : 224) && KAI_CheckMeleeRange (Target,MeleeRange*4)) //Check 4 times further sometimes.
			{
				ChaseTimer = 0;
				If (!NoStateJump)
					SetStateLabel ("Melee.Kick.Run");
				Return True;
			}
		}
		
		Return False;
	}
	
	//Marines have identical criteria for if an actor is hostile as my MVP vehicles do.
	Override Bool IsActorHostile (Actor Other)
	{
		Return (Other && (IsHostile (Other) || IsTargetingAllies (Self, Other)));
	}
	
	Override Void OnWander()
	{
		Super.OnWander();
		Bool UsedLine;
		If (!IsDangerNearby())
			UsedLine = SM_MarineUseLine(faceline:True); //Check if there's a line in front of use to use.
		
		//If (UsedLine) 
			//SetStateLabel ("Interact");
	}
	
	//Actions the marine is performing, can be stacked on each other like flags.
	Enum MarineStates
	{
		MARINE_IDLING 	= 1 << 0, //Bing chilling
		MARINE_CHASING	= 1 << 1, //Chasing someone.
		MARINE_FIRING 	= 1 << 2, //Shooting
		MARINE_THROWING	= 1 << 3, //Throwing a grenade
		MARINE_MELEE	= 1 << 4, //Beating someone up
		MARINE_RELOAD 	= 1 << 5, //Reloading
		MARINE_RETREAT	= 1 << 6, //GTFOing, assumed to be from some danger by default.
		MARINE_KNEELING	= 1 << 7, //Kneeling down.
		MARINE_LYINGDOWN= 1 << 8, //Lying down on the ground.
		//MARINE_PATROL	= 1 << 9, //Patrolling
	}
	
	Const MARINE_HEARDIST = 4096; //How far can the marine hear.
	Const MARINE_FOV = 120; //How wide the marine can see.
	Const MAGAZINE_SIZE = 30; //How much ammo does the marine have per magazine ?
	Const MARINE_FIREFOV = 60; //The FOV within which the marine can fire his VelInterceptEx() bullets without looking stupid.
	Const MARINE_USEPATIENCE = 10; //How long the marine stays in the interact state.
	Const MARINE_CHASETIME = 350; //Chase your target for approximately 30 seconds after he has gone out of sight or died, before going to your idle state.
	
	Mixin SM_SplashFunctions;
	
	Int MarineState; //What the marine doin'.
	Actor NearestEnemy; //The marines' closest enemy, used to stay away from enemies.
	Int RetreatLoops; //How many times the retreat state should be called.
	UInt8 InteractWaits; //Keeps track of how many times the interact state loops before the marine gives up waiting on the sector he used to stop.
	Int AimPos; //Where is the marine aiming ? Similar to the TurretAimPos on the vehicles.
	Int AimTimer; //If the marine has been trying to aim and fire at the target for this long, then it's not working.
	Int ChaseTimer; //How long has the marines' target being dead or out of sight ?
	
	//Shooting variables.
	Int AmmoCount; //How much ammo the marine has.
	Int BurstCounter; //Used by the burst fire tracking.
	Int BurstSize; //How many shots to fire.
	UInt8 NextFireDelay; //How long until the marine can shoot again, so that they don't shoot constantly. This can only be a ~7 second delay at most.
	Int AttackType; //How is the marine firing his gun ?
	Bool RemovedOldMag; //Used for reloading, if the marine was interrupted by flinching mid-reload, this skips the part where he throws the old magazine out.
	Enum RifleFireModes
	{
		FIRE_BURST, //Fire a 3 round burst like the base M4 Carbine. Decently accurate.
		FIRE_SINGLE, //Fire a single accurate shot.
		FIRE_FULLAUTO, //Fire everything, pretty inaccurate, adds recoil, and faster than normal fire.
	}
	Bool SittingDown; //Is the marine firing while kneeling or lying down ? Adds an overall accuracy buff.
	
	//Other attacks
	Bool HasBerserk; //Has an active berserk pack.
	Int JumpkickDelay; //How long before the marine does a flying kick again.
	Bool QuickMelee; //If the marine does a melee attack while this is one, he will retreat a bit before going back to See.
	
	String User_Armor; //The name of the armor the marine should be equipped with upon spawning. Default is the vanilla green armor.
	String User_Color; //What color is the marine ?
	
	vector3 OLDKICKPOSDEBUG;
	
	States
	{
		//When the marine is looking around with this animation, he actually changes his sight angle.
		Spawn:
			MARI EEEEEEEE 3 //Look 80 degrees to your left.
			{
				Angle += 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle -= 80;
				If (Target) SetStateLabel ("See");
			}
			MARI FFFFFFFF 3 //Look 20 degrees to your right.
			{
				Angle -= 20;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 20;
				If (Target) SetStateLabel ("See");
			}
			MARI GGGGGGGG 3 //Look 80 degrees to your right.
			{
				Angle -= 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 80;
				If (Target) SetStateLabel ("See");
			}
			MARI HHHHHHHH 3 KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV); //Just look straight.
			Loop;
		Idle:
			MARI A 0 SM_SetMarineState (MARINE_IDLING,0,True); //No more acting, only bing chilling.
			MARI AABBCCDD 3
			{
				KAI_Wander(8,768,anglelimit:20);
				KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET);
			}
			MARI D 0 A_Jump (4,"Idle.Stay","Idle.Stay.Alert"/*,"Idle.Stay.Kneel"*/); //Might stay around.
			TNT1 A 0 A_JumpIf (Random (0,255) < 8 && !Target && AmmoCount <= MAGAZINE_SIZE/2,"Reload"); //Reload if we have half ammo.
			Loop;
		Idle.Stay: //Staying around idle. Exactly like in the spawn state.
			MARI EEEEEEEE 3 //Look 80 degrees to your left.
			{
				Angle += 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle -= 80;
				If (Target) SetStateLabel ("See");
			}
			MARI FFFFFFFF 3 //Look 20 degrees to your right.
			{
				Angle -= 20;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 20;
				If (Target) SetStateLabel ("See");
			}
			MARI GGGGGGGG 3 //Look 80 degrees to your right.
			{
				Angle -= 80;
				KAI_Look (LOF_NOJUMP,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV);
				Angle += 80;
				If (Target) SetStateLabel ("See");
			}
			MARI HHHHHHHH 3 KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV); //Just look straight.
			TNT1 A 0 A_Jump (48,"Idle");
			Loop;
		Idle.Stay.Alert: //Standing there, menacingly.
			MARI IIIIIIIIIII 3 KAI_Look (0,0,MaxTargetRange,MARINE_HEARDIST,MARINE_FOV,extraflags:KAIL_CHASETARGET); //Roughly 1 second of staying still.
			TNT1 A 0 A_SetAngle (Angle+RandomPick (40,30,20,10,0,0,-10,-20,-30,40));
			TNT1 A 0 A_Jump (48,"Idle");
			Loop;
		//Idle.Stay.Kneel: //Standing around while kneeling down, can randomly pick this one. TG5 needs to make sprites for me to be able to add it though.
		See:
			TNT1 A 0 SM_SetMarineState (MARINE_CHASING,0,True); //NOTE: Removing all marine stauses might cause problems if I implement the patrolling state ?
			MARF JJKKLLMM 3 SM_Chase (chaseflags:CHF_DONTIDLE);
			TNT1 A 0 A_JumpIf (Random (0,255) < 8 && !Target && AmmoCount <= MAGAZINE_SIZE/2,"Reload"); //Reload if we have half ammo.
			Goto See+1;
		Retreat: //Run away a certain number of steps.
			MARI AAABBBCCCDDD 1 SM_RunAway (Target,192);
			TNT1 A 0
			{
				RetreatLoops--;
				console.printf ("%d retreats left",retreatloops);
				If (RetreatLoops < 0 || !Target) //Once we are done running like a bitch. Or if there's no target left.
				{
					//We are supposed to be reloading, so do that.
					If (MarineState & MARINE_RELOAD)
						Return FindState ("Reload",True);
					
					Return FindState ("See",True);
				}
				//Decrement twice as fast whenever the target is out of sight or dead.
				If (IsDead (Target) || !CheckSight (Target,SF_IGNOREWATERBOUNDARY))
					RetreatLoops--;
				Return State (Null);
			}
			Loop;
		Fire: //Aim up.
			MARF JJJ 2; 
			MARF A 2 //Wait until you can actually aim properly at the enemy.
			{
				If (++AimTimer >= GameTicRate * 3) //https://www.youtube.com/watch?v=VX5gXHcbJAk
					Return FindState ("Fire.End",True);
				If (Target && CheckFOV(Target,160/2) && AimingAheadOfTarget())
					Return FindState ("Fire.Loop");
				Return State (Null);
			}
			Wait;
		Fire.Loop:
			MARF A 0 SM_SetMarineState (MARINE_FIRING,MARINE_IDLING|MARINE_THROWING|MARINE_IDLING|MARINE_CHASING); //Set marine actions.
			MARF A 3 //Delay
			{
				If (AttackType == FIRE_FULLAUTO)
					Tics = 2; //Fire faster in full auto.
				If (AmmoCount <= 0) //Out of ammo.
				{
					A_StartSound ("VRifle/EmptyGun",CHAN_WEAPON,attenuation:ATTN_STATIC); //Marine tried dry firing.
					Return FindState ("Fire.End");
				}
				
				Return State (Null);
			}
			MARF E 3 Light ("MarineMuzzleFlash") SM_FireBullet();
			MARF A 0
			{
				If (AttackType == FIRE_FULLAUTO && !Target || IsDead (Target))
					LookForPlayers (True); //Look for a new target.
				
				BurstCounter++;console.printf ("fired %d rounds",burstcounter);
				//Run line of fire checks.
				If (!SM_CheckLOF ((0,-6,42))) //The default parameters for this function are for marines firing bursts.
					Return FindState ("Fire.End",True);
				Return SM_CheckRefire (10,"Fire.End",MARINE_FIREFOV); //Since we are firing a short burst, be very likely to stop if anything is in the way.
			}
			MARF A 0 A_JumpIf (BurstCounter >= BurstSize,"Fire.End");
			Goto Fire.Loop;
		//Run some checks before you stop firing fully, like making sure you aren't out of ammo right after stopping.
		Fire.End:
			TNT1 A 0
			{
				SM_EndFiring();
				If (AmmoCount <= 0) //Out of ammo.
				{
					//Target is alive and in sight.
					If (!IsDead (Target) && CheckSight (Target,SF_IGNOREWATERBOUNDARY))
					{
						//Determine how much to run away based on how dangerous your enemy is.
						Switch (AssessThreatLevel (Target))
						{
							Case THREAT_UNSTOPPABLE:
							Case THREAT_SUPERDANGER:
								//RetreatLoops = Random (32,48);a_log ("now this is an avengers level threat");
								//Break;
							Case THREAT_VERYDANGEROUS:
							Case THREAT_DANGEROUS:
								RetreatLoops = Random (12,24);a_log ("this is dangerous");
								Break;
							Default:
								RetreatLoops = Random (6,12);
								Break;
						}
						
						SM_SetMarineState (MARINE_RELOAD,0); //Tell the Retreat state we need to reload, so it goes there once the RetreatLoops end.
						Return FindState ("Retreat"); //Run either far enough or out of sight, to reload.
					}
					Else //Dead or out of sight, reload now.
						Return FindState ("Reload");
				}
				Return State (Null);
			}
			Goto See;
		Reload: //Reload the rifle.
			TNT1 A 0 SM_SetMarineState (MARINE_RELOAD,0);
			TNT1 A 0 A_JumpIf (RemovedOldMag,5); //We probably flinched mid reload or some shit, so go right to the end of the reload sequence.
			MARA ABC 6;
			MARA D 4 {A_SpawnItemEx ("SM_EmptyMagazine",0,-16,27,0,FRandom(-2,-5),FRandom(-1,-0.5)); RemovedOldMag = True;}
			MARA C 6;
			MARA B 6
			{
				A_StartSound ("Marine/Reload",CHAN_WEAPON);
				AmmoCount = MAGAZINE_SIZE; //Reset counter to the magazine size.
			}
			MARA A 4
			{
				SM_SetMarineState (0,MARINE_RELOAD); //We're done here.
				RemovedOldMag = False;
			}
			TNT1 A 0 A_JumpIf (MARINE_IDLING,"Idle");
			Goto See;
		Melee:
			#### # 0 A_Jump (255,"Melee.Smack","Melee.Kick","Melee.Jumpkick"); 
		Melee.Smack: //Smack enemy with your rifle.
			#### # 0 A_FaceTarget();
			MARI A 3 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_IDLING);
			MARM A 2 A_FaceTarget();
			MARM B 8
			{
				Double DmgMul = HasBerserk ? 10 : 1;
				Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
				A_CustomMeleeAttack (Random[Punch](4,8)*DmgMul,HitSound,"Marine/MeleeMiss",'Melee',HasBerserk);
				If (HasBerserk) Target.A_Recoil (2*Cos(Target.PitchTo(Self,Target.Height/2)));
			}
			Goto Melee.End;
		Melee.Kick: //Kick enemy in place, 50/50 chance on which one the marine will use since they are more or less the same.
			#### # 0 A_FaceTarget();
			MARI A 2 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_IDLING);
			//#### # 0 A_JumpIf ((Distance2D(Target) >= (MeleeRange/2)+Target.Radius),"Melee.Kick.Run");
			MARM F 8
			{
				Double DmgMul = HasBerserk ? 6 : 1;
				Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
				A_CustomMeleeAttack (Random[Punch](4,8)*DmgMul,HitSound,"Marine/MeleeMiss",'Melee',HasBerserk);
				Target.TriggerPainChance ('Melee'); //Additional pain chance.
				If (HasBerserk)
				{
					Target.TriggerPainChance ('Melee'); //Even more pain.
					Target.A_Recoil (5*Cos(Target.PitchTo(Self,Target.Height/2))); //Produce recoil from the bottom of the marine to the middle of the victim.
					Target.Vel.Z += 10; //Wee
					Target.bBlasted = True; //Even more damage.
				}
			}
			Goto Melee.End;
		Melee.Kick.Run: //Too far to kick, run to the enemy.
			MARM DDEE 2
			{
				//Give up on the target if its' dead, nonexistent, or way too far away.
				Int RunSeconds = HasBerserk ? 6 : 3; //How many seconds to run before giving up.
				If (!KAI_CheckMeleeRange(Target,1024) || IsDead (Target) || ++ChaseTimer >= (GameTicRate*RunSeconds)/CurState.Tics)
				{
					ChaseTimer = 0;
					Return SeeState;
				}
				
				Double OldSpeed = Speed;
				If (!HasBerserk)
					A_SetSpeed (Speed*2.5); //The marine is just slightly faster than the stock players' walking speed.
				Else
					A_SetSpeed (Speed*3);
				KAI_MoveTowards (Target.Pos,0.25,25);
				A_SetSpeed (OldSpeed);
				If (Distance2D(Target) <= (MeleeRange/2)+Target.Radius)
					Return FindState ("Melee.Kick",True); //Now we can punt it.
				Return State (Null);
			}
			Loop;
		Melee.Jumpkick: //Do a flying kick to your enemy, pushing them back in the process.
			MARI A 1 SM_SetMarineState (MARINE_MELEE,MARINE_IDLING|MARINE_THROWING|MARINE_FIRING|MARINE_IDLING);
			#### # 0
			{
				A_FaceTarget();
				A_StartSound ("Marine/Throw");
				A_Recoil (-10);
				Vel.Z += 6;
				console.printf ("start position %d %d %d",pos);
				OLDKICKPOSDEBUG = pos;
			}
			MARI A 1; //One tick delay for the ground check to not immediately return true.
			Marine.Jumpkick.Loop: //Flying loop.
				MARM C 1
				{a_log ("waiting to hit something");
					//If we land or hit an actor.
					If (GetZAt () >= Pos.Z || BlockingMobj)
						Return FindState ("Marine.Jumpkick.Attack");
					Return State (Null);
				}
				Wait;
		Marine.Jumpkick.Attack: //Where the magic happens
			MARM C 1
			{
				If (BlockingMobj)
				{
					Double DmgMul = HasBerserk ? 4 : 1;
					Sound HitSound = HasBerserk ? "Marine/PowerMelee" : "Marine/Melee";
					a_log ("THIS IS SPARTA");
					A_StartSound (HitSound,CHAN_WEAPON);
					Int Dmg = BlockingMobj.DamageMobj (Self,Self,Random[Punch](8,12)*DmgMul,'Melee');
					BlockingMobj.TraceBleed (Dmg,Self);
					If (!bDontThrust) //Push the enemy back.
					{
						Double MassMul = KAI_Math.LinearMap (BlockingMobj.Mass,1000,0,0.0,1.0);
						console.printf ("mass %d, mass multiplier %.2f",blockingmobj.mass,massmul);
						Double XVel , YVel, ZVel;
						XVel = YVel = 8*MassMul;
						ZVel = 4*MassMul;
						Double BuffMul = 1;
						If (HasBerserk) //Change velocities.
							BuffMul = 2;
						
						//Double Ang = BlockingMobj.AngleTo (Self);
						BlockingMobj.Vel.X += (XVel * Cos (Angle) + YVel * Sin (Angle))*BuffMul;
						BlockingMobj.Vel.Y += (XVel * Sin (Angle) - YVel * Cos (Angle))*BuffMul;
						BlockingMobj.Vel.Z += ZVel*BuffMul;
						BlockingMobj.bBlasted = True;
					}
				}console.printf ("end position %d %d %d, difference %d %d %d, difference distance %d",pos,level.vec3diff(pos,OLDKICKPOSDEBUG),
				level.vec3diff(pos,OLDKICKPOSDEBUG).length());
				JumpKickDelay = GameTicRate*Random(1,4);
			}
			Goto Melee.End;
		Melee.End: //Just in case I need to add any shit here.
			#### # 0 SM_SetMarineState (0,MARINE_MELEE); //We are no longer doing melee.
			#### # 0 A_JumpIf ((MarineState & MARINE_RELOAD),"Reload");
			#### # 0
			{
				ChaseTimer = 0;
				If (QuickMelee) //We came here to just do a quick attack.
				{
					QuickMelee = False;
					RetreatLoops += Random (2,6);
					Return FindState ("Retreat",True);
				}
				Return State (Null);
			}
			Goto See;
		//The marine is interacting with a door or the likes, so stop in place. This has no MarineState since if the marine flinches during this, he should move anyway.
		Interact:
			MARI EEEEFFFFGGGGHHHH 3
			{
				A_Log ("waiting in the interact state for the sector to finish moving.");
				LookExParams MarineSight;
				MarineSight.FOV = MARINE_FOV;
				//Wait until you either run out of patience, the sector stops moving!
				If (InteractWaits >= MARINE_USEPATIENCE || UseSec && (!UseSec.PlaneMoving(Sector.Floor) && !UseSec.PlaneMoving(Sector.Ceiling)) ||
				//Or you can see your target again.
				Target && IsVisible (Target,False,MarineSight))
				{if (interactwaits >= MARINE_USEPATIENCE) a_log ("too much waiting");
				if (!SM_SectorInMotion (UseSec)) a_log ("sector finished");
				if (Target && IsVisible (Target,False,MarineSight)) a_log ("enemy spotted");
					InteractWaits = 0;
					If (Target) //Had a target, go back to chasing.
						Return SeeState;
					Else //Bing chilling
						SetIdle();
				}
				
				Return State (Null);
			}
			TNT1 A 0 {InteractWaits++;}
			Loop;
		Pain:
			MARA E 0 SM_SetMarineState (0,MARINE_IDLING|MARINE_THROWING|MARINE_IDLING|MARINE_MELEE); //Being hurt interrupts staying idle, wandering, and throwing grenades.
			MARA E Random (7,14) A_Pain();
			MARA E 0
			{
				ChaseTimer = 0;
				If ((MarineState & MARINE_RELOAD)) //We were reloading before retreating.
				{
					If (!RetreatLoops) //Go to reloading, like if the marine was hurt mid reload. But do run away a bit first.
					{
						RetreatLoops = Random (2,5);
						Return FindState ("Retreat",True);
					}
					Else //If we have retreat loops, that means we were actually running before reloading.
						Return FindState ("Retreat",True); //Go right back to that.
				}
				Return State (Null);
			}
			MARA E 0 A_JumpIf ((MarineState & MARINE_RETREAT),"Retreat"); //Or running.
			MARA E 0 A_JumpIf ((MarineState & MARINE_FIRING),"Fire.End"); //End shooting now that you flinched.
			MARA E 0 A_JumpIf ((MarineState & MARINE_MELEE),"Melee.End"); //End beating the shit out of your enemy too.
			Goto See;
	}
}