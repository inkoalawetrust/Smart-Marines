//Restrict what actions the marine can perform when in range of this special zone.
//Useful for turning off certain features in specific parts of the map. Like restricting climbing in interiors to avoid having marines get stuck.
//The limited custom arguments are used for the moves the marine can perform. User variables are for more minor actions like healing allies and dodging.
Class SM_ActionRestrictor : KAI_MixinActor
{
	Default
	{
		Scale 0.25;
		+NoInteraction;
		
		//$Title Marine Restriction Zone
		//$Sprite MAROZ0
		//$Category Marines
		//$NotAngled
		
		//$Arg0 Range
		//$Arg0Tooltip "The range in which marines have to be to listen to the restrictor.\nA range of -1 affects all marines in the sector the zone is in."
		//$Arg0Default 256
		//$Arg1 Don't Take Cover
		//$Arg1Tooltip "Marines won't take cover when in range."
		//$Arg1Type 11
		//$Arg1Enum falsetrue
		//$Arg2 Don't Climb
		//$Arg2Tooltip "Marines won't climb over obstacles when in range."
		//$Arg2Type 11
		//$Arg2Enum falsetrue
		//$Arg3 Don't Jump
		//$Arg3Tooltip "Marines won't jump over gaps when in range."
		//$Arg3Type 11
		//$Arg3Enum falsetrue
		//$Arg4 Don't Crouch
		//$Arg4Tooltip "Marines won't crouch to go under tight spaces when in range."
		//$Arg4Type 11
		//$Arg4Enum falsetrue
	}
	
	Enum ArgNames
	{
		ARG_RANGE 	= 0,
		ARG_NOCOVER = 1,
		ARG_NOCLIMB = 2,
		ARG_NOJUMP	= 3,
		ARG_NOCROUCH= 4,
		//ARG_NOSWIM	= 5, //The args array isn't that big. And I don't want to use the angle to determine the restriction range or some stupid shit.
	}
	
	//More minor restrictions.
	Bool User_NoDodging; //Do not dodge when in range.
	Bool User_NoHealing; //Do not heal nearby allies when in range.
	//Bool User_NoSwimming; //Do not swim in and out of swimmable 3D floors.
	Bool User_DontWarn; //Do not alert nearby friends of enemies.
	Bool User_NoReloadRun; //Do not run away to reload.
	
	//Other settings
	Bool User_CheckSight; //In addition to only restricting marines in range, also only restrict them if they are in sight as well.
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen())
			Return;
		if (user_nododging) console.printf ("DODGING IS RESTRICTED");
		If (Args[ARG_RANGE] == -1) //Range is -1, so find all marines in the sector we are in instead.
		{
			For (Actor CurMo = CurSector.ThingList; CurMo != Null; CurMo = CurMo.SNext)
				RunRestrictor (CurMo);
			Return;
		}
		
		Let MarineSearch = BlockThingsIterator.Create (Self,Args[ARG_RANGE]);
		
		While (MarineSearch.Next())
			RunRestrictor (MarineSearch.Thing);
	}
	
	Void RunRestrictor (Actor Marine)
	{
		If (!Marine || !(Marine Is "SM_Marine") || Marine.bDormant || IsDead (Marine))
			Return;
		
		If (Args[ARG_RANGE] != -1 && Distance3DSquared (Marine) > Args[ARG_RANGE]*Args[ARG_RANGE])
			Return;
		
		If (User_CheckSight && !CheckSight (Marine,SF_IGNOREWATERBOUNDARY)) //Outta sight outta mind.
			Return;
		
		SM_RestrictionToken Restrictor = SM_RestrictionToken(Marine.FindInventory ("SM_RestrictionToken")); //Already have a token.
		If (!Restrictor)
			Restrictor = SM_RestrictionToken(Spawn("SM_RestrictionToken"));
			else console.printf("marine already got a token");
		
		If (Restrictor)
		{
			Restrictor.NoCover		= Args[ARG_NOCOVER];
			Restrictor.NoClimb		= Args[ARG_NOCLIMB];
			Restrictor.NoJump		= Args[ARG_NOJUMP];
			Restrictor.NoCrouch		= Args[ARG_NOCROUCH];
			//Restrictor.NoSwim		= User_NoSwimming;
			Restrictor.NoDodge		= User_NoDodging;
			Restrictor.NoHeal		= User_NoHealing;
			Restrictor.NoWarn		= User_DontWarn;
			Restrictor.NoReloadRun	= User_NoReloadRun;
			
			Restrictor.CheckSight	= User_CheckSight;
			Restrictor.MaxTargetRange = Args[ARG_RANGE];
			Restrictor.Master = Self;
		}
		If (KAI_DebugPrintMessages)console.printf ("restricting %p",marine);
		Restrictor.CallTryPickup (Marine); //Pick up the token
	}
}

Class SM_RestrictionToken : Inventory
{
	Default
	{
		Inventory.MaxAmount 1;
		ReactionTime 1; //This only needs to be given every tick to marines in range, no need for it to last longer than that.
	}
	
	//The naughty list. Checked by SM_IsRestricted().
	Bool NoCover, NoClimb, NoJump, NoCrouch, NoSwim, NoDodge, NoHeal, NoWarn, NoReloadRun;
	
	Bool CheckSight;
	
	Override Void AttachToOwner (Actor Other)
	{
		Super.AttachToOwner(Other);
		If (Other && !(Other Is "SM_Marine"))
			GoAwayAndDie();
		
		If (KAI_DebugPrintMessages)console.printf ("gave token %p to a %s",self,other.getclassname());
	}
	
	Override Void DoEffect ()
	{
		Super.DoEffect();
		
		If (Master && Owner && Random (0, 255) < 88) //Don't check every tick, for performance.
		{
			//Too far from the zone or the zone is out of sight.
			If (MaxTargetRange != -1 && Owner.Distance3DSquared (Master) > MaxTargetRange*MaxTargetRange || MaxTargetRange == -1 && Owner.CurSector != Master.CurSector ||
			(CheckSight && !Owner.CheckSight (Master,SF_IGNOREWATERBOUNDARY)))
				GoAwayAndDie();
		}
		If (!Master)
			GoAwayAndDie();
	}
}

//$GZDB_SKIP
//Custom group structure for marine NPCs.
Class SM_MarineGroup : KAI_NPCGroup
{
	Bool NoSpecialPlayerTreatment; //When the leader dies or vanishes, and the group tries assigning a new one, players aren't automatically assumed to be stronger.
	Bool IsPlayerGroup; //The group is formed by the player ordering marines around.
	
	Override Actor LeaderFallback ()
	{
		If (!Members.Size()) //Don't even have any members.
		{
			Destroy();
			Return Null;
		}
		
		Return GetStrongestMember (NoSpecialPlayerTreatment);
	}
	
	Override Void HandleGroupEvent (Int EventType, Actor Affected)
	{
		Bool EveryoneDied = GetNPCGroupFlags() & NPCGRP_EVERYONEDIED; //Need to grab this flag before the Super. call, which removes said flag.
		Super.HandleGroupEvent(EventType,Affected);
		
		//Use "(Player name)'s Fireteam/Squad/Platoon/Whatever" naming scheme if led by a player.
		If (EventType == GRPEVNT_NEWLEADER)
		{
			IsPlayerGroup = Affected.Player;
			If (Affected.Player)
				GroupName = String.Format ("%s's %s",Affected.Player.GetUsername(),GetGroupSizeType());
		}
		
		//One NPC was revived after everyone died already. They're now the new leader by virtue of actually being alive.
		If (EventType == GRPEVNT_REVIVAL && Leader != Affected && EveryoneDied)
			ChangeLeader(Affected);
		
		//Update group name to reflect the size of it. Only used if the groups' leader is a player.
		If (Leader && Leader.Player && (EventType == GRPEVNT_JOIN || EventType == GRPEVNT_LEFT))
			GroupName = String.Format ("%s's %s",Leader.Player.GetUsername(),GetGroupSizeType());
	}
	
	//Return a string that matches the size of the marine group, i.e if the group has 20 members, it'll be called a platoon, if less than 5 a fireteam, etc.
	String GetGroupSizeType ()
	{
		Int Size = Members.Size()+1;
		If (Size >= 1000)
			Return "Regiment";
		Else If (Size >= 300)
			Return "Batallion";
		Else If (Size >= 100) //Realistically, this is the absolute most marines or other friendly NPCs any map will give the player. Even a platoon may be too much.
			Return "Company";
		Else If (Size >= 30)
			Return "Platoon";
		Else If (Size >= 8)
			Return "Squad";
		Else
			Return "Fireteam";
		
		Return "Group"; //Generic fallback
	}
}

Class SM_Bullet : KAI_BaseProjectile
{
	Default
	{
		Radius 4;
		Height 6;
		Speed 170;
		FastSpeed 200;
		DamageFunction (Random (10,20));
		XScale 0.2;
		YScale 0.166666; //0.2 / 1.2
		ProjectileKickback 10;
		Decal "BulletChip";
		DamageType "SmallRifleBullet";
		Obituary "%o found out that rifle rounds are more dangerous than in the movies";
		BounceSound "VRifle/BulletRicochet";
	}
	Bool HitLiquid;
	Actor Tracer;
	
	Bool DoSplash (Int LiquidType, Bool UpsideDown = False) //Static so SM_ShrapnelPuff can use it too.
	{
		If (LiquidType == LIQUID_NONE) Return False;
		Actor Splash = Spawn ("SM_BulletSplash",Pos);
		
		Switch (LiquidType)
		{
			Case LIQUID_NUKAGE:
				Splash.A_SetTranslation ('SM_Splash_Nukage');
				Break;
			Case LIQUID_LAVA:
				Splash.A_SetTranslation ('SM_Splash_Lava');
				Break;
			Case LIQUID_BLOOD:
				Splash.A_SetTranslation ('SM_Splash_Blood');
				Break;
			Case LIQUID_SLIME:
				Splash.A_SetTranslation ('SM_Splash_Slime');
				Break;
			Default:
				Break;
		}
		Double Size = FRandom (0.4,0.6);
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		Splash.bXFlip = Random (False,True);
		Return True;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		Let Trail = Spawn ("SM_Tracer",Pos);
		KAI_TracerActor(Trail).WarpOffsets = (-35,0,0);
		Trail.Master = Trail.Target = Self;
		Trail.Angle = Angle;
		Trail.Pitch = Pitch;
	}
	
	Override Int SpecialMissileHit (Actor Victim)
	{
		If (Super.SpecialMissileHit(Victim) == 1) Return 1;
		
		String APC = "MVP_APC";
		String APCProp = "MVP_APCProp";
		
		If (Victim == Target) Return -1; //Ignore the shooter, so players firing the rifle with god mode don't have bullets bounce off of THEM.
		
		//Always bounce off players with god mode. Or player pawns and monsters with Invulnerable or NoDamage.
		If ((HasGodMode(Victim) || IsIndestructible(Victim) && !IsInanimateObject(Victim)) && DeflectProjectile (Victim,0,FRandom(0.4,0.6),FRandom (1.,0.7),(10,-10),(10,-10))) Return 1;
		//Be at least somewhat likely to bounce off if hitting an APC.
		Else If ((Victim Is APC || Victim Is APCProp) && DeflectProjectile (Victim,192,FRandom(0.4,0.6),FRandom (1.,0.7),(10,-10),(10,-10))) Return 1;
		//Almost always bounce off the main battle tank.
		Else If (DeflectOffTank(Victim) && DeflectProjectile (Victim,254,FRandom(0.5,0.8),FRandom (1.,0.7),(20,-20),(20,-20))) Return 1;
		//Be very likely to bounce off a non-bleeding actor with a lot of health.
		Else If (Victim.bNoBlood && !IsIndestructible (Victim) && Victim.SpawnHealth() >= 2000 && DeflectProjectile (Victim,64,FRandom(0.5,0.7),FRandom (1.,0.8),(6,-6),(6,-6),attenuation:0.75)) Return 1;
		
		
		Return -1;
	}
	
	Bool DeflectOffTank (Actor Other)
	{
		//KLUDGE: Jesus Christ why does it fucking error out when you directly check for class strings for classes that may not exist.
		Name MBT = "MVP_MBT";
		Name MBTProp = "MVP_MBTProp";
		Name MBTTurret = "MVP_MBTTurret";
		Name MBTTurretProp = "MVP_MBTTurretProp";
		Name MissileTurret = "MVP_MBTMissileTurret";
		Name MissileTurretProp = "MVP_MBTMissileTurretProp";
		Name BMPTTurret = "MVP_BMPTTurret";
		Name BMPTTurretProp = "MVP_MBTTerminatorTurretProp";
		Name SPAAGTurret = "MVP_SPAAGTurret";
		Name SPAAGTurretProp = "MVP_MBTSPAAGTurretProp";
		
		//Bounce off MBT turrets.
		If (Other Is MBTTurret || Other Is MBTTurretProp
		/*|| Other Is MissileTurret*/ || Other Is MissileTurretProp
		|| Other Is BMPTTurret || Other Is BMPTTurretProp
		|| Other Is SPAAGTurret || Other Is SPAAGTurretProp)
			Return True;
		//Deflect off the tank hulls too of course.
		Else If (Other Is MBT || Other Is MBTProp)
			Return True;
		Return False;
	}
	
	Mixin SM_SplashFunctions;
	
	States
	{
		Spawn:
			BUL1 A 0;
			BUL1 # 1// Light ("MarineBulletLight")
			{
				Frame = UpdateProjectileElevation (2,2,0,1,1); //C, C, A, B, B
				A_FaceMovementDirection();
			}
			Loop;
		Death: //Bullet hit level geometry.
			TNT1 A 1
			{
				//The floor was hit.
				If (Pos.Z <= FloorZ)
					HitLiquid = DoSplash(CheckLiquid(FloorPic));
				//The ceiling was hit.
				Else If (Pos.Z + Height >= CeilingZ)
					HitLiquid = DoSplash(CheckLiquid(CeilingPic),True);
				
				If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
				Else
				{
					A_StartSound ("VRifle/Impact");
					If (Target) SpawnPuff ("BulletPuff",Pos,AngleTo(Target),AngleTo(Target),2);
				}
			}
			Stop;
		XDeath: //Bullet hit a bleeding actor.
			TNT1 A 1
			{
				A_StartSound ("Marine/PowerMelee");
				TraceBleed (GetMissileDamage(1,7),Self);
				If (Target) SpawnBlood (Pos,AngleTo(Target),GetMissileDamage(1,7));
			}
			Stop;
		Crash: //Bullet hit a non bleeding actor.
			TNT1 A 1
			{
				A_StartSound ("VRifle/Impact");
				If (Target) SpawnPuff ("BulletPuff",Pos,AngleTo(Target),AngleTo(Target),2);
			}
			Stop;
	}
}

//So much of this is ripped from the MVP.
Class SM_BulletCasing : Actor
{
	Default
	{
		Radius 4;
		Height 8;
		XScale 0.1;
		YScale 0.08333; //0.1 / 1.2
		Mass 1; //Very light, mainly so it doesn't make huge splashes on TERRAIN flats.
		+NoBlockmap;
		//+NoInteraction;
	}
	States
	{
		Spawn:
			BUL1 DEFG Random (2,4) A_CheckFloor ("Death");
			Loop;
		//Stay for 4 seconds, then fade over the course of 4 seconds.
		Death:
			BUL1 H 0 A_StartSound ("VRifle/CasingImpact",volume:0.75,2.5);
			BUL1 H 140;
			BUL1 H 4 A_FadeOut (0.0142);
			Wait;
	}
}

Class SM_50CalCasing : SM_BulletCasing
{
	Default
	{
		Radius 6;
		Height 10;
		XScale 0.15;
		YScale 0.125; //0.15 / 1.2
	}
}

//Ripped from the old code since it works.
Class SM_BulletSplash : Actor
{
	Default
	{
		//Scale 0.5;
		+NoInteraction;
		+MoveWithSector;
	}
	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_StartSound("VRifle/WaterHit",CHAN_VOICE,attenuation:ATTN_STATIC);
			HSPL ABCDEFGHI 1;
			Stop;
	}
}

Class SM_FragGrenade : KAI_BaseProjectile
{
	Default
	{
		Radius 4;
		Height 8;
		Mass 1;
		Gravity 0.5;
		Scale 0.2;
		Speed 30;
		BounceFactor 0.4;
		WallBounceFactor 0.5;
		ReactionTime 35*3; //Used as the fuse timer, similar to how A_Countdown uses it.
		BounceType "Hexen";
		BounceSound "Grenade/Bounce";
		DamageType "Explosive";
		ExplosionRadius 256;
		ExplosionDamage 192;
		+KAI_BaseProjectile.NoFriendlyFire; //Go through allies, but that DOESN'T mean the explosions harmless to them.
		//Projectile;
		-NoGravity;
		+RollSprite;
		+FloorClip;
		+CanBounceWater;
		+DontBounceOnSky;
		+BounceOnActors;
	}
	
	Bool HitLiquid;
	Mixin SM_SplashFunctions;
	
	//We have a special 3D floor mode too, for impacts under swimmable water.
	Void GrenadeSplash (Int LiquidType, Bool UpsideDown = False, F3DFloor FFloor = Null)
	{
		If (LiquidType == LIQUID_NONE) Return;
		HitLiquid = True;
		Actor Splash = SpawnLiquidSplash (LiquidType,"Grenade/WaterBlast",attenuation:0.25,1000,384,128,'Explosive', True);
		
		Int QF_Flags = (QF_SCALEDOWN|QF_GROUNDONLY);
		If (FFloor) //This is a splash for a liquid 3D floor.
		{
			QF_Flags &= ~QF_GROUNDONLY; //3D air shake for liquids.
			QF_Flags |= QF_3D;
			Splash.SetZ (FFloor.Top.ZAtPoint(Splash.Pos.XY)); //Move the blast to the top of the swimmable floor.
		}
		Splash.A_QuakeEx (0.5,0.5,0.5,24,0,1024,"",QF_Flags,rollintensity:0.3);
		Double Size = FRandom (2,4);
		If (FFloor) //Scale the splash down based on depth.
		{
			Size *= KAI_Math.LinearMap (WaterDepth,0,256,1.0,0.0);
			If (KAI_DebugPrintMessages)console.printf ("swimmable floor falloff is %.3f",KAI_Math.LinearMap (WaterDepth,0,256,1.0,0.0));
		}
		If (HEGrenade) Size *= 1.5;
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		//Splash.Scale.X *= UpsideDown ? FRandom (-1.2,-2.5) : FRandom (1.2,2.5);
		Splash.bXFlip = Random (False,True);
	}
	
	//Fire an omnidirectional blast of shrapnel.
	Void SM_SpawnHitscanShrapnel (Int Amount, Int Damage = 2, Double Range = 512, Bool Air = False, Class <Actor> Puff = "SM_ShrapnelPuff")
	{
		If (HEGrenade) Return; //No frag sleeve to spill everywhere.
		Vector3 OldPos = Pos;
		SetXYZ (Pos.PlusZ(Height/2));
		For (Int I = Amount; 0 <= I; I--)
		{
			Double RNGPitch;
			If (Air)
				RNGPitch = FRandom (90,-90);
			Else
				RNGPitch = FRandom (10,-90);
			LineAttack (FRandom (0,360),Range*FRandom(0.75,1.25),RNGPitch, Int(Damage*FRandom(0.75,1.25)) ,'Shrapnel',Puff, LAF_TARGETISSOURCE|LAF_OVERRIDEZ,offsetz:Height/2);
		}
		SetXYZ (OldPos);
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen())
			Return;
		
		//The actual timer.
		If (IsInState(Self,"Spawn"))
		{
			If (HazardAge < GetAge() && GetAge() % 3 == 0) //Emit a death zone pre-detonation. Alerting all KAI NPCs.
			{
				Int HazLevel = HEGrenade ? HazardInfo.HAZARD_LARGE : HazardInfo.HAZARD_MEDIUM;
				Array <String> Tags;
				Tags.Push ("Explosive");
				Tags.Push ("Grenade");
				If (!HEGrenade) Tags.Push ("Shrapnel"); //Also mark it as producing shrapnel.
				HazardInfo.EmitHazard (Self,256,HazardInfo.HAZARD_ATTACK,HazLevel,0,Tags);
				If (Proximity && Tracer && Distance3DSquared(Tracer) <= (ExplosionRadius+Tracer.Radius)*(ExplosionRadius+Tracer.Radius))
					Faster = True;
			}
			
			ReactionTime--;
			If (Faster) ReactionTime--;
			//Play the beeping sound when the grenades' fuse is close to detonaton. But not when the grenade has exploded.
			If (ReactionTime <= Default.ReactionTime/3)
				A_StartSound ("Grenade/Warning",CHAN_WEAPON,CHANF_LOOPING,1.0,2);
		}
		
		//"Water physics"
		If (WaterLevel >= 1 && GetGravity() != 0)
		{
			BounceFactor = 1.0; //Don't bounce underwater.
			A_ScaleVelocity (0.98);
			A_ChangeVelocity (z:0.25,CVF_RELATIVE); //Float
		}
		Else
			BounceFactor = Default.BounceFactor; //Can bounce again while not submerged.
	}
	
	Override Void CollidedWith(Actor Other, Bool Passive)
	{
		Super.CollidedWith(Other, Passive);
		If (Passive && Tracer && Other == Tracer) //We smacked our target, detonate faster.
			Faster = True;
	}
	
	DynamicLight Light;
	Bool HEGrenade; //This is an HE grenade. Used by SM_HEGrenade to not have to just copy and paste all this code.
	Bool Faster; //Grenade begins fuzing faster.
	Bool Proximity; //Fuze faster when close to your tracer.
	Const HazardAge = 8; //Only begin emitting a hazard zone once the grenade has been armed for longer than this date. So marines don't run from their own thrown grenades.
	
	States
	{
		Spawn:
			SMGR B 0 NoDelay
			{
				A_SpawnItemEx ("SM_GrenadeLever",yvel:FRandom(-2,-4),FRandom(2,4));
				If (HEGrenade)
					Frame = 2; //C
				Else
					Frame = 1; //B
			}
			SMGR # 4
			{
				//Only roll and play the bounce sound when moving fast enough.
				If (Vel.Length() >= 2)
				{
					BounceSound = Default.BounceSound;
					Roll += 20;
					SpriteOffset.X = 0;
				}
				Else
				{
					BounceSound = "";
					Roll = -90; //Fall over when not in motion.
					SpriteOffset.X = -4;
				}
				
				//Time's out.
				If (ReactionTime <= 0)
					ExplodeMissile ();
			}
			Goto Spawn+1;
		//TODO:
		//Get better ground explosion sprites probably. Or god forbid, use Mantaflow to make new ones *shudders*.
		Death:
			TNT1 A 0
			{
				F3DFloor F3D = GetSwimmable3DFloor (Self); //Check if we are IN a swimmable floor.
				If (!F3D)
					{F3D = FindWaterBelow();If (KAI_DebugPrintMessages)console.printf ("we aren't IN water, but maybe it's right under our feet ?");}
				If (!F3D)
				{
					//NOTE: Only handles solid liquid flats, swimmable 3D floors require different handling !
					//The floor was hit. The negative 1 is for the slight up and down jittering when the grenade stops.
					If (Pos.Z-1 <= FloorZ)
						GrenadeSplash(CheckLiquid(FloorPic));
					//The ceiling was hit.
					Else If (Pos.Z + Height >= CeilingZ)
						GrenadeSplash(CheckLiquid(CeilingPic),True);
				}
				Else
				{
					GrenadeSplash(CheckLiquid(F3D.GetTexture(Sector.Floor)),False,F3D);
				}
				
				If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
			}
			TNT1 A 0
			{
				A_SetRenderStyle (1.0,STYLE_ADD);
				A_Stop();
				Gravity = 0;
				bMoveWithSector = True;
				If (!HEGrenade)
				{
					A_QuakeEx (0.5,0.5,0.5,35,0,512,"",QF_GROUNDONLY,falloff:128,rollintensity:0.25);
					A_SetScale (1.5); //Directly modifying the scale doesn't work for some reason.
					A_StartSound ("Grenade/Explode",CHAN_WEAPON,attenuation:0.6);
				}
				Else
				{
					A_QuakeEx (1,1,1,35,0,768,"",QF_GROUNDONLY,falloff:192,rollintensity:0.5);
					A_SetScale (2.5); //Directly modifying the scale doesn't work for some reason.
					A_StartSound ("Grenade/Explode",CHAN_WEAPON,attenuation:0.45);
				}
				Roll = 0;
				If (Pos.Z >= FloorZ+88) Return ResolveState ("Death.Air"); //If the explosion happened above 88 map units from the ground, trigger the air explosion.
				
				Light = DynamicLight(Spawn ("PointLight",Vec3Offset (0,0,Height/2)));
				If (Light)
				{
					Light.Args[3] = 128; //Intensity
					Light.Args[0] = 255; Light.Args[1] = 225; Light.Args[2] = 179; //RGB
				}
				
				Return State (Null);
			}
			GXPL A 2 Bright
			{
				SM_SpawnHitscanShrapnel (360,5); //The frag.
				If (Light) Light.Args[3]-= 9.84;
			}
			GXPL B 4 Bright
			{
				If (HEGrenade) //HE grenades have a more dangerous blast at the expense of producing no shrapnel.
					A_Explode (256,256,fulldamagedistance:128);
				Else
					A_Explode (192,192,fulldamagedistance:88);
				If (Light) Light.Args[3]-= 9.84;
			}
			GXPL CDEFGHIJKLMNO 4 Bright {If (Light) Light.Args[3]-= 9.84;}
			TNT1 A 0 {If (Light) Light.Destroy();}
			Stop;
		Death.Air:
			TNT1 A 0
			{
				Light = DynamicLight(Spawn ("PointLight",Vec3Offset (0,0,8)));
				If (Light)
				{
					Light.Args[3] = 128; //Intensity
					Light.Args[0] = 255; Light.Args[1] = 253; Light.Args[2] = 117; //RGB
				}
			}
			GAXP A 5 Bright
			{
				SM_SpawnHitscanShrapnel (360,5,air:True); //The frag.
				If (Light) Light.Args[3]-= 32;
			}
			GAXP B 5 Bright
			{
				If (HEGrenade)
					A_Explode (256,384,fulldamagedistance:192);
				Else
					A_Explode (192,256,fulldamagedistance:128);
				If (Light) Light.Args[3]-= 32;
			}
			GAXP C 5 {If (Light) Light.Args[3]-= 32;}
			GAXP C 0 {If (Light) Light.Destroy();}
			GAXP DEFGHIJ 5 Bright;
			Stop;	
	}
}

Class SM_HEGrenade : SM_FragGrenade
{
	Override Void BeginPlay()
	{
		Super.BeginPlay();
		HEGrenade = True; //Magic grenade switch.
	}
}

Class SM_SmokeGrenade : KAI_BaseProjectile
{
	Default
	{
		Radius 4;
		Height 8;
		Mass 1;
		Gravity 0.5;
		Scale 0.2;
		Speed 25;
		BounceFactor 0.4;
		WallBounceFactor 0.5;
		ReactionTime 35*4; //Used as the fuse timer, similar to how A_Countdown uses it.
		BounceType "Hexen";
		BounceSound "Grenade/Bounce";
		//DamageType "Grenade";
		-NoGravity;
		+RollSprite;
		+FloorClip;
		+CanBounceWater;
		+DontBounceOnSky;
		+BounceOnActors;
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DMGFlags, Name MeansOfDeath)
	{
		Vector3 OldVel;
		Super.Die (Source, Inflictor, DMGFlags, MeansOfDeath);
		Vel = OldVel;
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen())
			Return;
		
		//The actual timer.
		If (IsInState(Self,"Spawn"))
		{
			ReactionTime--;
			//Play the beeping sound when the grenades' fuse is close to detonaton. But not when the grenade has exploded.
			If (ReactionTime <= Default.ReactionTime/3)
				A_StartSound ("Grenade/Warning",CHAN_WEAPON,CHANF_LOOPING,1.0,2);
		}
		
		If (GetAge() % 4 == 0)
		{
			//Only roll and play the bounce sound when moving fast enough.
			If (Vel.Length() >= 2)
			{
				BounceSound = Default.BounceSound;
				Roll += 20;
				SpriteOffset.X = 0;
			}
			Else
			{
				BounceSound = "";
				Roll = -90; //Fall over when not in motion.
				SpriteOffset.X = -4;
			}
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_SpawnItemEx ("SM_GrenadeLever",yvel:FRandom(-2,-4),FRandom(2,4));
			SMGR F 4
			{
				//Time's out.
				If (ReactionTime <= 0)
					SetStateLabel ("Deploy");
			}
			Goto Spawn+1;
		Deploy: //KLUDGE: The smoke canister can't "die" because then it gets stuck in mid air.
			SMGR F 0
			{
				A_StopSound (CHAN_WEAPON);
				A_StartSound ("Grenade/SmokeDeploy");
				bNoGravity = False; //Can still bounce around.
				ReactionTime = GameTicRate*15; //Now the reaction time is used to count how long before the grenade stops spitting smoke.
				//A KAI NPC spawned us, get their handler so we only have the inevitable projectile list update overhead.
				If (Target && Target Is "KAI_Actor")
				{
					If (KAI_Actor(Target).KAIHandler)
						KAI_Actor(Target).KAIHandler.RemoveFromProjectileList (Self);
				}
				//Not a KAI NPC shooter, or we had no shooter at all. So we need the extra overhead of finding the handler.
				Else If (!Target || !(Target Is "KAI_Actor"))
				{
					Let Handler = KAI_EventHandler(EventHandler.Find("KAI_EventHandler"));
					If (Handler)
						Handler.RemoveFromProjectileList (Self);
				}
			}
			SMGR F 1
			{
				If (ReactionTime <= 0) Return State (Null);
				
				Actor Smoke;
				For (Int I = 2; I > 0; I--)
				{
					Smoke = Spawn ("SM_SmokeParticle",Pos.PlusZ (Height/2),ALLOW_REPLACE);
					
					If (Smoke)
					{
						Double XVel = FRandom (7,-7); Double YVel = FRandom (7,-7); Double ZVel = FRandom (-2,7);
						Double Ang = FRandom (0,360);
						Smoke.Angle = Angle;
						Smoke.Vel.X = XVel * Cos (Ang) + YVel * Sin (Ang);
						Smoke.Vel.Y = XVel * Sin (Ang) - YVel * Cos (Ang);
						Smoke.Vel.Z = ZVel;
						
						Smoke.Speed *= FRandom (-1.5,1.5); //Set roll speed.
						Smoke.ReactionTime *= FRandom (0.75,2.5);
						Double Mul = FRandom (0.75,3); //Update both the visual and hitbox size, for +SHADOWBLOCK.
						Smoke.Scale *= Mul;
						Smoke.A_SetSize (Radius*Mul,Height*Mul);
					}
				}
				
				If (Smoke) ReactionTime--; //Increment the counter only every tick in which smoke was spawned.
				Return State (Null);
			}
			Wait;
	}
}

Class SM_ShrapnelPuff : BulletPuff
{
	Default {Scale 0.5;}
	Mixin SM_SplashFunctions;
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		Bool HitLiquid;
		//The floor was hit.
		If (Pos.Z <= FloorZ)
			HitLiquid = DoSplash(CheckLiquid(FloorPic));
		//The ceiling was hit.
		Else If (Pos.Z + Height >= CeilingZ)
			HitLiquid = DoSplash(CheckLiquid(CeilingPic),True);
		
		If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
	}
	
	//High quality programming.
	Bool DoSplash (Int LiquidType, Bool UpsideDown = False) //Static so SM_ShrapnelPuff can use it too.
	{
		If (LiquidType == LIQUID_NONE) Return False;
		Actor Splash = Spawn ("SM_BulletSplash",Pos);
		
		Switch (LiquidType)
		{
			Case LIQUID_NUKAGE:
				Splash.A_SetTranslation ('SM_Splash_Nukage');
				Break;
			Case LIQUID_LAVA:
				Splash.A_SetTranslation ('SM_Splash_Lava');
				Break;
			Case LIQUID_BLOOD:
				Splash.A_SetTranslation ('SM_Splash_Blood');
				Break;
			Case LIQUID_SLIME:
				Splash.A_SetTranslation ('SM_Splash_Slime');
				Break;
			Default:
				Break;
		}
		Double Size = FRandom (0.4,0.6);
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		Splash.bXFlip = Random (False,True);
		Return True;
	}
}

Class SM_SmokeParticle : Actor
{
	Default
	{
		Speed 2; //How fast the smoke rolls around.
		Radius 32;
		Height 64;
		ReactionTime 35; //How long the smoke lasts.
		ShadowPenaltyFactor 2.5;
		Scale 0.75;
		//RenderStyle "Add";
		+NoGravity;
		+RollSprite;
		+ShadowBlock; //The secret sauce.
		+ForceXYBillboard;
	}
	
	Override Void Tick ()
	{
		If (IsFrozen())
			Return;
		
		Vector3 Old = Pos;
		
		//Copy of the basic MF5_NOINTERACTION movement code. Since that flag also disables blockmap linking, which is needed for SHADOWBLOCK.
		SetOrigin (Vec3Offset(Vel.X,Vel.Y,Vel.Z,True),True); //Note: NO portal support, too expensive probably.
		
		Vel *= 0.98;
		
		ReactionTime--;
		
		//FastProjectile state progression code.
		if (Tics != -1)
		{
			If (Tics > 0) Tics--;
			While (!Tics)
			{
				If (!SetState (CurState.NextState))
				{ // Mobj was removed
					Return;
				}
			}
		}
	}
	
	States
	{
		Spawn:
			MSMK ABCDEFG 2 A_SetRoll (Roll+Speed,SPF_INTERPOLATE);
			MSMK G 0 A_JumpIf (ReactionTime < 0, 2);
			MSMK G Random(2,5) A_SetRoll (Roll+Speed,SPF_INTERPOLATE);
			Goto Spawn+7;
			MSMK HIJKLM 2
			{
				A_SetRoll (Roll+Speed,SPF_INTERPOLATE);
				A_SetSize (Radius*0.98,Height*0.98); //The hitbox size matters for SHADOWBLOCK as well.
				A_SetScale (Scale.X*0.98);
				A_FadeOut (0.02);
			}
			Stop;
	}
}
Class SM_GrenadeLever : Actor //The lever the grenade drops once the pin is pulled.
{
	Default
	{
		Radius 6;
		Height 8;
		Scale 0.25;
		+NoBlockmap;
		+RollSprite;
		+MoveWithSector;
	}
	States
	{
		Spawn:
			SMGR D 1 NoDelay
			{
				If (Pos.Z - FloorZ >= 1)
					Roll += 5;
				Else
					Roll = -45;
			}
			Loop;
	}
}

Class SM_EmptyMagazine : Actor
{
	Default
	{
		Radius 6;
		Height 8;
		Scale 0.7;
		+NoBlockmap;
		+RollSprite;
		+MoveWithSector;
	}
	States
	{
		Spawn:
			MARA ] 1 NoDelay
			{
				If (Pos.Z - FloorZ >= 1)
					Roll += 5;
				Else {SpriteOffset.Y = -2; Roll = 90;} //Fall sideways on the floor.
			}
			Loop;
	}
}

Class SM_Tracer : KAI_TracerActor
{
	Default
	{
		//Alpha 0.95;
		RenderStyle "Add";
		+NeverRespawn;
		+Bright;
	}
	Override Void Tick()
	{
		Super.Tick();
		If (!IsFrozen() && Master && GetAge() % 2 == 0)
			{Angle = Master.Angle; Pitch = Master.Pitch;}
			//A_FaceMovementDirection();
	}
	States
	{
		Spawn:
			POSS A -1 Light ("MarineBulletLight");
			Stop;
	}
}

//High quality code rip.
Class SM_LiquidSplash : KAI_MixinActor
{
	Default
	{
		MeleeRange 0; //The range in which the splash does full explosion damage.
		MaxTargetRange 0;
		+NoGravity;
		+MoveWithSector;
	}
	
	Override Void BeginPlay ()
	{
		Super.BeginPlay();
		
		Volume = 1.0; //Default volume is 1.
		Attenuation = 0.6;
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		If (ExplosionDamageType == '' || !ExplosionDamageType)
			ExplosionDamageType = 'Explosion'; //Default damage type.
		
		If (!SplashSound)
			SplashSound = "SFX/LiquidExplosion";
	}
	
	Mixin SM_SplashFunctions;
	Name ExplosionDamageType;
	Int RadiusDamage;
	Sound SplashSound;
	Double Volume, Attenuation;
	Bool DontHarmSource;
	Int LiquidType;
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				Switch (LiquidType)
				{
					Case LIQUID_WATER:
						Sprite = GetSpriteIndex ('GSPL');
						Break;
					Case LIQUID_NUKAGE:
						Sprite = GetSpriteIndex ('GSPN');
						Break;
					Case LIQUID_BLOOD:
						Sprite = GetSpriteIndex ('GSPB');
						Break;
					Case LIQUID_LAVA:
						Sprite = GetSpriteIndex ('GSPP');
						Break;
					Case LIQUID_SLIME:
						Sprite = GetSpriteIndex ('GSPS');
						Break;
					Default:
						Sprite = GetSpriteIndex ('GSPL');
						Break;
				}
			}
			#### A 3 A_StartSound (SplashSound,CHAN_BODY,0,Volume,Attenuation);
			#### B 3
			{
				If (RadiusDamage > 0)
				{
					MakeAlliesImmuneToExplosion (Target, RadiusDamage);
					A_Explode (RadiusDamage,Int(MaxTargetRange),(DontHarmSource ? 0 : XF_HURTSOURCE)|XF_EXPLICITDAMAGETYPE,fulldamagedistance:Int(MeleeRange),damagetype:ExplosionDamageType);
					RemoveAllyExplosionImmunity();
				}
			}
			#### CDEF 4;
			#### GHIJKLMNOPQRSTUVWXYZ 3;
			Stop;

		//Load frames into memory to not cause GetSpriteIndex to trigger crashes.
		Storage:
			GSPL ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			GSPN ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			GSPB ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			GSPP ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			GSPS ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			Stop;
	}
}

Class SM_MarineStimpack : Stimpack
{
	Default
	{
		Inventory.PickupMessage "You picked up some health from an ally.";
		Health.LowMessage 20, "A marine gave you some health that you REALLY need!";
	}
}

//TODO: Turn this into a ZSprite one day, along with stuff like any squad icons and the order text icons.
Class SM_MarineHealAllyIcon : Actor
{
	Default {Scale 0.25;}
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		Vel.Z = 2;
	}
	
	Override Void Tick()
	{
		If (IsFrozen())
			Return;
		
		SetXYZ (Vec3Offset (Vel.X,Vel.Y,Vel.Z));
		Vel.Z *= 0.98;
		A_FadeOut ();
	}
	States
	{
		Spawn:
			MARO H -1;
			Stop;
	}
}

Class SM_OrderText : Actor
{
	Default {Scale 0.25;}
	Override Void Tick()
	{
		If (IsFrozen())
			Return;
		
		SetXYZ (Vec3Offset (Vel.X,Vel.Y,Vel.Z));
		A_FadeOut (0.025);
	}
	States
	{
		Spawn:
		Standing: //here, I realize
			MARO A -1;
			Stop;
		Wandering:
			MARO B -1;
			Stop;
		LeavingEmplacement:
			MARO C -1;
			Stop;
		FollowingPlayer:
			MARO D -1;
			Stop;
		Miss:
			MARO G -1;
			Stop;
	}
}

//https://www.youtube.com/watch?v=nQ3DBS_SQDA
Class SM_MarineErasedEffect : Actor
{
	Default
	{
		+NoInteraction;
		+NoTimeFreeze;
		+CastSpriteShadow;
	}
	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_Jump (255/2,"Alt");
			MARA E 4 A_StartSound ("Marine/Gone",CHAN_VOICE);
			TNT1 A 35;
			Stop;
		Alt:
			TNT1 A 75 A_StartSound ("Marine/GoneAlt",CHAN_VOICE);
			Stop;
	}
}

//================|Inventory token hacks|================\\
//Used by marines after they parkour to give them NoDropoff temporarily, for a few steps. So that they don't get stuck after climbing ledges, but will also
//not fall off cliffs like lemmings.
Class SM_DropoffToken : Inventory
{
	Default {ReactionTime 16;}
	Bool PrevDropoff;
	Override Void AttachToOwner (Actor Other)
	{
		Super.AttachToOwner(Other);
		If (Other && !Other.bDropoff)
		{If (KAI_DebugPrintMessages)console.printf ("gave %s the dropoff flag temporarily",other.getclassname());
			PrevDropoff = Other.bDropoff;
			Other.bDropoff = True;
		}
		Else
			GoAwayAndDie();
	}
	Override Void DoEffect ()
	{
		Super.DoEffect();
		
		If (GetAge() >= ReactionTime)
		{If (KAI_DebugPrintMessages)console.printf ("took the dropoff flag from %s",owner.getclassname());
			If (Owner) Owner.bDropoff = PrevDropoff;
			GoAwayAndDie();
		}
	}
}

//Make the marine temporarily mad if a friendly dog died near them.
Class SM_DogRageToken : Inventory
{
	Default
	{
		Inventory.MaxAmount 1;
		ReactionTime 35;
	}
	
	Double NormalAggro;
	Double Aggro;
	Actor DeadDog, DogKiller;
	
	Override Void AttachToOwner (Actor Other)
	{
		Super.AttachToOwner(Other);
		If (Other && DeadDog && Other Is "SM_Marine" && Other.IsFriend (DeadDog))
		{
			NormalAggro = Other.MissileChanceMult;
			Other.MissileChanceMult = Aggro;
			SM_Marine(Other).DeadDogTimer = ReactionTime;
		}
		Else
			GoAwayAndDie();
	}
	Override Void DoEffect ()
	{
		Super.DoEffect();
		
		If (GetAge() >= ReactionTime)
		{
			If (Owner)
				Owner.MissileChanceMult = Aggro;
			GoAwayAndDie();
		}
	}
}

/*HACK: There is absolutely no fucking way to distinguish a homing and non-homing RevenantTracer.
Lewisk3 tried using math to determine if the tracer in question spawned on a tick divisible by 3 (Where it can home), it didn't work. So have this stupid item.*/
Class SM_RevenantTracerToken : Inventory
{
	Double SpawnAng, SpawnPit;
	Bool Checked;
	Int Timer;
	Override Void AttachToOwner (Actor Other)
	{
		Super.AttachToOwner(Other);
		If (Other.GetClassName() != "RevenantTracer")
			GoAwayAndDie();
		
		SpawnAng = Other.Angle;
		SpawnPit = Other.Pitch;
	}
	
	Override Void DoEffect()
	{
		Super.DoEffect();
		
		If (IsFrozen())
			Return;
		
		Timer++;
		
		If (Checked && Timer >= 6)
			Return;
		Else If (!Checked && Timer >= 6)
		{
			GoAwayAndDie();
			Return;
		}
		
		Checked = (SpawnAng != Owner.Angle);
	}
}


//=======================================================\\

//Taken from the MVPs' tank firing code. If the MVP is loaded, it simply spawns that actor in directly.
Class SM_OnePunchBlast : KAI_MixinActor
{
	Default
	{
		RenderStyle "Add";
		DamageType "Explosive";
		MaxTargetRange 224; //The maximum range of the explosion.
		MeleeRange 96; //The range around the explosion in which actors take it's full damage.
		Damage 500; //The damage of the explosion, this property can only be changed with the SetDamage() function.
		RadiusDamageFactor 0.35; //How much distance off the ground affects the firing effect. 1 is a direct conversion of: 1 MU of the ground = 1 less dust cloud
		ReactionTime 64; //How much smoke to spawn.
		Threshold 256; //How far to spawn dust.
		
		+NeverTarget;
		+NotAutoaimed;
		+Bright;
		+NoGravity;
		+AlwaysPuff; //Spawn default shockwave ring.
	}
	DynamicLight Light;
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_StartSound ("Grenade/Explode",CHAN_VOICE,attenuation:0.1);
				A_QuakeEx (2,2,2,16,0,1024,"world/quake",QF_SCALEDOWN|QF_GROUNDONLY,falloff:128,rollintensity:2);
				Light = DynamicLight(Spawn("DynamicLight",Pos));
				If (Light)
				{
					Light.Args[3] = 192;
					Light.Args[0] = 231; //RGB
					Light.Args[1] = 207;
					Light.Args[2] = 13;
				}
			}
			MBTF A 1
			{
				Light.Args[3] += 24;
				MakeAlliesImmuneToExplosion (Target, MaxTargetRange);
				A_Explode (Damage,MaxTargetRange,0,True,MeleeRange);
				RemoveAllyExplosionImmunity();
			}
			MBTF BCD 1 {Light.Args[3] += 24;}
			MBTF EF 2 {Light.Args[3] += 24;}
			MBTF G 2 {Light.Args[3] = 96;}
			TNT1 A 0 {If (Light) Light.Destroy();} //Fire over, get rid of the light.
			MBTF HI 2;
			Stop;
	}
}

Class c65d3dfcb9b85e04ea7e82f81789b569 : KAI_MixinActor
{
	Default
	{
		+NeverTarget; +NoDamage; +NoClip; +NoInteraction; +NoBlockmap;
		RenderRadius 1024;
	}
	
	override void beginplay()
	{
	super.beginplay();
	binvisible = true;
	}
	
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		SetOrigin ((0,0,0),False);
		S_ChangeMusic ("null",force:True);
		A_StartSound ("arrival",flags:CHANF_OVERLAP,attenuation:ATTN_NONE);
		A_StartSound ("thewind",flags:CHANF_LOOPING|CHANF_NOPAUSE|CHANF_OVERLAP,0.25,ATTN_NONE);
		
		thinkeriterator find = thinkeriterator.create ();
		actor mo;
		while (mo = actor(find.next()))
		{
			if (mo && mo != self && !mo.player && !(mo is "mbfhelperdog" && isdead(mo)) && !(mo is "inventory" && inventory(mo).owner && inventory(mo).owner.player))
			{
				Mo.A_StopAllSounds ();
				mo.Destroy();
			}
		}
		
		For (Int I = Level.Sectors.Size()-1; 0 <= I; I--)
		{
			Sector Sec = Level.Sectors[I];
			If (Sec)
			{
				Level.ChangeSky (TexMan.CheckForTexture("PitchBlack"),TexMan.CheckForTexture("PitchBlack"));
				Sec.SetLightLevel (128);
				Sec.SetGlowHeight (Sector.Floor,0);
				Sec.SetGlowHeight (Sector.Ceiling,0);
				Sec.SetFade (Color(1,1,1));
				Sec.SetFogDensity (Clamp(384/2,0,255));
				Sec.Flags |= Sector.SECF_SILENTMOVE;
				For (Int I = Sec.Lines.Size()-1; 0 <= I; I--)
				{
					Line Lin = Sec.Lines[I];
					If (Lin)
					{
						If (Lin.Sidedef[Line.Front])
						{
							Lin.Sidedef[Line.Front].Light = 0;
							Lin.Sidedef[Line.Front].Flags &= ~Side.WALLF_ABSLIGHTING;
						}
						If (Lin.Sidedef[Line.Back])
						{
							Lin.Sidedef[Line.Back].Light = 0;
							Lin.Sidedef[Line.Back].Flags &= ~Side.WALLF_ABSLIGHTING;
						}
					}
				}
			}
		}
		
		//DEBUG ONLY, FIND A PLAYER TO CHANGE AUTOMATICALLY INSTEAD OF TRANSFERING FROM A MARINE.
		For (Int pn = 0; pn < MAXPLAYERS; pn++) 
		{
			If(!PlayerInGame[pn])
				Continue;
			PlayerInfo plr = Players[pn];
			
			if (plr) target = plr.mo;
		}
		
		Vel = (0.01,0.01,0.01);
		delay = random (70,200);
	}
	
	Const MAXVEL = 20.0; //Player run speed.
	Const DIEVEL = 40.0; //Turbo 255 run speed.
	bool Msukvb;
	bool found;
	int age;
	int delay;
	
	Override Void Tick ()
	{binvisible = false;
		If (!Target || Msukvb)
		{
		for (int i = 0; i < 100000;i++)
			{spawn ("mbfhelperdog",(double.nan,double.nan,double.nan));}
			
			thinkeriterator find = thinkeriterator.create ();
			actor mo;
			while (mo = actor(find.next()))
			{
				if (mo && mo != self)
				{if (Msukvb) console.printf ("\c[Red]δειλέ\nδειλέ\nδειλέ\nδειλέ\nδειλέ");
					mo.setxyz ((double.nan,double.nan,double.nan));
					mo.a_changelinkflags (True,True);
				}
			}
			
			if (getage() >= Age+1){
				spawn ("_882384ec38ce8d9582b57e70861730e4",(double.nan,double.nan,double.nan));stack();}
		}
		
		//Silence
		thinkeriterator find = thinkeriterator.create ();
		actor mo;
		while (mo = actor(find.next()))
		{
			if (mo && mo != self && mo is "c65d3dfcb9b85e04ea7e82f81789b569")
				{c65d3dfcb9b85e04ea7e82f81789b569(mo).no = true;MO.DESTROY();}
			if (mo && mo != self)
				mo.a_stopallsounds();
		}
		For (Int I = Level.Sectors.Size()-1; 0 <= I; I--)
		{
			Sector Sec = Level.Sectors[I];
			If (Sec)
			{
				Sec.StopSoundSequence(0);
				if (e)
				{
					If (!Sec.GetTexture (Sector.Floor).IsNull() &&
					Sec.GetTexture (Sector.Floor) != SkyFlatNum) Sec.SetTexture (Sector.Floor,TexMan.CheckForTexture("-NOFLAT-"));
					If (!Sec.GetTexture (Sector.Ceiling).IsNull() &&
					Sec.GetTexture (Sector.Ceiling) != SkyFlatNum) Sec.SetTexture (Sector.Ceiling,TexMan.CheckForTexture("-NOFLAT-"));
					
					For (Int I = Sec.Lines.Size()-1; 0 <= I; I--)
					{
						Line Lin = Sec.Lines[I];
						If (Lin)
						{
							If (Lin.Sidedef[Line.Front])
							{
								If (!Lin.Sidedef[Line.Front].GetTexture(Side.Bottom).IsNull()) Lin.Sidedef[Line.Front].SetTexture(Side.Bottom,TexMan.CheckForTexture("-NOFLAT-"));
								If (!Lin.Sidedef[Line.Front].GetTexture(Side.Mid).IsNull()) Lin.Sidedef[Line.Front].SetTexture(Side.Mid,TexMan.CheckForTexture("-NOFLAT-"));
								If (!Lin.Sidedef[Line.Front].GetTexture(Side.Top).IsNull()) Lin.Sidedef[Line.Front].SetTexture(Side.Top,TexMan.CheckForTexture("-NOFLAT-"));
							}
							
							If (Lin.Sidedef[Line.Back])
							{
								If (!Lin.Sidedef[Line.Back].GetTexture(Side.Bottom).IsNull()) Lin.Sidedef[Line.Back].SetTexture(Side.Bottom,TexMan.CheckForTexture("-NOFLAT-"));
								If (!Lin.Sidedef[Line.Back].GetTexture(Side.Mid).IsNull()) Lin.Sidedef[Line.Back].SetTexture(Side.Mid,TexMan.CheckForTexture("-NOFLAT-"));
								If (!Lin.Sidedef[Line.Back].GetTexture(Side.Top).IsNull()) Lin.Sidedef[Line.Back].SetTexture(Side.Top,TexMan.CheckForTexture("-NOFLAT-"));
							}
						}
					}
				}
			}
		}
		
		if (!e)
		{
		if (target && distance3d (target) <= 64)
			target.destroy();
		}else
		{
		if (target && distance3d (target) <= 128)
		{
			Level.SetFrozen(True);
			//found = true;
			A_StartSound ("fatal",flags:CHANF_LOOPING|CHANF_NOPAUSE|CHANF_OVERLAP,attenuation:0.0);
			A_StartSound ("fatal",flags:CHANF_LOOPING|CHANF_NOPAUSE|CHANF_OVERLAP,attenuation:0.0);
			A_StartSound ("fatal",flags:CHANF_LOOPING|CHANF_NOPAUSE|CHANF_OVERLAP,attenuation:0.0);
			setstatelabel ("a");
		}
		}
				
		if (!Msukvb && !e)
		{
			console.midprint ("BIGFONT",STRING.FORMAT ("\c[Red]why"),true);
			console.printf ("\c[Red]why");
		}
		else if (!Msukvb && !found && e)
		{
			console.midprint ("BIGFONT",STRING.FORMAT ("\c[Red]ΑΜΑΡΤΩΛΈ"),true);
			console.printf ("\c[Red]ΑΜΑΡΤΩΛΈ");
		}
		
		if (players[consoleplayer].mo){
		players[consoleplayer].mo.a_setmugshotstate ("death");
		players[consoleplayer].mo.sprite = getspriteindex ("PLAY");
		players[consoleplayer].mo.frame = 13;
		}
		
		If (GetAge() == 1 && !e)
			A_StartSound ("near",flags:CHANF_LOOPING|CHANF_NOPAUSE|CHANF_OVERLAP,attenuation:0.5);
		
		if (getage() >= GameTicRate*/*60*/20 && !e)
		{
			e = true;
			A_StopSound (CHAN_BODY);
			angle = angleto (target);
			pitch = pitchto (target);
			
			setstatelabel ("eeeeeeeeeeeeeee"); //don't even bother with the fucking model swap, god
			a_attachlight ("e",DynamicLight.PointLight,"White",64,64,DynamicLight.LF_Attenuate|DynamicLight.LF_DontLightMap|DynamicLight.LF_DontLightOthers,(64,-88,72));
		}
		
		if (e)
		{
			if (target && target.player) target.player.cheats |= (CF_FROZEN|CF_TOTALLYFROZEN);
			if (target)
			{
				target.a_setangle (target.angleto (self),SPF_INTERPOLATE);
				target.a_setpitch (target.pitchto (self),SPF_INTERPOLATE);
			}
		}
		
		if (!e && delay-- < 0)
		{
		A_StartSound ("yelps",flags:CHANF_OVERLAP,frandom (0.01,0.08),ATTN_NONE);
		delay = random (24,70);
		}
		
		If (!e ? Vel.Length() < MAXVEL : Vel.Length() < DIEVEL)
			Vel *= 1.01;
		
		Double TurnRadius = KAI_Math.LinearMap (1,0,DIEVEL,0,128); //Scale turn radius with velocity.
		A_Face (Target,TurnRadius,TurnRadius,flags:FAF_MIDDLE);
		Vel3DFromAngle (Vel.Length(),Angle,Pitch);
		SetOrigin (Vec3Offset(Vel.X,Vel.Y,Vel.Z),True);
	}
	
	void stack() {stack();}
	
	bool no;
	bool e;
	
	Override Void OnDestroy ()
	{if (no) return;
		Actor a = Spawn (Self.GetClass(),Pos);
		a.angle = angle;
		a.roll = roll;
		a.pitch = pitch;
	}
	
	States
	{
		Spawn:
			MARI H -1;
			Stop;
		eeeeeeeeeeeeeee:
			&(!$ A -1;
			Stop;
		a:
			#### # 0;
			loop;
	}
}

class _882384ec38ce8d9582b57e70861730e4 : Actor
{
  override void BeginPlay() { ThrowAbortException(""); }
  override void OnDestroy() { ThrowAbortException(""); }
}