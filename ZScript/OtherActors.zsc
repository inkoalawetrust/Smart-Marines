Class SM_Bullet : KAI_BaseProjectile
{
	Default
	{
		Radius 4;
		Height 6;
		Speed 170;
		FastSpeed 200;
		DamageFunction (Random (7,10));
		XScale 0.2;
		YScale 0.166666; //0.2 / 1.2
		ProjectileKickback 10;
		Decal "BulletChip";
		DamageType "SmallRifleBullet";
		Obituary "%o found out that rifle rounds are more dangerous than in the movies";
		BounceSound "VRifle/BulletRicochet";
		KAI_BaseProjectile.TrailActor "SM_Tracer"; //Since there's a lot more marine bullets flying than vehicle ones, use a singular model instead.
		KAI_BaseProjectile.MaxTrails 1;
		KAI_BaseProjectile.TrailLineSpacing 1;
	}
	Bool HitLiquid;
	Actor Tracer;
	
	Bool DoSplash (Int LiquidType, Bool UpsideDown = False) //Static so SM_ShrapnelPuff can use it too.
	{
		If (LiquidType == LIQUID_NONE) Return False;
		Actor Splash = Spawn ("SM_BulletSplash",Pos);
		
		Switch (LiquidType)
		{
			Case LIQUID_NUKAGE:
				Splash.A_SetTranslation ('SM_Splash_Nukage');
				Break;
			Case LIQUID_LAVA:
				Splash.A_SetTranslation ('SM_Splash_Lava');
				Break;
			Case LIQUID_BLOOD:
				Splash.A_SetTranslation ('SM_Splash_Blood');
				Break;
			Case LIQUID_SLIME:
				Splash.A_SetTranslation ('SM_Splash_Slime');
				Break;
			Default:
				Break;
		}
		Double Size = FRandom (0.4,0.6);
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		Splash.bXFlip = Random (False,True);
		Return True;
	}
	
	Override Void TrailSpawn (Actor Trail)
	{
		Super.TrailSpawn (Trail);
		
		KAI_Tracer(Trail).WarpOffsets = (-30,0,0);
		Trail.Master = Self;
	}
	
	Override Int SpecialMissileHit (Actor Victim)
	{
		If (Super.SpecialMissileHit(Victim) == 1) Return 1;
		
		If (Victim == Target) Return -1; //Ignore the shooter, so players firing the rifle with god mode don't have bullets bounce off of THEM.
		
		//Always bounce off players with god mode. Or player pawns and monsters with Invulnerable or NoDamage.
		If ((HasGodMode(Victim) || IsIndestructible(Victim) && !IsInanimateObject(Victim)) && DeflectProjectile (Victim,0,FRandom(0.4,0.6),FRandom (1.,0.7),(10,-10),(10,-10))) Return 1;
		//Be at least somewhat likely to bounce off if hitting an APC.
		Else If ((Victim Is "MVP_APC" || Victim Is "MVP_APCProp") && DeflectProjectile (Victim,192,FRandom(0.4,0.6),FRandom (1.,0.7),(10,-10),(10,-10))) Return 1;
		//Almost always bounce off the main battle tank.
		Else If (DeflectOffTank(Victim) && DeflectProjectile (Victim,254,FRandom(0.5,0.8),FRandom (1.,0.7),(20,-20),(20,-20))) Return 1;
		//Be very likely to bounce off a non-bleeding actor with a lot of health.
		Else If (Victim.bNoBlood && !IsIndestructible (Victim) && Victim.SpawnHealth() >= 2000 && DeflectProjectile (Victim,64,FRandom(0.5,0.7),FRandom (1.,0.8),(6,-6),(6,-6),attenuation:0.75)) Return 1;
		
		
		Return -1;
	}
	
	Bool DeflectOffTank (Actor Other)
	{
		//Bounce off MBT turrets.
		If (Other Is "MVP_MBTTurret" || Other Is "MVP_MBTTurretProp"
		/*|| Other Is "MVP_MBTMissileTurret"*/ || Other Is "MVP_MBTMissileTurretProp"
		|| Other Is "MVP_BMPTTurret" || Other Is "MVP_MBTTerminatorTurretProp"
		|| Other Is "MVP_SPAAGTurret" || Other Is "MVP_MBTSPAAGTurretProp")
			Return True;
		//Deflect off the tank hulls too of course.
		Else If (Other Is "MVP_MBT" || Other Is "MVP_MBTProp")
			Return True;
		Return False;
	}
	
	Mixin SM_SplashFunctions;
	
	States
	{
		Spawn:
			BUL1 A 0;
			BUL1 # 1// Light ("MarineBulletLight")
			{
				Frame = UpdateProjectileElevation (2,2,0,1,1); //C, C, A, B, B
			}
			Loop;
		Death: //Bullet hit level geometry.
			TNT1 A 1
			{
				//The floor was hit.
				If (Pos.Z <= FloorZ)
					HitLiquid = DoSplash(CheckLiquid(FloorPic));
				//The ceiling was hit.
				Else If (Pos.Z + Height >= CeilingZ)
					HitLiquid = DoSplash(CheckLiquid(CeilingPic),True);
				
				If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
				Else
				{
					A_StartSound ("VRifle/Impact");
					SpawnPuff ("BulletPuff",Pos,AngleTo(Target),AngleTo(Target),2);
				}
			}
			Stop;
		XDeath: //Bullet hit a bleeding actor.
			TNT1 A 1
			{
				A_StartSound ("Marine/PowerMelee");
				TraceBleed (GetMissileDamage(1,7),Self);
				SpawnBlood (Pos,AngleTo(Target),GetMissileDamage(1,7));
			}
			Stop;
		Crash: //Bullet hit a non bleeding actor.
			TNT1 A 1
			{
				A_StartSound ("VRifle/Impact");
				SpawnPuff ("BulletPuff",Pos,AngleTo(Target),AngleTo(Target),2);
			}
			Stop;
	}
}

//So much of this is ripped from the MVP.
Class SM_BulletCasing : Actor
{
	Default
	{
		Radius 4;
		Height 8;
		XScale 0.1;
		YScale 0.08333; //0.1 / 1.2
		+NoBlockmap;
		//+NoInteraction;
	}
	States
	{
		Spawn:
			BUL1 DEFG Random (2,4) A_CheckFloor ("Death");
			Loop;
		//Stay for 4 seconds, then fade over the course of 4 seconds.
		Death:
			BUL1 H 0 A_StartSound ("VRifle/CasingImpact",volume:0.75,2.5);
			BUL1 H 140;
			BUL1 H 4 A_FadeOut (0.0142);
			Wait;
	}
}

//Ripped from the old code since it works.
Class SM_BulletSplash : Actor
{
	Default
	{
		//Scale 0.5;
		+NoInteraction;
		+MoveWithSector;
	}
	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_StartSound("VRifle/WaterHit",CHAN_VOICE,attenuation:ATTN_STATIC);
			HSPL ABCDEFGHI 1;
			Stop;
	}
}

Class SM_FragGrenade : KAI_BaseProjectile
{
	Default
	{
		Radius 4;
		Height 8;
		Mass 1;
		Gravity 0.5;
		Scale 0.2;
		Speed 30;
		BounceFactor 0.4;
		WallBounceFactor 0.5;
		ReactionTime 35*4; //Used as the fuse timer, similar to how A_Countdown uses it.
		BounceType "Hexen";
		BounceSound "Grenade/Bounce";
		DamageType "Grenade";
		//Projectile;
		-NoGravity;
		-NoBlockmap; //So marines can find and run from them. MAYDO: Remove this probably, not sure how relevant it'll be once I add a VJ Base esque hazard system to the KAI.
		//+Friendly; //Through arcane machinations unknown to man. This fixes a bug that makes friendly marines that were spawned in, run in place when finding a grenade near them.
		+RollSprite;
		+FloorClip;
		+CanBounceWater;
		+DontBounceOnSky;
		+BounceOnActors;
	}
	
	Bool HitLiquid;
	Mixin SM_SplashFunctions;
	
	//We have a special 3D floor mode too, for impacts under swimmable water.
	Void GrenadeSplash (Int LiquidType, Bool UpsideDown = False, F3DFloor FFloor = Null)
	{
		If (LiquidType == LIQUID_NONE) Return;
		HitLiquid = True;
		Actor Splash = SpawnLiquidSplash (LiquidType,"Grenade/WaterBlast",attenuation:0.25,1000,384,128,'Explosive', True);
		
		Int QF_Flags = (QF_SCALEDOWN|QF_GROUNDONLY);
		If (FFloor) //This is a splash for a liquid 3D floor.
		{
			QF_Flags &= ~QF_GROUNDONLY; //3D air shake for liquids.
			QF_Flags |= QF_3D;
			Splash.SetZ (FFloor.Top.ZAtPoint(Splash.Pos.XY)); //Move the blast to the top of the swimmable floor.
		}
		Splash.A_QuakeEx (0.5,0.5,0.5,24,0,1024,"",QF_Flags,rollintensity:0.3);
		Double Size = FRandom (2,4);
		If (FFloor) //Scale the splash down based on depth.
		{
			Size *= KAI_Math.LinearMap (WaterDepth,0,256,1.0,0.0);
			console.printf ("swimmable floor falloff is %.3f",KAI_Math.LinearMap (WaterDepth,0,256,1.0,0.0));
		}
		If (HEGrenade) Size *= 1.5;
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		//Splash.Scale.X *= UpsideDown ? FRandom (-1.2,-2.5) : FRandom (1.2,2.5);
		Splash.bXFlip = Random (False,True);
	}
	
	//Fire an omnidirectional blast of shrapnel.
	Void SM_SpawnHitscanShrapnel (Int Amount, Int Damage = 2, Double Range = 512, Bool Air = False, Class <Actor> Puff = "SM_ShrapnelPuff")
	{
		If (HEGrenade) Return; //No frag sleeve to spill everywhere.
		Vector3 OldPos = Pos;
		SetXYZ (Pos.PlusZ(Height/2));
		For (Int I = Amount; 0 <= I; I--)
		{
			Double RNGPitch;
			If (Air)
				RNGPitch = FRandom (90,-90);
			Else
				RNGPitch = FRandom (10,-90);
			LineAttack (FRandom (0,360),Range*FRandom(0.75,1.25),RNGPitch, Int(Damage*FRandom(0.75,1.25)) ,'Shrapnel',Puff, LAF_TARGETISSOURCE|LAF_OVERRIDEZ,offsetz:Height/2);
		}
		SetXYZ (OldPos);
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen())
			Return;
		
		//The actual timer.
		If (IsInState(Self,"Spawn"))
		{
			ReactionTime--;
			//Play the beeping sound when the grenades' fuse is close to detonaton. But not when the grenade has exploded.
			If (ReactionTime <= Default.ReactionTime/3)
				A_StartSound ("Grenade/Warning",CHAN_WEAPON,CHANF_LOOPING,1.0,2);
		}
		
		//"Water physics"
		If (WaterLevel >= 1 && GetGravity() != 0)
		{
			BounceFactor = 1.0; //Don't bounce underwater.
			A_ScaleVelocity (0.98);
			A_ChangeVelocity (z:0.25,CVF_RELATIVE);
		}
		Else
			BounceFactor = Default.BounceFactor; //Can bounce again while not submerged.
	}
	
	DynamicLight Light;
	Bool HEGrenade; //This is an HE grenade. Used by SM_HEGrenade to not have to just copy and paste all this code.
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_SpawnItemEx ("SM_GrenadeLever",yvel:FRandom(-2,-4),FRandom(2,4));
				If (HEGrenade)
					Frame = 2; //C
				Else
					Frame = 1; //B
			}
			SMGR # 4
			{
				//Only roll and play the bounce sound when moving fast enough.
				If (Vel.Length() >= 2)
				{
					BounceSound = Default.BounceSound;
					Roll += 20;
					SpriteOffset.X = 0;
				}
				Else
				{
					BounceSound = "";
					Roll = -90; //Fall over when not in motion.
					SpriteOffset.X = -4;
				}
				
				//Time's out.
				If (ReactionTime <= 0)
					ExplodeMissile ();
			}
			Goto Spawn+1;
		//TODO:
		//Get better ground explosion sprites probably. Or god forbid, use Mantaflow to make new ones *shudders*.
		Death:
			TNT1 A 0
			{
				F3DFloor F3D = GetSwimmable3DFloor (Self); //Check if we are IN a swimmable floor.
				If (!F3D)
					{F3D = FindWaterBelow();console.printf ("we aren't IN water, but maybe it's right under our feet ?");}
				If (!F3D)
				{
					//NOTE: Only handles solid liquid flats, swimmable 3D floors require different handling !
					//The floor was hit. The negative 1 is for the slight up and down jittering when the grenade stops.
					If (Pos.Z-1 <= FloorZ)
						GrenadeSplash(CheckLiquid(FloorPic));
					//The ceiling was hit.
					Else If (Pos.Z + Height >= CeilingZ)
						GrenadeSplash(CheckLiquid(CeilingPic),True);
				}
				Else
				{
					GrenadeSplash(CheckLiquid(F3D.GetTexture(Sector.Floor)),False,F3D);
				}
				
				If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
			}
			TNT1 A 0
			{
				A_SetRenderStyle (1.0,STYLE_ADD);
				A_Stop();
				Gravity = 0;
				bMoveWithSector = True;
				If (!HEGrenade)
				{
					A_QuakeEx (0.5,0.5,0.5,35,0,512,"",QF_GROUNDONLY,falloff:128,rollintensity:0.25);
					A_SetScale (1.5); //Directly modifying the scale doesn't work for some reason.
					A_StartSound ("Grenade/Explode",CHAN_WEAPON,attenuation:0.6);
				}
				Else
				{
					A_QuakeEx (1,1,1,35,0,768,"",QF_GROUNDONLY,falloff:192,rollintensity:0.5);
					A_SetScale (2.5); //Directly modifying the scale doesn't work for some reason.
					A_StartSound ("Grenade/Explode",CHAN_WEAPON,attenuation:0.45);
				}
				Roll = 0;
				If (Pos.Z >= FloorZ+88) Return ResolveState ("Death.Air"); //If the explosion happened above 88 map units from the ground, trigger the air explosion.
				
				Light = DynamicLight(Spawn ("PointLight",Vec3Offset (0,0,Height/2)));
				If (Light)
				{
					Light.Args[3] = 128; //Intensity
					Light.Args[0] = 255; Light.Args[1] = 225; Light.Args[2] = 179; //RGB
				}
				
				Return State (Null);
			}
			GXPL A 2 Bright
			{
				SM_SpawnHitscanShrapnel (360,5); //The frag.
				If (Light) Light.Args[3]-= 9.84;
			}
			GXPL B 4 Bright
			{
				If (HEGrenade) //HE grenades have a more dangerous blast at the expense of producing no shrapnel.
					A_Explode (256,256,fulldamagedistance:128);
				Else
					A_Explode (192,192,fulldamagedistance:88);
				If (Light) Light.Args[3]-= 9.84;
			}
			GXPL CDEFGHIJKLMNO 4 Bright {If (Light) Light.Args[3]-= 9.84;}
			TNT1 A 0 {If (Light) Light.Destroy();}
			Stop;
		Death.Air:
			TNT1 A 0
			{
				Light = DynamicLight(Spawn ("PointLight",Vec3Offset (0,0,8)));
				If (Light)
				{
					Light.Args[3] = 128; //Intensity
					Light.Args[0] = 255; Light.Args[1] = 253; Light.Args[2] = 117; //RGB
				}
			}
			GAXP A 5 Bright
			{
				SM_SpawnHitscanShrapnel (360,5,air:True); //The frag.
				If (Light) Light.Args[3]-= 32;
			}
			GAXP B 5 Bright
			{
				If (HEGrenade)
					A_Explode (256,384,fulldamagedistance:192);
				Else
					A_Explode (192,256,fulldamagedistance:128);
				If (Light) Light.Args[3]-= 32;
			}
			GAXP C 5 {If (Light) Light.Args[3]-= 32;}
			GAXP C 0 {If (Light) Light.Destroy();}
			GAXP DEFGHIJ 5 Bright;
			Stop;	
	}
}

Class SM_HEGrenade : SM_FragGrenade
{
	Override Void BeginPlay()
	{
		Super.BeginPlay();
		HEGrenade = True; //Magic grenade switch.
	}
}

Class SM_SmokeGrenade : KAI_BaseProjectile
{
	Default
	{
		Radius 4;
		Height 8;
		Mass 1;
		Gravity 0.5;
		Scale 0.2;
		Speed 30;
		BounceFactor 0.4;
		WallBounceFactor 0.5;
		ReactionTime 35*4; //Used as the fuse timer, similar to how A_Countdown uses it.
		BounceType "Hexen";
		BounceSound "Grenade/Bounce";
		DamageType "Grenade";
		-NoGravity;
		-NoBlockmap; //So marines can find and run from them. MAYDO: Remove this probably, not sure how relevant it'll be once I add a VJ Base esque hazard system to the KAI.
		+RollSprite;
		+FloorClip;
		+CanBounceWater;
		+DontBounceOnSky;
		+BounceOnActors;
	}
	
	Override Void Die (Actor Source, Actor Inflictor, Int DMGFlags, Name MeansOfDeath)
	{
		Vector3 OldVel;
		Super.Die (Source, Inflictor, DMGFlags, MeansOfDeath);
		Vel = OldVel;
	}
	
	Override Void Tick()
	{
		Super.Tick();
		
		If (IsFrozen())
			Return;
		
		//The actual timer.
		If (IsInState(Self,"Spawn"))
		{
			ReactionTime--;
			//Play the beeping sound when the grenades' fuse is close to detonaton. But not when the grenade has exploded.
			If (ReactionTime <= Default.ReactionTime/3)
				A_StartSound ("Grenade/Warning",CHAN_WEAPON,CHANF_LOOPING,1.0,2);
		}
		
		If (GetAge() % 4 == 0)
		{
			//Only roll and play the bounce sound when moving fast enough.
			If (Vel.Length() >= 2)
			{
				BounceSound = Default.BounceSound;
				Roll += 20;
				SpriteOffset.X = 0;
			}
			Else
			{
				BounceSound = "";
				Roll = -90; //Fall over when not in motion.
				SpriteOffset.X = -4;
			}
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_SpawnItemEx ("SM_GrenadeLever",yvel:FRandom(-2,-4),FRandom(2,4));
			SMGR F 4
			{
				//Time's out.
				If (ReactionTime <= 0)
					SetStateLabel ("Deploy");
			}
			Goto Spawn+1;
		Deploy: //KLUDGE: The smoke canister can't "die" because then it gets stuck in mid air.
			SMGR F 0
			{
				A_StopSound (CHAN_WEAPON);
				A_StartSound ("Grenade/SmokeDeploy");
				bNoGravity = False; //Can still bounce around.
				ReactionTime = GameTicRate*15; //Now the reaction time is used to count how long before the grenade stops spitting smoke.
				//A KAI NPC spawned us, get their handler so we only have the inevitable projectile list update overhead.
				If (Target && Target Is "KAI_Actor")
				{
					If (KAI_Actor(Target).KAIHandler)
						KAI_Actor(Target).KAIHandler.RemoveFromProjectileList (Self);
				}
				//Not a KAI NPC shooter, or we had no shooter at all. So we need the extra overhead of finding the handler.
				Else If (!Target || !(Target Is "KAI_Actor"))
				{
					Let Handler = KAI_EventHandler(EventHandler.Find("KAI_EventHandler"));
					If (Handler)
						Handler.RemoveFromProjectileList (Self);
				}
			}
			SMGR F 1
			{
				If (ReactionTime <= 0) Return State (Null);
				console.printf ("smoke counter is %d",reactiontime);
				
				Actor Smoke;
				For (Int I = 2; I > 0; I--)
				{
					Smoke = Spawn ("SM_SmokeParticle",Pos.PlusZ (Height/2),ALLOW_REPLACE);
					
					If (Smoke)
					{
						Double XVel = FRandom (7,-7); Double YVel = FRandom (7,-7); Double ZVel = FRandom (-2,7);
						Double Ang = FRandom (0,360);
						Smoke.Angle = Angle;
						Smoke.Vel.X = XVel * Cos (Ang) + YVel * Sin (Ang);
						Smoke.Vel.Y = XVel * Sin (Ang) - YVel * Cos (Ang);
						Smoke.Vel.Z = ZVel;
						
						Smoke.Speed *= FRandom (-1.5,1.5); //Set roll speed.
						Smoke.ReactionTime *= FRandom (0.75,2.5);
						Double Mul = FRandom (0.75,3); //Update both the visual and hitbox size, for +SHADOWBLOCK.
						Smoke.Scale *= Mul;
						Smoke.A_SetSize (Radius*Mul,Height*Mul);
					}
				}
				
				If (Smoke) ReactionTime--; //Increment the counter only every tick in which smoke was spawned.
				Return State (Null);
			}
			Wait;
	}
}

Class SM_ShrapnelPuff : BulletPuff
{
	Default {Scale 0.5;}
	Mixin SM_SplashFunctions;
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		Bool HitLiquid;
		//The floor was hit.
		If (Pos.Z <= FloorZ)
			HitLiquid = DoSplash(CheckLiquid(FloorPic));
		//The ceiling was hit.
		Else If (Pos.Z + Height >= CeilingZ)
			HitLiquid = DoSplash(CheckLiquid(CeilingPic),True);
		
		If (HitLiquid) Destroy(); //Splash was spawned, so just delete yourself.
	}
	
	//High quality programming.
	Bool DoSplash (Int LiquidType, Bool UpsideDown = False) //Static so SM_ShrapnelPuff can use it too.
	{
		If (LiquidType == LIQUID_NONE) Return False;
		Actor Splash = Spawn ("SM_BulletSplash",Pos);
		
		Switch (LiquidType)
		{
			Case LIQUID_NUKAGE:
				Splash.A_SetTranslation ('SM_Splash_Nukage');
				Break;
			Case LIQUID_LAVA:
				Splash.A_SetTranslation ('SM_Splash_Lava');
				Break;
			Case LIQUID_BLOOD:
				Splash.A_SetTranslation ('SM_Splash_Blood');
				Break;
			Case LIQUID_SLIME:
				Splash.A_SetTranslation ('SM_Splash_Slime');
				Break;
			Default:
				Break;
		}
		Double Size = FRandom (0.4,0.6);
		Splash.Scale.X = Splash.Scale.Y = (UpsideDown ? -Size : Size);
		Splash.bXFlip = Random (False,True);
		Return True;
	}
}

Class SM_SmokeParticle : Actor
{
	Default
	{
		Speed 2; //How fast the smoke rolls around.
		Radius 24;
		Height 48;
		ReactionTime 35; //How long the smoke lasts.
		ShadowPenaltyFactor 2.0;
		Scale 0.75;
		//RenderStyle "Add";
		+NoGravity;
		+RollSprite;
		+ShadowBlock; //The secret sauce.
		+ForceXYBillboard;
	}
	
	Override Void Tick ()
	{
		If (IsFrozen())
			Return;
		
		Vector3 Old = Pos;
		
		//Copy of the basic MF5_NOINTERACTION movement code. Since that flag also disables blockmap linking, which is needed for SHADOWBLOCK.
		If (!KAI_Math.IsEmptyVector3 (Vel))
			SetOrigin (Vec3Offset(Vel.X,Vel.Y,Vel.Z),True);
		
		Vel *= 0.98;
		
		ReactionTime--;
		
		//FastProjectile state progression code.
		if (Tics != -1)
		{
			If (Tics > 0) Tics--;
			While (!Tics)
			{
				If (!SetState (CurState.NextState))
				{ // Mobj was removed
					Return;
				}
			}
		}
	}
	
	States
	{
		Spawn:
			MSMK ABCDEFG 2 A_SetRoll (Roll+Speed,SPF_INTERPOLATE);
			MSMK G 0 A_JumpIf (ReactionTime < 0, 2);
			MSMK G 2 A_SetRoll (Roll+Speed,SPF_INTERPOLATE);
			Goto Spawn+7;
			MSMK HIJKLM 2
			{
				A_SetRoll (Roll+Speed,SPF_INTERPOLATE);
				A_SetSize (Radius*0.98,Height*0.98); //The hitbox size matters for SHADOWBLOCK as well.
				A_SetScale (Scale.X*0.98);
				A_FadeOut (0.02);
			}
			Stop;
	}
}
Class SM_GrenadeLever : Actor //The lever the grenade drops once the pin is pulled.
{
	Default
	{
		Radius 6;
		Height 8;
		Scale 0.25;
		+NoBlockmap;
		+RollSprite;
		+MoveWithSector;
	}
	States
	{
		Spawn:
			SMGR D 1 NoDelay
			{
				If (Pos.Z - FloorZ >= 1)
					Roll += 5;
				Else
					Roll = -45;
			}
			Loop;
	}
}

Class SM_EmptyMagazine : Actor
{
	Default
	{
		Radius 6;
		Height 8;
		Scale 0.7;
		+NoBlockmap;
		+RollSprite;
		+MoveWithSector;
	}
	States
	{
		Spawn:
			MARA ] 1 NoDelay
			{
				If (Pos.Z - FloorZ >= 1)
					Roll += 5;
				Else {SpriteOffset.X = 3; Roll = 90;} //Fall sideways on the floor.
			}
			Loop;
	}
}

Class SM_Tracer : KAI_Tracer
{
	Default
	{
		//Alpha 0.95;
		RenderStyle "Add";
		+NeverRespawn;
		+Bright;
	}
	
	Override Void Tick()
	{
		Super.Tick();
		If (!IsFrozen() && Master && GetAge() % 2 == 0)
			{Angle = Master.Angle; Pitch = Master.Pitch;}
			//A_FaceMovementDirection();
	}
	States
	{
		Spawn:
			POSS A -1 Light ("MarineBulletLight");
			Stop;
	}
}

//High quality code rip.
Class SM_LiquidSplash : KAI_MixinActor
{
	Default
	{
		MeleeRange 0; //The range in which the splash does full explosion damage.
		MaxTargetRange 0;
		+NoGravity;
		+MoveWithSector;
	}
	
	Override Void BeginPlay ()
	{
		Super.BeginPlay();
		
		Volume = 1.0; //Default volume is 1.
		Attenuation = 0.6;
	}
	
	Override Void PostBeginPlay ()
	{
		Super.PostBeginPlay();
		
		If (ExplosionDamageType == '' || !ExplosionDamageType)
			ExplosionDamageType = 'Explosion'; //Default damage type.
		
		If (!SplashSound)
			SplashSound = "SFX/LiquidExplosion";
	}
	
	Mixin SM_SplashFunctions;
	Name ExplosionDamageType;
	Int RadiusDamage;
	Sound SplashSound;
	Double Volume, Attenuation;
	Bool DontHarmSource;
	Int LiquidType;
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				Switch (LiquidType)
				{
					Case LIQUID_WATER:
						Sprite = GetSpriteIndex ('GSPL');
						Break;
					Case LIQUID_NUKAGE:
						Sprite = GetSpriteIndex ('GSPN');
						Break;
					Case LIQUID_BLOOD:
						Sprite = GetSpriteIndex ('GSPB');
						Break;
					Case LIQUID_LAVA:
						Sprite = GetSpriteIndex ('GSPP');
						Break;
					Case LIQUID_SLIME:
						Sprite = GetSpriteIndex ('GSPS');
						Break;
					Default:
						Sprite = GetSpriteIndex ('GSPL');
						Break;
				}
			}
			#### A 3 A_StartSound (SplashSound,CHAN_BODY,0,Volume,Attenuation);
			#### B 3
			{
				If (RadiusDamage > 0)
				{
					MakeAlliesImmuneToExplosion (Target, RadiusDamage);
					A_Explode (RadiusDamage,Int(MaxTargetRange),(DontHarmSource ? 0 : XF_HURTSOURCE)|XF_EXPLICITDAMAGETYPE,fulldamagedistance:Int(MeleeRange),damagetype:ExplosionDamageType);
					RemoveAllyExplosionImmunity();
				}
			}
			#### CDEF 4;
			#### GHIJKLMNOPQRSTUVWXYZ 3;
			Stop;

		//Load frames into memory to not cause GetSpriteIndex to trigger crashes.
		Storage:
			GSPL ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			GSPN ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			GSPB ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			GSPP ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			GSPS ABCDEFGHIJKLMOPQRSTUVWXYZ 0;
			Stop;
	}
}

//Used by marines after they parkour to give them NoDropoff temporarily, for a few steps. So that they don't get stuck after climbing ledges, but will also
//not fall off cliffs like lemmings.
Class SM_DropoffToken : Inventory
{
	Default {ReactionTime 16;}
	Bool PrevDropoff;
	Override Void AttachToOwner (Actor Other)
	{
		Super.AttachToOwner(Other);
		If (Other && !Other.bDropoff)
		{console.printf ("gave %s the dropoff flag temporarily",other.getclassname());
			PrevDropoff = Other.bDropoff;
			Other.bDropoff = True;
		}
		Else
			GoAwayAndDie();
	}
	Override Void DoEffect ()
	{
		Super.DoEffect();
		
		If (GetAge() >= ReactionTime)
		{console.printf ("took the dropoff flag from %s",owner.getclassname());
			If (Owner) Owner.bDropoff = PrevDropoff;
			GoAwayAndDie();
		}
	}
}