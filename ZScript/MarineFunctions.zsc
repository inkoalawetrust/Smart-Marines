Extend Class SM_Marine
{
	Enum MarineChaseFlags
	{
		SMC_NOUSESTATE = 1 << 0, //The marine will not wait in his interact state after using a line with no threat around.
	}
	//Unlike in the original Smart Marines, this is VERY MUCH a custom function.
	Void SM_Chase (StateLabel WaitState = Null, StateLabel RetreatState = Null, Int Flags = 0, Int ChaseFlags = 0, Double TurnRadius = 25)
	{
		//Very marine specific things
		If (BurstCounter) BurstCounter = 0; //Reset the burst fire countdown when not firing. Like if the marine is hurt mid-burst.
		bNoFriction = Default.bNoFriction; //Reset the friction flag to the default, in case the marine begun firing or something mid-jump.
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		
		//ZScript exports of different segments of GZDooms' native AI code. This is the stuff not needed for movement.
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_Chase_FriendsAttackPlayerEnemies(ChaseFlags);
		KAI_Chase_Retarget(ChaseFlags,True); //Friendly marines go idle with no target too.
		KAI_Chase_HandleActiveSound(ChaseFlags); //MAYDO: Remove this ?
		
		Bool MovedAlready;
		Double MajorThreatRange = 1536*1536;//(RetreatRange*4)*(RetreatRange*4);
		
		//Run away from major threats.
		If (bNoFear && Target && !(Goal && bChaseGoal))
		{
			If (!(ChaseFlags & CHF_DONTMOVE))
			{
				//If you can't attack (But not because you are in a NOATTACK sector), run. Also run if the other actor is frightening or you're frightened.
				If ((!CanAttack() && !(CurSector.Flags & Sector.SECF_NOATTACK)) || bFrightened || IsFrightening (Target) ||
				//If the targets' threat level is over the threshold, and it's visible and nearby, GTFO.
				ThreatLevelThreshold != THREAT_ASSESS && AssessThreatLevel(Target, True) >= ThreatLevelThreshold && (Distance3DSquared(Target) < MajorThreatRange))
				{
					//And at last, check if the target is still visible.
					If (CheckSight (Target, SF_IGNOREWATERBOUNDARY))
					{
						If (!RetreatState)
							KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
						Else
							SetStateLabel (RetreatState);
						MovedAlready = True;
						Return;
					}
				}
			}
		}
		
		Bool UsedLine;
		//If you can move and haven't done so already.
		If (!(ChaseFlags & CHF_DONTMOVE))
		{
			//Only update the nearest enemy to run from when not focused on a route.
			If (bAvoidMelee && !(IsPatrolling(Self) && bChaseGoal)) NearestEnemy = FindNearestEnemy (128); //TODO: Unhardcode the retreat range probably.
			//If you aren't patrolling and not allowed off your route, and there is an enemy nearby.
			If (bAvoidMelee && NearestEnemy)
			{
				If (!RetreatState)
					KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
				Else
					SetStateLabel (RetreatState);
				MovedAlready = True;
				//Return; //Might still melee you.
			}
			//Actual movement handling.
			Else
			{
				Bool B;
				KAI_Chase_HandleStrafing (Target,ChaseFlags);
				[B,MovedAlready] = KAI_Chase_PatrolHandling(WaitState, 0.2, anglelimit:TurnRadius, chaseflags:ChaseFlags);
				
				/*If there is no danger in sight, the marine will wait for lines he used like doors and platforms to move. Instead of moving around like a
				normal monster. However, if there IS danger nearby, the marine will keep moving after using the line like normal.*/
				Int NoStockUse;
				If (!IsDangerNearby())
				{
					NoStockUse = KMT_NOLINEUSE;
					UsedLine = SM_MarineUseLine(faceline:!(Flags & SMC_NOUSESTATE)); //Check if there's a line in front of use to use.
				}
				
				//Crouching comes first.
				//If (!MovedAlready)
				//	MovedAlready = SM_HandleCrouching();
				//Else
					SM_HandleCrouching();
				
				If (!Crouching)
				{
					If (!MovedAlready)
						MovedAlready = SM_HandleClimbing();
					Else If (MovedAlready && !Crouching)
						SM_HandleClimbing();
				}
				
				Vector2 JumpPosition = SM_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
				If (JumpPosition == JumpPosition && !Crouching) //We have a valid position we must jump to, AKA the returned vector isn't null.
				{
					JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
					Bool Reachable = True; //Assume we can jump there by default.
					//The jump destination is longer than half the jump distance, so do a long jump if there's space behind you for it.
					If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5 && (Reachable = SM_CanRunBack()))
					{console.printf ("doing a long jump over a distance of %.2f threshold is %d",Level.Vec2Diff (Pos.XY,JumpPosition).Length(),MARINE_JUMPLENGTH/1.5);
						PreJumpPos = Vec3Angle(256,Angle-180);
						SetStateLabel ("Jump.Running");
						MovedAlready = True;
					}
					Else If (Reachable) //If the gap is too short to do a running jump, do a normal one, but don't fall back to normal jumps for large gaps.
					{
						SetStateLabel ("Jump");
						MovedAlready = True;
					}
				}
				
				//Finally, if you do have a target, DO move towards it, but with KAI_MoveTowards instead of the shitty native movement code.
				If (Target && !MovedAlready)
				{
					KAI_MoveTowards (Target.Pos, 0.5, TurnRadius, ChaseFlags, KMT_CHASEGOAL|KMT_ZIGZAG|NoStockUse);
				}
			}
		}
		
		SM_UpdateChaseTimer();
		ShouldAttack(); //Run attack decision code.
		
		If (!(Flags & SMC_NOUSESTATE) && UsedLine) 
			SetStateLabel ("Interact");
		
		//If you are set to not automatically idle, only do it when the timer is over the threshold.
		If (ChaseFlags & CHF_DONTIDLE && ChaseTimer >= MARINE_CHASETIME)
		{
			A_ClearTarget();
			ChaseTimer = 0;
			SetIdle();
		}
	}
	
	Bool SM_CanRunBack()
	{
		Vector3 RealPos = Pos;
		Bool Moved = IsPosReachable (Vec3Angle(256,Angle-180));
		If (Moved)
		{
			SetOrigin (Vec3Angle(256,Angle-180),False);
			Moved = IsPosReachable (Vec3Angle(256,Angle));
			SetOrigin (RealPos,False);
		}
		Return Moved;
	}
	
	//Handle the marine crouching when his move is potentially obstructed by level geometry and/or actor obstacles.
	//Returns true if the marine will crouch, false if he will not.
	Bool SM_HandleCrouching (Bool ChangeHeight = True)
	{
		Vector2 CheckPos = Vec2Angle(Speed,Angle);
		FCheckPosition Tm;
		//Tm.FromPMove = True;
		
		Double CurHeight = Height;
		Height = Default.Height; //Check our uncrouched height.
		
		//TODO: Figure out how to distinguish if the move is blocked by a ceiling being too short or an actor being below the marines' height ONLY.
		If (!CheckPosition (CheckPos,tm:Tm))
		{
			Double SecHeight = Tm.CeilingZ;
			F3DFloor FFloor;
			If (FFloor = SM_Find3DFloorInFrontOfMe(Level.Vec2Diff(Pos.XY,CheckPos).Length()*3))
				SecHeight = FFloor.Bottom.ZAtPoint(CheckPos);
			
			If (BlockingMobj && (BlockingMobj.Pos.Z < Pos.Z+Height && BlockingMobj.Pos.Z >= Pos.Z+MARINE_CROUCHHEIGHT) ||
			(SecHeight < Pos.Z+Height && SecHeight >= Pos.Z+MARINE_CROUCHHEIGHT))
			{a_log ("SM_HandleCrouching(): Marine must crouch to cross this obstacle.");
				If (ChangeHeight) Height = MARINE_CROUCHHEIGHT;
				Crouching = True;
				Return True;
			}
			else
				a_log ("SM_HandleCrouching(): nothing short enough is blocking the marine to warrant crouching");
		}else a_log ("SM_HandleCrouching():hello, i don't need to crouch at all");
		
		Crouching = False;
		Height = CurHeight;
		If (ChangeHeight) Height = Default.Height;
		a_log ("SM_HandleCrouching(): Marine doesn't need to crouch.");
		Return False;
	}
	
	//Exactly what it says, handles detecting ledges and making the marine climb them.
	//The jumping variable allows the marine to jump so that he can catch ledges that are barely just too high to reach.
	Bool SM_HandleClimbing (Bool Jumping = True)
	{
		FCheckPosition Tm;
		Tm.FromPMove = True;
		Vector2 CheckPos = Vec2Angle(Speed,Angle);
		//Handle climbing up ledges about the marines' height.
		//BUG: The code causes the marine to climb over invisible ledges if it crosses from normal geometric ground to bridge things.
		If (!CheckMove (CheckPos,0,Tm)
		//Marines can climb over actors, but shouldn't do it on LIVING ones, since it looks stupid, especially with friendly marines climbing over the player.
		&& (!BlockingMobj || IsInanimateObject (BlockingMobj)))
		{
			//KLUDGE: I'm pretty sure Tm.FloorZ should handle actors itself, but it doesn't.
			Double ClimbZ = Tm.FloorZ;
			
			F3DFloor FFloor;
			//Check for 3D floors the marine can climb over separetely with a trace, since CheckPosition() won't cut it.
			If (FFloor = SM_Find3DFloorInFrontOfMe(Level.Vec2Diff(Pos.XY,CheckPos).Length()*3)) //There's actually a 3D floor in front of the marine.
				{ClimbZ = FFloor.Top.ZAtPoint(CheckPos); //Set the climbZ to the top of that 3D floor !
				a_log ("i hit a 3d floor");}
			console.printf ("3d floor height is %.2f, check trace distance is %.2f",climbz,Level.Vec2Diff(Pos.XY,CheckPos).Length()*3);
			
			If (BlockingMobj)
				ClimbZ = BlockingMobj.Pos.Z + BlockingMobj.Height;
			if (isinstate (self,"jump"))
				console.printf ("im trying to climb mid jump, my z pos is %.2f, and my climb height is %.2f, tm.floorz is %.2f",pos.z,climbz,tm.floorz);
			//Ledge is just at around the marines' height.
			If (ClimbZ < Pos.Z+(Height*1.1) && !(FloorZ - Tm.DropoffZ > MaxDropOffHeight))
			{
				ClimbPos = (CheckPos,ClimbZ);
				SetOrigin ((ClimbPos.XY,Pos.Z),True);
				console.printf ("angle to pos is %.2f, climbz is %.2f",GetAngleToPos(ClimbPos),ClimbZ);
				SetStateLabel ("Climb");
				Return True;
			}
			//Ledge is just a bit too tall for the marine, but could be still reached by jumping and grabbing it.
			//Height*1.75 is around 98 MU with the marines' 56 MU height.
			Else If (Jumping && ClimbZ < Pos.Z+(Height*1.75) && !(FloorZ - Tm.DropoffZ > MaxDropOffHeight))
			{
				//If (ClimbZ >= Pos.Z+(Height*1.8)) //Blocking actor is too high up to climb over.
				//	{a_log ("this truck is too tall to jump AND THEN climb over, nested check");Return False;}
				
				JumpPos = (CheckPos,ClimbZ-56); //Jump to the position we need to climb.
				SetStateLabel ("Jump.Up");
				Return True;
			}
			else
			a_log ("this truck is too tall to jump AND THEN climb over");
		}
		Return False;
	}
	
	//Get a position for the marine to jump to, if he doesn't have to jump, the gap is too wide, or there's something in the way, this returns a null vector.
	Vector2 SM_GetJumpPosition (Double CheckDistance, Double CheckAngle)
	{
		Vector2 PosOffset = Vec2Angle (Radius*2.01,CheckAngle);
		
		vector3 oldpos = pos;
		//setorigin ((posoffset,pos.z),false);
		Vector2 Path = Level.Vec2Diff( PosOffset, Vec2Angle (CheckDistance,CheckAngle));
		Double Distance = Path.Length();
		Double Spacing = Radius*2.01;
		If (Distance <= 1) {a_log ("SM_GetJumpPosition(): Epic fail");Return (Double.NaN,Double.NaN);}
		Path /= Distance;
		Double RealDropHeight = MaxDropoffHeight;
		
		Vector2 MovePos;
		//FCheckPosition Tm;
		FLineTraceData Jump;
		Double RealHeight;
		
		//Get the ACTUAL collision height, actors included.
		Double REALFloorZ = FloorZ;
		Bool Useless; //Why fucking return if the caller is on another actor ? Just return the fucking POINTER !
		Actor Bottom;
		SetOrigin (Pos.PlusZ(-1),False);
		[Useless,Bottom] = TestMobjZ ();
		SetOrigin (Pos.PlusZ(1),False);
		If (Bottom)
			REALFloorZ = Bottom.Pos.Z+Bottom.Height;
			
		For (Int I = Spacing; I < Distance+(Spacing*2); I += Spacing)
		{
			MovePos = Level.Vec2Offset(Pos.XY, Path*I);//spawn ("kai_debugpoint",(movepos,tm.floorz));
			console.printf ("performed %d jump checks at %d %d",I,movepos);
			//Bool Moved = CheckPosition (MovePos,False,Tm);
			LineTrace (0,8192,90,TRF_THRUHITSCAN|TRF_SOLIDACTORS|TRF_ABSPOSITION,0,MovePos.X,MovePos.Y,data:Jump);
			FSpawnParticleParams P; P.Color1 = "Green"; P.Style = STYLE_None; P.Lifetime = 2; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
			KAI_LOFRaycast.VisualizeTracePath((MovePos,Pos.Z),Jump.HitLocation,Jump.Distance,8,p);
			//Tm.DropoffZ = Tm.FloorZ = Jump.HitLocation.Z;
			if (jump.hitsector) a_log ("jump check found a sector");
			
			console.printf ("SM_GetJumpPosition(): movepos %d %d %d, REALFloorZ is %d",(movepos,Jump.HitLocation.Z),Jump.HitLocation.Z);
			//Get the real height, used by GetZAt to handle ledges.
			RealHeight = CurSector.NextLowestFloorAt (Pos.X,Pos.Y,Pos.Z,FFCF_3DRESTRICT,MaxStepHeight);
			//This position has a dropoff larger than the marines' dropoff height.
			Sector SecAt = Level.PointInSector (MovePos);
			If (SecAt && Jump.HitLocation.Z >= SecAt.FloorPlane.ZAtPoint(MovePos) && (REALFloorZ - Jump.HitLocation.Z) > RealDropHeight/2)// && (RealHeight - Jump.HitLocation.Z) > RealDropHeight/2)
			{
				//spawn ("kai_debugpoint",(movepos,Jump.HitLocation.Z));
			}
			//Or it doesn't, so stop the check, this is where we should jump at. If it's not short enough for the marine to just walk over of course.
			Else
			{
				console.printf ("SM_GetJumpPosition(): failed pos at %d %d, ravine height is %d, REALFloorZ %d, check height %d",movepos,
				(REALFloorZ - Jump.HitLocation.Z),REALFloorZ,Jump.HitLocation.Z);
				console.printf ("okay, how the actual fuck is the marines own floor height the same as the check trace ? is he at %d %d %d",pos);
				//Make the jump pos null if the distance to the jump position is shorter than the marines' radius. Like if there is no hole to jump over at all.
				If (Level.Vec2Diff (Pos.XY,MovePos).Length() < Spacing)
					{a_log ("SM_GetJumpPosition(): jump length too short, nullifying jump position");MovePos = (Double.NaN,Double.NaN);}
				Break;
			}
		}
		
		//The path was clear and all that, but the final position is RIGHT INTO THE MOAT WE'RE WANT TO JUMP OVER.
		If ((REALFloorZ - Jump.HitLocation.Z) > RealDropHeight/2)// && (RealHeight - Jump.HitLocation.Z) > RealDropHeight/2)
			{console.printf ("SM_GetJumpPosition(): jump destination is in the pit, cancelling jump");MovePos = (Double.NaN,Double.NaN);}
		
		//setorigin (oldpos,false);
		
		If (MovePos == MovePos) //Only run this if MovePos isn't null.
		{
			FLineTraceData JumpClear;
			LineTrace (CheckAngle,distance,0,TRF_SOLIDACTORS|TRF_THRUHITSCAN,Height/2,Radius*2,data:JumpClear);
			FSpawnParticleParams P; P.Color1 = "Blue"; P.Style = STYLE_None; P.Lifetime = 35; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
			KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(Height/2),JumpClear.HitLocation,JumpClear.Distance,8,p);
			console.printf ("SM_GetJumpPosition(): jumpclear distance is %.2f, and it hit at %d %d %d",jumpclear.distance, jumpclear.hitlocation);
			
			If (JumpClear.HitType != TRACE_HitNone)
				{a_log ("SM_GetJumpPosition(): my jump path is not clear");Return (Double.NaN,Double.NaN);}
			
			//spawn ("teleportfog",(movepos,Jump.HitLocation.Z));
		}
		Return MovePos;
	}
	
	//ATTEMPT AT AN ALTERNATE JUMP FUNCTION.
	//v0 is the velocity
	//g is the gravity
	/*Void SM_JumpTo (Vector3 Where, Double JumpSpeed = 17.2)
	{
		Double G = GetGravity();
		Double Root = JumpSpeed * JumpSpeed * JumpSpeed * JumpSpeed - G * (G * Where.X * Where.X + 2.0 * Where.Y * JumpSpeed * JumpSpeed);
		//If (Root <= 0)
		//	Return;
		Root = Sqrt (Root);
		Double Ang = ATan ((JumpSpeed * JumpSpeed - Root) / (G / Where.X));
	}*/
	
	//Have the marine jump to the specified position, this uses a custom version of Lewisk3's grenade throwing function.
	Void SM_JumpTo (Vector3 Where, Double JumpSpeed = -17.2)
	{
		//FireGrenade() properties turned into hardcoded variables.
		Double AimDist = 0;//MARINE_JUMPLENGTH;
		Double MaxPitch = 45;//90;
		Double AimSens = 1.1;
		
		// Source and Destination
		vector3 fromPos = (
			pos.xy,
			pos.z + (height/2) //MAYDO: Remove this additional Z offset entirely maybe ?
		);
		vector3 toPos = Where;
		
		vector3 diff = level.vec3diff(fromPos, toPos);
		
		// Modify toPos Z component based on how many units the thrown  ̶g̶r̶e̶n̶a̶d̶e̶ marine
		// fall by the time it reaches the destination.
		double dist = diff.xy.Length();
		if(dist >= aimDist)
		{
			double grav = 1.0 + ceil(self.GetGravity() * (level.gravity * 0.010769));
			double ticsDist = diff.Length() / double(max(self.Speed,1.0));        
			double fallDist = ticsDist * grav;
			toPos.z += fallDist * aimSens;
		}
		
		// Recalculate differences.
		diff = level.vec3diff(fromPos, toPos);
		double aimPitch = VectorAngle( sqrt(diff.y*diff.y + diff.x*diff.x), diff.z );
		aimPitch = min(aimPitch, maxPitch);
		//spawn ("teleportfog",topos);
		// Modify  ̶g̶r̶e̶n̶a̶d̶e̶ marine velocity
		double a = GetAngleToPos(Where,0);
		double p = -aimPitch;
		
		//If the jump speed is negative, pick a jump speed that will be JUST enough to throw the marine at the desired position, as long as the calculated
		//velocity is below the negative speed. Essentially making the negative velocity act like a speed limit instead of a hardcoded value.
		If (JumpSpeed < 0)
		{
			JumpSpeed = Abs (JumpSpeed);
			Double Original = JumpSpeed;
			JumpSpeed = KAI_Math.LinearMap (Diff.Length(),0,MARINE_JUMPLENGTH,0,JumpSpeed);
			JumpSpeed = Abs (JumpSpeed);
			JumpSpeed = Clamp (JumpSpeed,0,Original);
			/*vector3 diff = level.vec3diff(fromPos, toPos);
			double v = abs(jumpSpeed);
			double g = GetGravity();
			double dX = diff.x**2;
			double dY = diff.y*(v*v);
			double velocityDelta = (v*v*v*v) - ( g * ((g*dX) + (2*dY)) );
			double thetaPitch = velocityDelta <= 0 ? 0 : atan( ((v*v) - velocityDelta) / (g * diff.x) );
			p = -thetaPitch;*/
			
			console.printf ("scaled jump vel: %.2f",jumpspeed);
		}
		
		self.vel = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * JumpSpeed;
		//If (JumpSpeed < 0) Self.Vel.Z = (ToPos.Z + Diff.Length() / (Vel.Length() * GameTicRate) * GetGravity());
		console.printf ("vel is %.2f %.2f %.2f",vel);
	}
	
	//Increment the chase timer as long as the target is nonexistent, dead, or out of sight. And reset it if any of these conditions are false.
	Void SM_UpdateChaseTimer()
	{
		If (IsPatrolling(Self)) //Ignore this if we are following a goal.
			ChaseTimer = 0;
		Bool Dead = IsDead(Target);
		If (!Target || Target && (Dead || !CheckSight(Target,SF_IGNOREWATERBOUNDARY)))
			ChaseTimer++;
		Else
			ChaseTimer = 0;
		If (!Target || Dead) ChaseTimer++; //Decrement the timer extra fast if the target is just flat out gone.
		//Console.Printf ("SM_UpdateChaseTimer(): Time is %d",ChaseTimer);
	}
	
	//Marines use lines in front of them.
	//IDEA: Make the marine detect doors or platforms in front of him, then if it's switch activated, search for nearby switches he can go up to and use. Dynamically.
	Sector UseSec;
	Bool SM_MarineUseLine (Double UseRange = 64, Bool FaceLine = False)
	{
		InteractWaits = 0; //Reset it here just in case.
		//Let LineSearch = BlockLinesIterator.Create (Self,Radius+64);
		//Count pushable lines as uses too.
        If (bCanPushWalls && BlockingLine && BlockingLine.Special && BlockingLine.Activate (Self,0,SPAC_Push))
		{
			//If (FaceLine) Angle = GetAngleToPos ((GetLinePos(BlockingLine),0));
			UseSec = GetLiftOrDoorSector(BlockingLine);//BlockingLine.BackSector;
			Return True;
		}
		
		If (!bCanUseWalls) Return False;
		FLineTraceData Usage;
		
		LineTrace (Angle,UseRange,0,TRF_BLOCKUSE,Height/2,data:Usage);
		
		FSpawnParticleParams P; P.Color1 = "Pink"; P.Style = STYLE_None; P.Lifetime = 1; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
		KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(Height/2),Usage.HitLocation,Usage.Distance,4,p);
		
		//Used a line in front of us.
		Line UseLine = Usage.HitLine;
		If (UseLine && UseLine.Special && UseLine.Activate (Self,Usage.LineSide,SPAC_Use))
		{
			//If (FaceLine) Angle = GetAngleToPos ((GetLinePos(UseLine),0));
			UseSec = GetLiftOrDoorSector(UseLine);//UseLine.BackSector;
			a_log ("a marine ran his custom line use function");
			Return True;
		}
		
		Return False;
	}
	
	//Gets the lift or door sector from the built in sector specials, instead of assuming the back sector is the door or lift, just in case.
	Sector GetLiftOrDoorSector (Line TheLine)
	{
		Sector Result;
		//Generally, it seems that args[0] is the tag of the affected sector. So this is what we assume.
		Switch (TheLine.Special)
		{
			Case 11: //Door_Open
			Case 12: //Door_Raise
			Case 21: //Floor_LowerToNearest
			Case 202: //Door_Generic
			Case 105: //Door_WaitRase
			Case 203: //Generic_Lift
			{
				Let TagIter = Level.CreateSectorTagIterator (TheLine.Args[0],TheLine);
				Result = Level.Sectors[TagIter.Next()];
				Break;
			}
		}
		
		If (TheLine.Args[0] == 0)
			Return TheLine.BackSector;
		
		Return Result;
	}
	
	//KLUDGE: Sector.PlaneMoving doesn't work, despite doing the same thing as this. So we have to use this, epic.
	Bool SM_SectorInMotion (Sector Sec)
	{
		If (!Sec)
			Return False;
		
		If (Sec.FloorData || Sec.CeilingData)
			Return True;
		
		Return False;
	}
	
	//Get the middle point of a line.
	//KLUDGE: GZDoom really doesn't like this formula I found on the Unreal Engine forum. Probably because it's too straightforward for its' esoteric tastes.
	Vector2 GetLinePos (Line TheLine)
	{
		If (!TheLine)
			Return (Double.NaN, Double.NaN);
		
		Return ((TheLine.V2.P - TheLine.V1.P) * 0.5 + TheLine.V1.P); 
	}
	
	//KAI_MoveAway wrapper.
	//MAYDO: Try and add code to make marines avoid smashing right into obstables ?
	Void SM_RunAway (Actor Other, Double RunRad = 64, Int MaxSteps = 32, Double TurnRadius = 25, Int ChaseFlags = 0, Int Flags = 0)//, Int KMAFlags = 0)
	{
		SM_HandleCrouching();
		
		If (!Crouching && SM_HandleClimbing())
			Return;
		
		Vector2 JumpPosition = SM_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
		If (JumpPosition == JumpPosition && !Crouching) //We have a valid position we must jump to, AKA the returned vector isn't null.
		{
			JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
			//The jump is longer than half the max jump distance, normally we do a running jump, but since we are presumably running for our lives, don't bother.
			If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5)
				Return;
			Else
			{
				SetStateLabel ("Jump");
				Return;
			}
		}		
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		
		KAI_MoveAway (Other, 16, RunRad, MaxSteps, 0.5, TurnRadius, ChaseFlags, Flags, KMA_USECORNERS);
	}
	
	//Returns true if the marine is down on the ground in some capacity, as opposed to standing up.
	Bool SM_IsCrouched()
	{
		Return (Crouching || MarineState & (MARINE_KNEELING|MARINE_LYINGDOWN));
	}
	
	//DECORATE-esque function for use in states.
	Void SM_SetMarineState (Int Add, Int Remove, Bool RemoveAll = False/*, Int Action = 0*/)
	{
		MarineState |= Add;
		If (!RemoveAll)
			MarineState &= ~Remove;
		Else
			MarineState = 0;
	}
	
	//Credit: Lewisk3
	void SM_FireGrenade(Actor toAct, class<Actor> nade, double maxPitch = 90, double aimSens = 1.0, double aimDist = 128)
	{
		if(!toAct) return;
		
		// Source and Destination
		vector3 fromPos = (
			pos.xy,
			pos.z + (height)
		);
		vector3 toPos = (
			toAct.pos.xy, 
			toAct.pos.z + (toAct.height * 0.5) 
		);
		
		vector3 diff = level.vec3diff(fromPos, toPos);
		
		// Spawn grenade, calculate values from instance.
		let nade = Spawn(nade, fromPos);
		if(!nade) return;    
		nade.target = self;
		
		// Modify toPos Z component based on how many units the thrown grenade
		// fall by the time it reaches the destination.
		double dist = diff.xy.Length();
		if(dist >= aimDist)
		{
			double grav = 1.0 + ceil(nade.GetGravity() * (level.gravity * 0.010769));
			double ticsDist = diff.Length() / double(max(nade.Speed,1.0));        
			double fallDist = ticsDist * grav;
			toPos.z += fallDist * aimSens;
		}
		
		// Recalculate differences.
		diff = level.vec3diff(fromPos, toPos);
		double aimPitch = VectorAngle( sqrt(diff.y*diff.y + diff.x*diff.x), diff.z );
		aimPitch = min(aimPitch, maxPitch);
		
		// Modify grenade velocity
		double a = AngleTo(toAct);
		double p = -aimPitch;
		nade.vel = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * nade.Speed;
	}
	
	State SM_CheckRefire (Int Chance, StateLabel AbortState, Double FOV = 360)
	{
		If (CurSector.Flags & Sector.SECF_NOATTACK)
			Return FindState (AbortState);
		
		AimPos = GetFAFAimPos (Target);
			
		If (Random2[pr_monsterrefire]() < Chance)
			Return State (Null);
		
		If (!Target || IsDead (Target) || (Target && !CheckFOV (Target,FOV)) || !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES))
			{a_log ("marine refire cancelled");Return FindState (AbortState);}
		
		Return State (Null);
	}
	
	//Marines just fire SM_Bullet, so for now at least, so we mostly just need the trace offsets.
	Bool SM_CheckLOF (Vector3 CheckOffsets = (0,0,32), Int PropHealthThreshold = 25, Bool AimingAt = False)
	{
		Let Check = New ("KAI_ProjectileLOFCheck");
		
		AimPos = GetFAFAimPos (Target);
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Target)
			{
				Double PitchTo = PitchTo (Target,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Target), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Double Distance = !AimingAt ? MaxTargetRange : Distance3D (Target)+8;
		Check.Shooter = Self;
		Check.Other = Target;
		Check.PropHealthThreshold = PropHealthThreshold; //This can depend on factors like how many rounds the marine is firing.
		
		Check.ProjInfo = New ('LOFProjInfo'); //Assign data class.
		Check.ProjInfo.Projectile = "SM_Bullet"; //Pass projectile class to trace.
		Check.ProjInfo.InitializeProjectileInfo(); //Let it infer the rest.
		
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Distance,0);
		
		//KAI_LOFRaycast.VisualizeTracePath (Level.Vec3Offset (Pos,CheckOffsets),Check.Results.HitPos,Check.Results.Distance);
		Bool BadLoaf = Check.BadLOF;
		If (Check.ProjInfo) Check.ProjInfo.Destroy();
		Check.Destroy();
		Return !BadLoaf;
	}
	
	Bool SM_FindInLOF (Actor Who, Vector3 CheckOffsets = (0,0,32), Bool AimingAt = False)
	{
		Let Check = New ("SM_FindTargetInLOF");
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Who)
			{
				Double PitchTo = PitchTo (Who,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Who), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Check.Shooter = Self;
		Check.Other = Who;
		Check.BadLOF = True; //We have to assume the LOF is bad, and if the trace finds the other actor, then it's a good LOF.
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,MaxTargetRange,0);
		Bool Res = Check.BadLOF;
		Check.Destroy();
		Return !Res;
	}
	
	//Get what part of the actor the marine is aiming at now.
	Double GetAimPosOffset ()
	{
		Switch (AimPos)
		{
			Case FAF_MIDDLE:
				Return Target.Height/2;
			Case FAF_TOP:
				Return Target.Height;
			Case FAF_BOTTOM:
				Return 0; //The bottom is the origin of actors.
			Default:
				Return 0;
		}
	}
	
	//Return what grenade type is likely currently appropriate against the enemy.
	Int DecideGrenadeType (Actor Against, Int Threshold = MARINE_GRENADECHANCE)
	{
		//Don't bother if the other actor doesn't exist, it's not time yet, or if the enemy flies and is over your head !
		If (!Against || GrenadeDelay || IsFlying (Against) && Pos.Z+Height < Against.Pos.Z) Return GRENADE_NONE;
		If (Distance3DSquared (Against) >= 768*768 || !SM_CheckLOF((0,0,Height),0)) //Not in throwing range. Or there is no direct LOF, yes, this doesn't account for arcing, I WILL NOT TRY.
			Return GRENADE_NONE;
		console.printf ("in range and in sight, lets decide to throw something, the throw threshold is %d",threshold);
		Bool ImmuneToBlasts = (Against.bNoRadiusDmg || Against.GetRadiusDamage (Against,256,256,128,False,True) <= 256/8); //The enemy is immune or HIGHLY resistant to blasts.
		Bool UseHE, UseSmoke;
		console.printf ("the %s will take %d damage",against.getclassname(),Against.GetRadiusDamage (Against,256,256,128,False,True));
		//Decide to throw the HE-FRAG grenade without the frag sleeve. Large blast radius and damage, good for strong enemies.
		//Based on RNG, if the target is super powerful, and if it's not effectively immune to pure explosion damage.
		If (!ImmuneToBlasts && (Random (0,255) < 96 || AssessThreatLevel (Against) >= ThreatLevelThreshold))
		{
			//Randomly decide to throw smoke, as long as the enemy CAN be affected by the smokescreen.
			If (Random (0,255) < 120 && (!Against.bSeeInvisible || Against.bShadowAim || Against.Player) && (Against.Player || Against.bDoShadowBlock))
				{UseSmoke = True;a_log ("i have randomly decided to throw smoke");}
			Else
				{UseHE = True;a_log ("i have decided to throw a pure HE grenade");}
		}
		
		//Now, let's check the chance of actually throwing a grenade.
		Int BulletDamage = Against.ApplyDamageFactor ("SmallRifleBullet",100); //Return how much damage the actor would actually take if 10 bullets did maximum damage.
		Int GrenChance = (Threshold > 0) ? Random (0,Threshold-24) : INT.MAX;console.printf ("the grenade throwing chance started as %d",grenchance);
		Int PreGrenChance = GrenChance; //The grenade chance before being incremented by AttackByQuantity.
		Double BlastRadius = 192;
		If (Threshold > 0)
		{
			GrenChance += 100-BulletDamage; //Increase grenade chance based on how much bullet damage the enemy can absorb.
			If (Target.Speed <= 6 || Random (0,255) < 64) //Our target is quite slow, lets see about throwing a smoke grenade.
				GrenChance += SM_AttackByQuantity (Target,!UseHE ? 192 : 256,True,ABQ_Infight|ABQ_Smokescreen);
			Else
				GrenChance += SM_AttackByQuantity (Target,!UseHE ? 192 : 256,True); //Grenade chance is also based on crowd size.
		}
		console.printf ("the grenade throwing chance is now %d",grenchance);
		If (GrenChance >= Threshold) //Decide if you should throw an HE or frag grenade.
		{
			If (UseHE)
				Return GRENADE_HE;
			Else If (UseSmoke)
				Return GRENADE_SMOKE;
			Else
				Return GRENADE_HEFRAG;
		}
		
		Return GRENADE_NONE;
	}
	
	//Prepare to throw a smoke grenade in front of you before retreating. That is to say like when running to reload.
	Bool PrepareForSmokeThrow (Int Chance = 48)
	{
		If (Target && Distance3DSquared (Target) <= 256*256) //If the target is too close, don't bother. Like if running away from a melee enemy.
			{A_LOG ("target is too close");Return False;}
		
		Chance += SM_AttackByQuantity (Target,flags:ABQ_Smokescreen); //Increase chance the more danger their is around.
		
		If (Health <= SpawnHealth()/3) //Extra chance if low on health.
			Chance += 30;
		
		If (Random (0,255) >= Chance)
			{console.printf ("a smoke chance of %d wasn't enough",chance);Return False;}
		
		//SM_SetMarineState (MARINE_RETREAT,MARINE_IDLING|MARINE_CHASING); //Specifies to the grenade drop state that the marine needs to retreat afterwards.
		GrenadeType = GRENADE_SMOKE;
		QuickGrenade = True;a_log ("throwing quick grenade and dipping.");
		Return True;
	}
	
	Enum ABQFlags
	{
		ABQ_Smokescreen = 1 << 0, //If on, ignore actors that can see through DOSHADOWBLOCK, unless they are players. 
		ABQ_Infight		= 1 << 1, //Give bonus points for monsters that can infight. Based on how many other monsters that can infight are found in Range.
	}
	
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks. Copied from the MVP !.
	//Range: The range around which to check for enemies.
	//AvoidAllies: Deduct points from the score for any allies in the AOE.
	//Smokescreen: This is a check for if the marine is throwing a smoke grenade. Makes actors that can see throw the smoke be ignored from the count.
	Int SM_AttackByQuantity (Actor Origin, Double Range = 256, Bool AvoidAllies = False, Int Flags = 0)
	{
		If (!Origin) Return 0;
		Actor Mobj;
		Int Chance;
		Bool IsHostile, IsVisible; //Caching
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Origin,Range);
		
		Int ViableEnemies;
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (!Mobj || IsDead (Mobj) || IsInanimateObject (Mobj) || Mobj == Self/* || Mobj == Origin*/) Continue;
			
			IsHostile = IsActorHostile (Mobj); IsVisible = IsVisible (Mobj,False);
			If (AvoidAllies && !IsHostile && IsVisible)
			{
				If (Mobj.bIsMonster) Chance -= 10;
				If (Mobj.Player) Chance -= 40;
				Continue;
			}
			
			//Actor can see through smoke grenades, because it's an NPC that's unfazed by SHADOWBLOCK.
			If (Flags & ABQ_Smokescreen && IsHostile && IsVisible && !(!Mobj.bSeeInvisible || Mobj.bShadowAim || Mobj.Player) && (Mobj.Player || Mobj.bDoShadowBlock))
				Continue;
			
			If (IsHostile)
				ViableEnemies++;
			
			If (Flags & ABQ_Infight && IsHostile && IsVisible && Mobj.OkayToSwitchTarget (Origin))
				{Chance += ViableEnemies; //Give an additional bonus if the monster can infight with the target, based on every additional monster in range.
			console.printf ("%s can infight with %s, so the chance is now %d",mobj.getclassname(),origin.getclassname(),chance);}
			If (IsHostile && IsVisible && Mobj.Distance3DSquared (Origin) <= Range*Range)
			{a_log ("checking an actor to blast to shit");
				Switch (AssessThreatLevel (Mobj))
				{
					Case THREAT_UNSTOPPABLE:
						Chance += 500;
						Break;
					Case THREAT_SUPERDANGER:
						Chance += 200;
						Break;
					Case THREAT_VERYDANGEROUS:
						Chance += 80;
						Break;
					Case THREAT_DANGEROUS:
						Chance += 40;
						Break;
					Case THREAT_ABOVENORMAL:
						Chance += 20;
						Break;
					Case THREAT_NORMAL:
						Chance += 10;
						Break;
					Case THREAT_MILD:
						Chance += 8;
						Break;
					Case THREAT_LOW:
						Chance += 5;
						Break;
					Case THREAT_VERYLOW:
						Chance += 1;
						Break;
					Case THREAT_NONE:
						Break;
					Default:
						Chance += 1;
						Break;
				}
			}
		}
		
		Return Chance;
	}
	
	//Search for dangerous enemies around you.
	Bool IsDangerNearby (Double Range = 1024)
	{return false; //DEBUG
		If (Target && CheckSight (Target, SF_IGNOREWATERBOUNDARY)) //My target is visible, that's an enemy.
			{a_log ("IsDangerNearby(): Found target");Return True;}
		
		For (Int pn = 0; pn < MAXPLAYERS; pn++)  //An enemy player is visible, now THAT'S an enemy.
		{
			If(!PlayerInGame[pn])
				Continue;
			PlayerInfo plr = Players[pn];
			
			If (Plr && !IsFriend (Plr.Mo) && CheckSight(Plr.Mo,SF_IGNOREWATERBOUNDARY))
				{a_log ("IsDangerNearby(): Found enemy player");Return True;}
		}
		
		//Look for dangerous enemies.
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || IsInanimateObject(Mobj) || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			a_log ("IsDangerNearby(): Found random enemy NPC");
			Return True;
		}
		
		Return False;
	}
	
	//====|Non-AI functions|====\\
	//Handles the coloring of the marines. And if the string says "Random" returns a random available color string.
	String SM_HandleMarineColoring (String WhatColor)
	{
		If (!WhatColor || WhatColor ~== "") Return WhatColor; //Don't run the code if the string is empty.
		
		//Handles the random color choice that is performed if the color name given is "Random".
		If (WhatColor ~== "Random")
		{
			Static Const String ColorArray[] = {"Red","Gray","White","Black","Blue","Yellow","Orange","Pink","DarkGreen","DarkRed","Default"}; //Contains all the valid color names.
			
			WhatColor = ColorArray[Random(0,ColorArray.Size()-1)]; //Randomly picks a color string.
		}
		
		If (!(WhatColor ~== "Default"))
			A_SetTranslation (String.Format("Marine_%s", WhatColor));
		Else
			A_SetTranslation ('');
		
		Return WhatColor;
	}
	
	//Change what sprite frame to display based on the marines' pitch.
	Int SM_UpdateElevation (Int Down, Int Straight, Int Up, Int KneelDown = -1, Int KneelStraight = -1, Int KneelUp = -1, Int LyingDown = -1)
	{
		If (Crouching) //Don't update if crouching, since the marine has no aim sprites when crouching, obviously.
			Return CurState.Frame;
		
		If (MarineState & MARINE_LYINGDOWN)
			Return LyingDown;
		
		If (!(MarineState & MARINE_KNEELING))
		{
			If (Pitch <= -15)
				Return Up;
			Else If (Pitch >= 10)
				Return Down;
		}
		Else
		{
			If (Pitch <= -15)
				Return KneelUp;
			Else If (Pitch >= 10)
				Return KneelDown;
		}
		
		If (!(MarineState & MARINE_KNEELING))
			Return Straight;
		Else
			Return KneelStraight;
	}
	
	//Update height based on marine state, used when the marine is firing while kneeling or lying down, and in the future when crouching.
	Void SM_UpdateHeight ()
	{
		If (Crouching) Return; //Crouching doesn't need updating from here, that's SM_HandlingCrouching()'s job.
	a_log ("running height update");
		If (MarineState & MARINE_KNEELING)
			{a_log ("the marine is kneeling");A_SetSize (newheight:32);}
		Else If (MarineState & MARINE_LYINGDOWN)
			{a_log ("the marine is lying down");A_SetSize (newheight:8);}
		Else
			{a_log ("no height change");A_SetSize (newheight:Default.Height);}
	}
	
	Void SM_FireBullet ()
	{
	If (MarineState & MARINE_KNEELING)
			a_log ("debug: the marine is kneeling");
		If (MarineState & MARINE_LYINGDOWN)
			a_log ("debug: the marine is lying down");
		A_StartSound ("Marine/Fire",CHAN_WEAPON);
		Double FireHeight = 42;
		Double Recoil = 0.25;
		If (MarineState & MARINE_KNEELING)
		{
			FireHeight = 32;
			Recoil /= 2;
		}
		Else If (MarineState & MARINE_LYINGDOWN)
		{
			FireHeight = 14;
			Recoil/= 3;
		}
		If (Crouching) //This should probably just be a MarineState instead of a variable lol.
		{
			FireHeight = 25;
			Recoil/= 3;
		}
		
		Actor Bullet = A_SpawnProjectile ("SM_Bullet",FireHeight,-6,flags:CMF_AIMDIRECTION,Pitch);
		Double AccuracyBuff = SM_IsCrouched() ? 0.5 : 1.0; //Double the accuracy if the marine is sitting down and firing.
		Switch (AttackType)
		{
			Case FIRE_BURST:
				AddProjectileSpread (Bullet,(1.1,-1.1)*AccuracyBuff,(1.1,-1.1)*AccuracyBuff);
				Break;
			Case FIRE_SINGLE:
				AddProjectileSpread (Bullet,(0.4,-0.4)*AccuracyBuff,(0.4,-0.4)*AccuracyBuff);
				Break;
			Case FIRE_FULLAUTO:
				AddProjectileSpread (Bullet,(2.2,-2.2)*AccuracyBuff,(2.2,-2.2)*AccuracyBuff);
				A_Recoil (Recoil);
				Break;
		}
		A_SpawnItemEx ("SM_BulletCasing",0,-6,FireHeight,FRandom (0,-1),FRandom (-4,-8),FRandom(1,5));
		AmmoCount--;
	}
	
	//End the marines' firing sequence. Used by both the Fire.End: state, and when the marine abruptly dies.
	Void SM_EndFiring()
	{
		SM_SetMarineState (0,MARINE_FIRING|MARINE_THROWING|MARINE_MELEE|MARINE_KNEELING|MARINE_LYINGDOWN);
		If (!IsDead(Self)) NextFireDelay = GameTicRate*Random(2,4); //Only add the timer if you didn't stop shooting by dying.
		AimTimer = BurstCounter = BurstSize = 0; //Reset aim and burst counters.
		AttackType = FIRE_BURST; //Reset to default fire mode.
		SM_UpdateHeight();
	}
	
	//KLUDGE: Because LineTrace() is fucking broken and refuses to find solid 3D floors.
	F3DFloor SM_Find3DFloorInFrontOfMe (Double Dist, Int Iterations = 4)
	{
		F3DFloor FFloor;
		Let FFloorCheck = New ("SM_Find3DFloor");
		FFloorCheck.HitSwimmable = True; //We only care for swimmable floors.
		
		//Iterate the trace this many times across the marines' height, more iterations allow for higher detail in the 3D floor detection when he collides, but have more overhead.
		Double Spacing = Height/Iterations;
		Double HeightOffset = Height;
		For (Int I = Iterations; I > 0; I--)
		{
			//Console.Printf ("Ran a 3D floor check at %.2f, the spacing is %.2f",HeightOffset, Spacing);
			FFloorCheck.Trace (Pos.PlusZ(HeightOffset),CurSector, (AngleToVector(Angle, Cos(0)), -Sin(0)) ,Dist,0);
			
			If (FFloor = FFloorCheck.Results.FFloor)
			{//a_log ("3d floor check passed");
				FSpawnParticleParams P; P.Color1 = "Green"; P.Style = STYLE_None; P.Lifetime = 35; P.Size = 2; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
				KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(HeightOffset),FFloorCheck.Results.HitPos,FFloorCheck.Results.Distance,0.5,p);
				FFloorCheck.Destroy();
				Return FFloor;
			}
			FSpawnParticleParams P; P.Color1 = "Red"; P.Style = STYLE_None; P.Lifetime = 35; P.Size = 2; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
			KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(HeightOffset),FFloorCheck.Results.HitPos,FFloorCheck.Results.Distance,0.5,p);
			HeightOffset -= Spacing;
		}
		
		FFloorCheck.Destroy();
		Return FFloor;
	}
}

//Find the marines target in the line of fire, otherwise assume the LOF is bad.
Class SM_FindTargetInLOF : KAI_LOFRaycast
{
	Override ETraceStatus TraceCallback ()
	{
		If (Other && Results.HitActor == Other)
		{console.printf ("SM_FindTargetInLOF: %s found",Other.GetClassName());
			BadLOF = False;
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

//KLUDGE: Apparently LineTrace()'s LineTracer must be fucking broken because it does NOT return the 3D floor it found.
//Find and return the first 3DFloor you hit.
Class SM_Find3DFloor : KAI_LOFRaycast
{
	Bool HitSwimmable; //Hit swimmable 3D floors too.
	Override ETraceStatus TraceCallback ()
	{
		If (HitSwimmable && Results.Crossed3DWater)
		{
			console.printf ("hit swimmable water at %d %d %d",results.crossed3dwaterpos);
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

//KLUDGE: Copied from the MVPs' UniversalFunctions mixin. Because they are supposed to work independent of each other.
Mixin Class SM_SplashFunctions
{
	Enum LiquidTypes
	{
		LIQUID_NONE = 0,
		LIQUID_WATER = 1,
		LIQUID_NUKAGE = 2,
		LIQUID_BLOOD = 3,
		LIQUID_LAVA = 4,
		LIQUID_SLIME = 5
	};
	
	Int CheckLiquid (TextureID Texture)
	{
		/*===============================================================
		This class stores the names of the different textures used for each type of liquid.
		These lists can be expanded as seen fit for your project, in case it has additional custom water/nukage/blood/lava/slime textures.
		The lists already contain some names of liquid flats that don't exist in the vanilla game, for built-in mod compatibility.
		Such as by having waterfall textures that don't exist like WFALL# and NFALL#.
		===============================================================*/
		Static Const String WaterTextures[] = {"FWATER1", "FWATER2", "FWATER3", "FWATER4", "WFALL1", "WFALL2", "WFALL3", "WFALL4"};
		Static Const String NukageTextures[] = {"NUKAGE1", "NUKAGE2", "NUKAGE3", "NFALL1", "NFALL2", "NFALL3", "NFALL4"};
		Static Const String BloodTextures[] = {"BLOOD1", "BLOOD2", "BLOOD3", "BFALL1", "BFALL2", "BFALL3", "BFALL4"};
		Static Const String LavaTextures[] = {"LAVA1","LAVA2", "LAVA3", "LAVA4", "DBRAIN1", "DBRAIN2", "DBRAIN3", "DBRAIN4", "LFALL1", "LFALL2", "LFALL3", "LFALL4"};
		Static Const String SlimeTextures[] = {"SLIME01","SLIME02", "SLIME03", "SLIME04", "SLIME05","SLIME06", "SLIME07", "SLIME08", "SFALL1", "SFALL2", "SFALL3", "SFALL4"};
		
		For (Int I = 0; I < WaterTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (WaterTextures[I]) == Texture)
				Return LIQUID_WATER;
		For (Int I = 0; I < NukageTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (NukageTextures[I]) == Texture)
				Return LIQUID_NUKAGE;
		For (Int I = 0; I < BloodTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (BloodTextures[I]) == Texture)
				Return LIQUID_BLOOD;
		For (Int I = 0; I < LavaTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (LavaTextures[I]) == Texture)
				Return LIQUID_LAVA;
		For (Int I = 0; I < SlimeTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (SlimeTextures[I]) == Texture)
				Return LIQUID_SLIME;
		
		Return LIQUID_NONE;
	}
	
	//Allows to quickly set up a spawned liquid splash, and then returns a pointer the splash to allow for further modifications, like making it visually larger or calling A_QuakeEx from it.
	Actor SpawnLiquidSplash (Int LiquidType = LIQUID_WATER, Sound SplashSound = "SFX/LiquidExplosion", Double Volume = 1.0, Double Attenuation = 0.5,
	Int ExplosionDamage = 0, Double ExplosionRadius = 0, Double FullDamageRadius = 0, Name DamageType = "", Bool DontHarmSource = False)
	{
		Actor Splash = Spawn ("SM_LiquidSplash",Pos);
		
		If (Splash)
		{
			//Set the shooter of the projectile for DontHarmSource to work.
			If (bMissile)
				Splash.Target = Target; //Projectiles store their shooter in the target pointer, so transfer the shooter to the splash.
			Else
				Splash.Target = Self; //Otherwise set the shooter to the actor calling the function, if it's not a projectile somehow.
			
			SM_LiquidSplash(Splash).LiquidType = LiquidType;
			SM_LiquidSplash(Splash).SplashSound = SplashSound;
			SM_LiquidSplash(Splash).Volume = Volume;
			SM_LiquidSplash(Splash).Attenuation = Attenuation;
			SM_LiquidSplash(Splash).RadiusDamage = ExplosionDamage;
			SM_LiquidSplash(Splash).MaxTargetRange = ExplosionRadius;
			SM_LiquidSplash(Splash).MeleeRange = FullDamageRadius;
			SM_LiquidSplash(Splash).ExplosionDamageType = DamageType;
			SM_LiquidSplash(Splash).DontHarmSource = DontHarmSource;
			Return Splash;
		}
		
		Return Null;
	}
	
	F3DFloor FindWaterBelow (Double Distance = 8)
	{
		Let WaterCheck = New ("SM_Find3DFloor");
		WaterCheck.HitSwimmable = True; //We only care for swimmable floors.
		
		WaterCheck.Trace (Pos,CurSector,(0,0,-1),Distance,0);
		Let FFloor = WaterCheck.Results.Crossed3DWater;
		//If (HitPos != HitPos) HitPos = WaterCheck.Results.Crossed3DWaterPos;
		WaterCheck.Destroy();
		Return FFloor;
	}
}