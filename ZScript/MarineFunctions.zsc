Extend Class SM_Marine
{
	Enum MarineChaseFlags
	{
		SMC_NOUSESTATE		= 1 << 0, //The marine will not wait in his interact state after using a line with no threat around.
		SMC_IGNOREHAZARDS	= 1 << 1, //The marine ignores any nearby hazards.
		SMC_NOCOVERSTOP		= 1 << 2, //The marine doesn't stop moving when in cover.
	}
	//Unlike in the original Smart Marines, this is VERY MUCH a custom function.
	Void SM_Chase (StateLabel WaitState = Null, StateLabel RetreatState = Null, Int Flags = 0, Int ChaseFlags = 0, Double TurnRadius = 25)
	{
		//Very marine specific things
		If (BurstCounter) BurstCounter = 0; //Reset the burst fire countdown when not firing. Like if the marine is hurt mid-burst.
		bNoFriction = Default.bNoFriction; //Reset the friction flag to the default, in case the marine begun firing or something mid-jump.
		HealTarget = Null;
		
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		
		//ZScript exports of different segments of GZDooms' native AI code. This is the stuff not needed for movement.
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_Chase_FriendsAttackPlayerEnemies(ChaseFlags);
		KAI_Chase_Retarget(ChaseFlags,True); //Friendly marines go idle with no target too.
		KAI_Chase_HandleActiveSound(ChaseFlags); //MAYDO: Remove this ?
		
		Bool MovedAlready;
		Double MajorThreatRange = 1536*1536;//(RetreatRange*4)*(RetreatRange*4);
		
		If (!(ChaseFlags & CHF_DONTMOVE)) MovedAlready = SM_RunFromHazards(); //Avoid any major hazards.
		
		If (!(Flags & SMC_NOCOVERSTOP) && MarineState & MARINE_INCOVER) //Don't move when in cover.
			ChaseFlags |= CHF_DONTMOVE;
		
		//Run away from major actor threats.
		If (bNoFear && Target && !(Goal && bChaseGoal))
		{
			If (!(ChaseFlags & CHF_DONTMOVE) && !MovedAlready)
			{
				//If you can't attack (But not because you are in a NOATTACK sector), run. Also run if the other actor is frightening or you're frightened.
				If ((!CanAttack() && !(CurSector.Flags & Sector.SECF_NOATTACK)) || bFrightened || IsFrightening (Target) ||
				//If the targets' threat level is over the threshold, and it's visible and nearby, GTFO.
				ThreatLevelThreshold != THREAT_ASSESS && AssessThreatLevel(Target, True) >= ThreatLevelThreshold && (Distance3DSquared(Target) < MajorThreatRange))
				{
					//And at last, check if the target is still visible.
					If (CheckSight (Target, SF_IGNOREWATERBOUNDARY))
					{
						If (!RetreatState)
							KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
						Else
							SetStateLabel (RetreatState);
						MovedAlready = True;
						Return;
					}
				}
			}
		}
		
		Bool UsedLine;
		//If you can move and haven't done so already.
		If (!(ChaseFlags & CHF_DONTMOVE))
		{
			//Only update the nearest enemy to run from when not focused on a route.
			If (bAvoidMelee && !(IsPatrolling(Self) && bChaseGoal)) NearestEnemy = FindNearestEnemy (128); //TODO: Unhardcode the retreat range probably.
			//If you aren't patrolling and not allowed off your route, and there is an enemy nearby.
			If (bAvoidMelee && NearestEnemy)
			{
				If (!RetreatState)
					KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
				Else
					SetStateLabel (RetreatState);
				MovedAlready = True;
				//Return; //Might still melee you.
			}
			//Actual movement handling.
			Else
			{
				Bool B;
				KAI_Chase_HandleStrafing (Target,ChaseFlags);
				[B,MovedAlready] = KAI_Chase_PatrolHandling(WaitState, 0.2, anglelimit:TurnRadius, chaseflags:ChaseFlags);
				
				/*If there is no danger in sight, the marine will wait for lines he used like doors and platforms to move. Instead of moving around like a
				normal monster. However, if there IS danger nearby, the marine will keep moving after using the line like normal.*/
				Int NoStockUse;
				If (!IsDangerNearby())
				{
					NoStockUse = KMT_NOLINEUSE;
					UsedLine = SM_MarineUseLine(faceline:!(Flags & SMC_NOUSESTATE)); //Check if there's a line in front of use to use.
				}
				
				//Crouching comes first.
				Crouching = KAI_HandleCrouching(Default.Height,MARINE_CROUCHHEIGHT);
				
				If (!Crouching)
				{
					If (KAI_HandleClimbing(ClimbPos,JumpPos,"Climb","Jump.Up",1.1,1.75))
						MovedAlready = True;
				}
				
				Vector2 JumpPosition = KAI_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
				If (JumpPosition == JumpPosition && !Crouching) //We have a valid position we must jump to, AKA the returned vector isn't null.
				{
					JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
					Bool Reachable = True; //Assume we can jump there by default.
					//The jump destination is longer than half the jump distance, so do a long jump if there's space behind you for it.
					If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5 && (Reachable = SM_CanRunBack()))
					{
						PreJumpPos = Vec3Angle(256,Angle-180);
						SetStateLabel ("Jump.Running");
						MovedAlready = True;
					}
					Else If (Reachable) //If the gap is too short to do a running jump, do a normal one, but don't fall back to normal jumps for large gaps.
					{
						SetStateLabel ("Jump");
						MovedAlready = True;
					}
				}
				
				//Finally, if you do have a target, DO move towards it, but with KAI_MoveTowards instead of the shitty native movement code.
				If (Target && !MovedAlready)
					KAI_MoveTowards (Target.Pos, 0.5, TurnRadius, ChaseFlags, KMT_CHASEGOAL|KMT_ZIGZAG|NoStockUse);
			}
		}
		
		SM_UpdateChaseTimer();
		ShouldAttack(); //Run attack decision code.
		
		If (!(Flags & SMC_NOUSESTATE) && UsedLine) 
			SetStateLabel ("Interact");
		
		//If you are set to not automatically idle, only do it when the timer is over the threshold.
		If (ChaseFlags & CHF_DONTIDLE && ChaseTimer >= MARINE_CHASETIME)
		{
			A_ClearTarget();
			ChaseTimer = 0;
			SetIdle();
		}
	}
	
	//Marine will run away from major hazards.
	//Unless it's patrolling and sticking to his path, and even then, he will still run if the hazard is like, a nuke or something.
	Bool SM_RunFromHazards (Bool NoJump = FaLse)
	{
		If (HazardToAvoid && ( !(Goal && bChaseGoal) || HazardToAvoid.Level >= HazardInfo.HAZARD_HUGE ) && SM_ShouldRunFromHazard(HazardToAvoid) == RUN_FAST)
		{
			//The amount of loops is the distance to the hazard divided by distance travelled by one retreat sequence + some change.
			Double RetreatDist = Speed*12; //12 movement calls in one Retreat loop.
			RetreatPos = GetHazardOriginPos (HazardToAvoid);
			RetreatLoops = Int(GetHazardDistance(HazardToAvoid) / RetreatDist)+1;
			
			//Run a bit extra further for shrapnel.
			Bool IsGrenade, HasShrapnel;
			ForEach (CurTag : HazardToAvoid.CustomTags)
			{
				If (CurTag ~== "Grenade")
					IsGrenade = True;
				If (CurTag ~== "Shrapenl")
					HasShrapnel = True;
			}
			If (IsGrenade && HasShrapnel)
				RetreatLoops++;
			
			console.printf ("marine breaking action to run %d times away from hazard %p",retreatloops,hazardtoavoid);
			HAZARDTOAVOID.PRINTHAZARDINFO();
			If (!NoJump) SetStateLabel ("Retreat");
			Return True;
		}
		Return False;
	}
	
	Bool SM_UpdateCover (Actor Other, Bool IsCrouchingAlready)
	{
		FLineTraceData EyeLevel, HipLevel;
		Bool EyeLevelUnblocked, HipLevelBlocked;
		Int HasHit;
		Actor Mobj;
		
		//Don't crouch if Who is invalid or are patrolling.
		If (!Other || IsPatrolling (Self))
			{console.printf ("SM_UpdateCover(): no other actor or patrolling");Return False;}
		
		//If the other actor is this close to you, you probably can't crouch.
		If (Distance3DSquared(Other) <= 72*72)
			{console.printf ("SM_UpdateCover(): other is too close to take cover.");Return False;}
		
		/*
		This fires two raycasts from the marines' eyes and hips. Then the Eye and HipLevelBlocked booleans return true or false.
		Based on whether or not they hit any level geometry before stopping. The distance that the raycasts travel double when
		the marine is already crouched, so they don't get out of cover even when their target hasn't breached said cover.
		*/
		
		If (!IsCrouchingAlready)
			LineTrace (AngleTo (Other),48,PitchTo(Other,50,Other.Height/2),0,50,data:EyeLevel);
		Else
			LineTrace (AngleTo (Other),128,PitchTo(Other,50,Other.Height/2),0,50,data:EyeLevel);
		
		EyeLevelUnblocked = SM_EyeLevelClear (EyeLevel);

		If (!IsCrouchingAlready)
			LineTrace (AngleTo (Other),48,PitchTo(Other,18,Other.Height/2),TRF_THRUHITSCAN,18,data:HipLevel);
		Else //Run a longer range trace when crouched to not go out of cover as easily when behind strangely shaped cover like star shaped fountains.
			LineTrace (AngleTo (Other),128,PitchTo(Other,18,Other.Height/2),TRF_THRUHITSCAN,18,data:HipLevel);
		
		HasHit = HipLevel.HitType;
		Mobj = HipLevel.HitActor;
		
		KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(18),EyeLevel.HitLocation,EyeLevel.Distance);
		KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(18),HipLevel.HitLocation,HipLevel.Distance);
		
		//Only take cover behind large enough actors that aren't other NPCs or players. And aren't about to break.
		If ((HasHit == TRACE_HitWall || HasHit == TRACE_HitFloor || HasHit == Trace_HitCeiling) ||
		(Mobj && !(Mobj.bIsMonster || Mobj.Player) && Mobj.Radius >= Radius && Mobj.Height < 40 && Mobj.Health >= 40))
			HipLevelBlocked = True;
		
		Bool OtherInSight = CheckSight (Other,SF_SEEPASTSHOOTABLELINES|SF_IGNOREWATERBOUNDARY);
		//Only run this if the marine is not crouched already.
		If (!IsCrouchingAlready)
			If (EyelevelUnblocked && HipLevelBlocked && OtherInSight)
				{console.printf ("SM_UpdateCover(): marine can take cover");Return True;}
		
		//If you are crouching already and have a line of sight to the other actor.
		If (IsCrouchingAlready && OtherInSight)
			//Then return if you can crouch based on whether or not your hips are blocked by cover still.
			{if (hiplevelblocked) console.printf ("SM_UpdateCover(): marine can no longer hide behind here");Return HipLevelBlocked;}
		
		If (!OtherInSight && Random (0,255) < 4) //If the other actor is out of sight, the marine will eventually give up staying behind cover.
			Return False;
		
		//If none of the other checks are true, but you are crouching already, then just assume you can keep doing so.
		If (IsCrouchingAlready)
			Return True;
		console.printf ("SM_UpdateCover(): All checks failed, turning off.");
		Return False;
	}
	
	//Clean wrapper for the eye level checks, copied from the original code and probably unnecessary.
	Bool SM_EyeLevelClear (FLineTraceData Data)
    {
        Int HasHit;
        
        HasHit = Data.HitType;
		
        If (Data.HitActor || HasHit == TRACE_HitWall || HasHit == TRACE_HitFloor || HasHit == Trace_HitCeiling)
            Return False;
        
        Return True;
    }
	
	Bool SM_CheckFOV (Actor Viewer, Actor Other, Double FOV)
	{
		Vector3 CameraPos;
		If (Viewer.Player)
			CameraPos = (Viewer.Player.Camera.Pos.XY,Viewer.Player.ViewZ);
		Else
			CameraPos = (Viewer.Pos.XY,Viewer.GetCameraHeight());
		
		If (Viewer.Player)
		{
			Double d1, d2, ViewWidth, ViewHeight;
			[d1,d2,ViewWidth,ViewHeight] = Screen.GetViewWindow();
			console.printf ("width %d, height %d",viewwidth,viewheight);
			FOV = FOV * (ViewWidth / ViewHeight);
		}
		
		Vector3 Coords = Level.SphericalCoords (CameraPos,Other.Pos.PlusZ(Other.Height/2),(Viewer.Angle,Viewer.Pitch));
		console.printf ("%s is in the %d FOV of %s, coords.z is %f, coords.x is %f, inverse square %f",other.getclassname(),fov/2,viewer.getclassname(),coords.z,coords.x,(Abs(Coords.X) / (Coords.Z * Coords.Z)));
		If (Abs(Coords.X) <= FOV/2)
		{a_log ("we passed");
			Return True;
		}
		Return False;
	}
	
	Bool SM_CanRunBack()
	{
		Vector3 RealPos = Pos;
		Bool Moved = IsPosReachable (Vec3Angle(256,Angle-180)); //Doesn't use the SM_ wrapper since it's supposed to be one continuous running leap.
		If (Moved)
		{
			SetOrigin (Vec3Angle(256,Angle-180),False);
			Moved = IsPosReachable (Vec3Angle(256,Angle));
			SetOrigin (RealPos,False);
		}
		Return Moved;
	}
	
	//Increment the chase timer as long as the target is nonexistent, dead, or out of sight. And reset it if any of these conditions are false.
	Void SM_UpdateChaseTimer()
	{
		If (IsPatrolling(Self)) //Ignore this if we are following a goal.
			ChaseTimer = 0;
		Bool Dead = IsDead(Target);
		If (!Target || Target && (Dead || !CheckSight(Target,SF_IGNOREWATERBOUNDARY)))
			ChaseTimer++;
		Else
			ChaseTimer = 0;
		If (!Target || Dead) ChaseTimer++; //Decrement the timer extra fast if the target is just flat out gone.
		//Console.Printf ("SM_UpdateChaseTimer(): Time is %d",ChaseTimer);
	}
	
	//Marines use lines in front of them.
	//IDEA: Make the marine detect doors or platforms in front of him, then if it's switch activated, search for nearby switches he can go up to and use. Dynamically.
	Sector UseSec;
	Bool SM_MarineUseLine (Double UseRange = 64, Bool FaceLine = False)
	{
		InteractWaits = 0; //Reset it here just in case.
		//Let LineSearch = BlockLinesIterator.Create (Self,Radius+64);
		//Count pushable lines as uses too.
        If (bCanPushWalls && BlockingLine && BlockingLine.Special && BlockingLine.Activate (Self,0,SPAC_Push))
		{
			//If (FaceLine) Angle = GetAngleToPos ((GetLinePos(BlockingLine),0));
			UseSec = GetLiftOrDoorSector(BlockingLine);//BlockingLine.BackSector;
			Return True;
		}
		
		If (!bCanUseWalls) Return False;
		FLineTraceData Usage;
		
		LineTrace (Angle,UseRange,0,TRF_BLOCKUSE,Height/2,data:Usage);
		
		FSpawnParticleParams P; P.Color1 = "Pink"; P.Style = STYLE_None; P.Lifetime = 1; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
		KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(Height/2),Usage.HitLocation,Usage.Distance,4,p);
		
		//Used a line in front of us.
		Line UseLine = Usage.HitLine;
		If (UseLine && UseLine.Special && UseLine.Activate (Self,Usage.LineSide,SPAC_Use))
		{
			//If (FaceLine) Angle = GetAngleToPos ((GetLinePos(UseLine),0));
			UseSec = GetLiftOrDoorSector(UseLine);//UseLine.BackSector;
			a_log ("a marine ran his custom line use function");
			Return True;
		}
		
		Return False;
	}
	
	//Gets the lift or door sector from the built in sector specials, instead of assuming the back sector is the door or lift, just in case.
	Sector GetLiftOrDoorSector (Line TheLine)
	{
		Sector Result;
		//Generally, it seems that args[0] is the tag of the affected sector. So this is what we assume.
		Switch (TheLine.Special)
		{
			Case 11: //Door_Open
			Case 12: //Door_Raise
			Case 21: //Floor_LowerToNearest
			Case 202: //Door_Generic
			Case 105: //Door_WaitRase
			Case 203: //Generic_Lift
			{
				Let TagIter = Level.CreateSectorTagIterator (TheLine.Args[0],TheLine);
				Result = Level.Sectors[TagIter.Next()];
				Break;
			}
		}
		
		If (TheLine.Args[0] == 0)
			Return TheLine.BackSector;
		
		Return Result;
	}
	
	//KLUDGE: Sector.PlaneMoving doesn't work, despite doing the same thing as this. So we have to use this, epic.
	Bool SM_SectorInMotion (Sector Sec)
	{
		If (!Sec)
			Return False;
		
		If (Sec.FloorData || Sec.CeilingData)
			Return True;
		
		Return False;
	}
	
	//Get the middle point of a line.
	//KLUDGE: GZDoom really doesn't like this formula I found on the Unreal Engine forum. Probably because it's too straightforward for its' esoteric tastes.
	Vector2 GetLinePos (Line TheLine)
	{
		If (!TheLine)
			Return (Double.NaN, Double.NaN);
		
		Return ((TheLine.V2.P - TheLine.V1.P) * 0.5 + TheLine.V1.P); 
	}
	
	//KAI_MoveAway wrapper.
	//MAYDO: Try and add code to make marines avoid smashing right into obstables ?
	Void SM_RunAway (Actor Other, Double RunRad = 64, Int MaxSteps = 32, Double TurnRadius = 25, Int ChaseFlags = 0, Int Flags = 0)//, Int KMAFlags = 0)
	{
		Crouching = KAI_HandleCrouching(Default.Height,MARINE_CROUCHHEIGHT);
		
		If (!Crouching && KAI_HandleClimbing(ClimbPos,JumpPos,"Climb","Jump.Up",1.1,1.75))
			Return;
		
		Vector2 JumpPosition = KAI_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
		If (JumpPosition == JumpPosition && !Crouching) //We have a valid position we must jump to, AKA the returned vector isn't null.
		{
			JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
			//The jump is longer than half the max jump distance, normally we do a running jump, but since we are presumably running for our lives, don't bother.
			If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5)
				Return;
			Else
			{
				SetStateLabel ("Jump");
				Return;
			}
		}		
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		
		KAI_MoveAway (Other, 16, RunRad, MaxSteps, 0.5, TurnRadius, ChaseFlags, Flags, KMA_USECORNERS, RetreatPos);
	}
	
	//Returns true if the marine is down on the ground in some capacity, as opposed to standing up.
	Bool SM_IsCrouched()
	{
		Return (Crouching || MarineState & (MARINE_KNEELING|MARINE_LYINGDOWN|MARINE_INCOVER));
	}
	
	//DECORATE-esque function for use in states.
	Void SM_SetMarineState (Int Add, Int Remove, Bool RemoveAll = False, Int Exceptions = 0/*, Int Action = 0*/)
	{
		If (!RemoveAll)
			MarineState &= ~Remove;
		Else
		{
			If (!Exceptions)
				MarineState = 0;
			Else
				MarineState &= Exceptions; //Remove all bits, excepts the ones passed in the Exceptions bitfield.
		}
		MarineState |= Add;
	}
	
	//Credit: Lewisk3
	void SM_FireGrenade(Actor toAct, class<Actor> nade, double maxPitch = 90, double aimSens = 1.0, double aimDist = 128)
	{
		if(!toAct) return;
		
		// Source and Destination
		vector3 fromPos = (
			pos.xy,
			pos.z + (height)
		);
		vector3 toPos = (
			toAct.pos.xy, 
			toAct.pos.z + (toAct.height * 0.5) 
		);
		
		vector3 diff = level.vec3diff(fromPos, toPos);
		
		// Spawn grenade, calculate values from instance.
		let nade = Spawn(nade, fromPos);
		if(!nade) return;    
		nade.target = self;
		
		// Modify toPos Z component based on how many units the thrown grenade
		// fall by the time it reaches the destination.
		double dist = diff.xy.Length();
		if(dist >= aimDist)
		{
			double grav = 1.0 + ceil(nade.GetGravity() * (level.gravity * 0.010769));
			double ticsDist = diff.Length() / double(max(nade.Speed,1.0));        
			double fallDist = ticsDist * grav;
			toPos.z += fallDist * aimSens;
		}
		
		// Recalculate differences.
		diff = level.vec3diff(fromPos, toPos);
		double aimPitch = VectorAngle( sqrt(diff.y*diff.y + diff.x*diff.x), diff.z );
		aimPitch = min(aimPitch, maxPitch);
		
		// Modify grenade velocity
		double a = AngleTo(toAct);
		double p = -aimPitch;
		nade.vel = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * nade.Speed;
	}
	
	State SM_CheckRefire (Int Chance, StateLabel AbortState, Double FOV = 360)
	{
		If (CurSector.Flags & Sector.SECF_NOATTACK)
			Return FindState (AbortState);
		
		AimPos = GetFAFAimPos (Target);
			
		If (Random2[pr_monsterrefire]() < Chance)
			Return State (Null);
		
		If (!Target || IsDead (Target) || (Target && !CheckFOV (Target,FOV)))
			{a_log ("marine refire cancelled");Return FindState (AbortState);}
		
		Double OldHeight = Height;
		If (SM_IsCrouched())
			{console.printf ("uncrouching marine to properly do the refire check");Height = Default.Height;} //Uncrouch for the sight check.
		
		If (!CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES))
		{
			Height = OldHeight; a_log ("marine refire cancelled");
			Return FindState (AbortState);
		}
		Height = OldHeight;
		
		Return State (Null);
	}
	
	//Marines just fire SM_Bullet, so for now at least, so we mostly just need the trace offsets.
	Bool SM_CheckLOF (Vector3 CheckOffsets = (0,0,32), Int PropHealthThreshold = 25, Bool AimingAt = False)
	{
		Let Check = New ("KAI_ProjectileLOFCheck");
		
		AimPos = GetFAFAimPos (Target);
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Target)
			{
				Double PitchTo = PitchTo (Target,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Target), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Double Distance = !AimingAt ? MaxTargetRange : Distance3D (Target)+8;
		Check.Shooter = Self;
		Check.Other = Target;
		Check.PropHealthThreshold = PropHealthThreshold; //This can depend on factors like how many rounds the marine is firing.
		Check.FriendlyFire = True;
		
		Check.ProjInfo = New ('LOFProjInfo'); //Assign data class.
		Check.ProjInfo.Projectile = "SM_Bullet"; //Pass projectile class to trace.
		Check.ProjInfo.InitializeProjectileInfo(); //Let it infer the rest.
		
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Distance,0);
		
		FSpawnParticleParams Debug; Debug.Lifetime = 8;
		KAI_LOFRaycast.VisualizeTracePath (Level.Vec3Offset (Pos,CheckOffsets),Check.Results.HitPos,Check.Results.Distance,params:Debug);
		Bool BadLoaf = Check.BadLOF;
		If (Check.ProjInfo) Check.ProjInfo.Destroy();
		Check.Destroy();
		Return !BadLoaf;
	}
	
	Bool SM_FindInLOF (Actor Who, Vector3 CheckOffsets = (0,0,32), Bool AimingAt = False)
	{
		Let Check = New ("SM_FindTargetInLOF");
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Who)
			{
				Double PitchTo = PitchTo (Who,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Who), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Check.Shooter = Self;
		Check.Other = Who;
		Check.BadLOF = True; //We have to assume the LOF is bad, and if the trace finds the other actor, then it's a good LOF.
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,MaxTargetRange,0);
		Bool Res = Check.BadLOF;
		Check.Destroy();
		Return !Res;
	}
	
	//Get what part of the actor the marine is aiming at now.
	Double GetAimPosOffset ()
	{
		Switch (AimPos)
		{
			Case FAF_MIDDLE:
				Return Target.Height/2;
			Case FAF_TOP:
				Return Target.Height;
			Case FAF_BOTTOM:
				Return 0; //The bottom is the origin of actors.
			Default:
				Return 0;
		}
	}
	
	//Return what grenade type is likely currently appropriate against the enemy.
	Int DecideGrenadeType (Actor Against, Int Threshold = MARINE_GRENADECHANCE)
	{
		//Don't bother if the other actor doesn't exist, it's not time yet, or if the enemy flies and is over your head !
		If (!Against || GrenadeDelay || IsFlying (Against) && Pos.Z+Height < Against.Pos.Z) Return GRENADE_NONE;
		If (Distance3DSquared (Against) >= 768*768 || !SM_CheckLOF((0,0,Height),0)) //Not in throwing range. Or there is no direct LOF, yes, this doesn't account for arcing, I WILL NOT TRY.
			Return GRENADE_NONE;
		
		Bool ImmuneToBlasts = (Against.bNoRadiusDmg || Against.GetRadiusDamage (Against,256,256,128,False,True) <= 256/8); //The enemy is immune or HIGHLY resistant to blasts.
		Bool UseHE, UseSmoke;
		
		//Decide to throw the HE-FRAG grenade without the frag sleeve. Large blast radius and damage, good for strong enemies.
		//Based on RNG, if the target is super powerful, and if it's not effectively immune to pure explosion damage.
		If (!ImmuneToBlasts && (Random (0,255) < 96 || AssessThreatLevel (Against) >= ThreatLevelThreshold))
		{
			//Randomly decide to throw smoke, as long as the enemy CAN be affected by the smokescreen.
			If (Random (0,255) < 120 && (!Against.bSeeInvisible || Against.bShadowAim || Against.Player) && (Against.Player || Against.bDoShadowBlock))
				UseSmoke = True;
			Else
				UseHE = True;
		}
		
		//Now, let's check the chance of actually throwing a grenade.
		Int BulletDamage = Against.ApplyDamageFactor ("SmallRifleBullet",100); //Return how much damage the actor would actually take if 10 bullets did maximum damage.
		Int GrenChance = (Threshold > 0) ? Random (0,Threshold-24) : INT.MAX;
		Int PreGrenChance = GrenChance; //The grenade chance before being incremented by AttackByQuantity.
		Double BlastRadius = 192;
		If (Threshold > 0)
		{
			GrenChance += 100-BulletDamage; //Increase grenade chance based on how much bullet damage the enemy can absorb.
			If (Target.Speed <= 6 || Random (0,255) < 64) //Our target is quite slow, lets see about throwing a smoke grenade.
				GrenChance += SM_AttackByQuantity (Target,!UseHE ? 192 : 256,True,ABQ_Infight|ABQ_Smokescreen);
			Else
				GrenChance += SM_AttackByQuantity (Target,!UseHE ? 192 : 256,True); //Grenade chance is also based on crowd size.
		}
		
		If (GrenChance >= Threshold) //Decide if you should throw an HE or frag grenade.
		{
			If (UseHE)
				Return GRENADE_HE;
			Else If (UseSmoke)
				Return GRENADE_SMOKE;
			Else
				Return GRENADE_HEFRAG;
		}
		
		Return GRENADE_NONE;
	}
	
	//Prepare to throw a smoke grenade in front of you before retreating. That is to say like when running to reload.
	Bool PrepareForSmokeThrow (Int Chance = 48)
	{
		If (Target && Distance3DSquared (Target) <= 256*256) //If the target is too close, don't bother. Like if running away from a melee enemy.
			{A_LOG ("PrepareForSmokeThrow(): target is too close");Return False;}
		
		Chance += SM_AttackByQuantity (Target,flags:ABQ_Smokescreen); //Increase chance the more danger their is around.
		
		If (Health <= SpawnHealth()/3) //Extra chance if low on health.
			Chance += 30;
		
		If (Random (0,255) >= Chance)
			{console.printf ("a smoke chance of %d wasn't enough",chance);Return False;}
		
		//SM_SetMarineState (MARINE_RETREAT,MARINE_IDLING|MARINE_CHASING); //Specifies to the grenade drop state that the marine needs to retreat afterwards.
		GrenadeType = GRENADE_SMOKE;
		QuickGrenade = True;a_log ("throwing quick grenade and dipping.");
		Return True;
	}
	
	Enum ABQFlags
	{
		ABQ_Smokescreen = 1 << 0, //If on, ignore actors that can see through DOSHADOWBLOCK, unless they are players. 
		ABQ_Infight		= 1 << 1, //Give bonus points for monsters that can infight. Based on how many other monsters that can infight are found in Range.
	}
	
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks. Copied from the MVP !.
	//Range: The range around which to check for enemies.
	//AvoidAllies: Deduct points from the score for any allies in the AOE.
	//Smokescreen: This is a check for if the marine is throwing a smoke grenade. Makes actors that can see throw the smoke be ignored from the count.
	Int SM_AttackByQuantity (Actor Origin, Double Range = 256, Bool AvoidAllies = False, Int Flags = 0)
	{
		If (!Origin) Return 0;
		Actor Mobj;
		Int Chance;
		Bool IsHostile, IsVisible; //Caching
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Origin,Range);
		
		Int ViableEnemies;
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (!Mobj || IsDead (Mobj) || IsInanimateObject (Mobj) || Mobj == Self/* || Mobj == Origin*/) Continue;
			
			IsHostile = IsActorHostile (Mobj); IsVisible = IsVisible (Mobj,False);
			If (AvoidAllies && !IsHostile && IsVisible)
			{
				If (Mobj.bIsMonster) Chance -= 10;
				If (Mobj.Player) Chance -= 40;
				Continue;
			}
			
			//Actor can see through smoke grenades, because it's an NPC that's unfazed by SHADOWBLOCK.
			If (Flags & ABQ_Smokescreen && IsHostile && IsVisible && !(!Mobj.bSeeInvisible || Mobj.bShadowAim || Mobj.Player) && (Mobj.Player || Mobj.bDoShadowBlock))
				Continue;
			
			If (IsHostile)
				ViableEnemies++;
			
			If (Flags & ABQ_Infight && IsHostile && IsVisible && Mobj.OkayToSwitchTarget (Origin))
				{Chance += ViableEnemies; //Give an additional bonus if the monster can infight with the target, based on every additional monster in range.
			console.printf ("%s can infight with %s, so the chance is now %d",mobj.getclassname(),origin.getclassname(),chance);}
			If (IsHostile && IsVisible && Mobj.Distance3DSquared (Origin) <= Range*Range)
			{a_log ("checking an actor to blast to shit");
				Switch (AssessThreatLevel (Mobj))
				{
					Case THREAT_UNSTOPPABLE:
						Chance += 500;
						Break;
					Case THREAT_SUPERDANGER:
						Chance += 200;
						Break;
					Case THREAT_VERYDANGEROUS:
						Chance += 80;
						Break;
					Case THREAT_DANGEROUS:
						Chance += 40;
						Break;
					Case THREAT_ABOVENORMAL:
						Chance += 20;
						Break;
					Case THREAT_NORMAL:
						Chance += 10;
						Break;
					Case THREAT_MILD:
						Chance += 8;
						Break;
					Case THREAT_LOW:
						Chance += 5;
						Break;
					Case THREAT_VERYLOW:
						Chance += 1;
						Break;
					Case THREAT_NONE:
						Break;
					Default:
						Chance += 1;
						Break;
				}
			}
		}
		
		Return Chance;
	}
	
	HazardInfo GetNearestHazard (Array<HazardInfo> HazardList)
	{
		Double ClosestDist = INT.MAX;
		HazardInfo Closest;
		
		ForEach (CurHaz : HazardList)
		{
			If (CurHaz)
			{
				If (CurHaz.Flags & HazardInfo.HAZ_SECTOR) //The first hazard found in the same sector as you is the closest.
					Return CurHaz;
				
				Double Dist = GetHazardDistance (CurHaz);
				If (Dist < ClosestDist)
				{
					ClosestDist = Dist;
					Closest = CurHaz;
				}
			}
		}
		
		Return Closest;
	}
	
	Enum RunAwayTypes //How should the marine run from a dangerous hazard, if at all ?
	{
		RUN_NONE, //The marine doesn't need to run.
		RUN_WALK, //The marine should probably avoid it, but just walk around it if possible, since it's not that serious.
		RUN_FAST, //Stop what you are doing and run away. Original marine behavior to grenades and the old SM_ImInDanger token.
	}
	
	//How should the marine run away from this hazard zome, if at all ?
	RunAwayTypes SM_ShouldRunFromHazard (HazardInfo Hazard)
	{
		If (!Hazard || !bAvoidHazards)
			Return RUN_NONE;
		
		//Run away from actually dangerous threats, or if the hazard in question is weak but you are close to dying.
		If (Hazard.Level >= HazardInfo.HAZARD_MEDIUM || Hazard.Level != HazardInfo.HAZARD_HARMLESS && Health <= SpawnHealth()/3)
			Return RUN_FAST;
		
		//Dealing with a minor threat, so just walk around it if not doing anything else and not low on health.
		If (Hazard.Level < HazardInfo.HAZARD_MEDIUM && Hazard.Level != HazardInfo.HAZARD_HARMLESS)
			Return RUN_WALK;
		
		Return RUN_NONE;
	}
	
	//Search for dangerous enemies around you.
	Bool IsDangerNearby (Double Range = 1024)
	{
		If (Target && CheckSight (Target, SF_IGNOREWATERBOUNDARY)) //My target is visible, that's an enemy.
			{a_log ("IsDangerNearby(): Found target");Return True;}
		
		For (Int pn = 0; pn < MAXPLAYERS; pn++)  //An enemy player is visible, now THAT'S an enemy.
		{
			If(!PlayerInGame[pn])
				Continue;
			PlayerInfo plr = Players[pn];
			
			If (Plr && !IsFriend (Plr.Mo) && CheckSight(Plr.Mo,SF_IGNOREWATERBOUNDARY))
				{a_log ("IsDangerNearby(): Found enemy player");Return True;}
		}
		
		//Look for dangerous enemies.
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || IsInanimateObject(Mobj) || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			a_log ("IsDangerNearby(): Found random enemy NPC");
			Return True;
		}
		
		Return False;
	}
	
	//IDEA: Maybe add some kind of health sort, to pick the most frail or powerful ally ?
	Actor SM_FindAllyToHelp (Double Range = 1024, Int HealthThreshold = 7)
	{
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		Array <Actor> Friends; //Store nearby allies to potentially heal.
		Array <Actor> Marines; //And friendly marines too, to ignore allies another marine is going to anyway.
		Array <Actor> Players; //Store found players, so they take priority if they aren't targeted for healing to begin with.
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
		
			//If the ally is indestructible, not even alive, a prop, or hasn't lost more than 7 HP, we don't need to help them.
			If (!Mobj || Mobj == Self || IsIndestructible(Mobj) || IsInanimateObject (Mobj) || IsDead (Mobj) || SM_GetMaxHealth (Mobj)-HealthThreshold < Mobj.Health)
				Continue;
			
			If (Mobj.bNoBlood) //Don't heal inorganic things like robots and vehicles.
				Continue;
			
			If (IsActorHostile (Mobj)) //Duh
				Continue;
			
			//Out of range, sight, or reach, in order of cost.
			If (Distance3DSquared (Mobj) > Range*Range || !CheckSight (Mobj,SF_IGNOREWATERBOUNDARY) || !SM_IsPosReachable (Mobj.Pos,ignoreactors:True))
				Continue;
			
			If (Mobj Is "SM_Marine")
				Marines.Push (Mobj);
			
			If (Mobj.Player)
				Players.Push (Mobj);
			a_log ("SM_FindAllyToHelp: found a friend");
			Friends.Push (Mobj);
		}
		
		//Ignore this if no other marines are near anyway.
		If (Marines.Size() > 0 && Friends.Size() > 0)
		{
			Actor HealTarg;
			//Check every nearby friendly marine to ignore allies they are already going to heal.
			For (Int I = Marines.Size()-1; 0 <= I; I--)
			{
				If (Marines[I] && (HealTarg = SM_Marine(Marines[I]).HealTarget))
					Friends.Delete (Friends.Find (HealTarg)); //This ally is already going to be healed.
			}
		}
		
		If (Players.Size() > 0) //Just pick the first player you find.
			Return Actor(Players[0]);
		
		If (Friends.Size() > 0)
			Return Friends[Random (0,Friends.Size()-1)];
		
		Return Null;
	}
	
	Enum StrafeDirections
	{
		STRAFE_RANDOM = -1, //Strafe in a random direction.
		STRAFE_NONE = 0, //Don't strafe.
		STRAFE_LEFT = 1, //Strafe left.
		STRAFE_RIGHT = 2 //Strafe right.
	};
	
	//After a projectile to dodge is found by SM_ShouldDodgeProjectile, this function handles picking a direction, if any, to dodge out of the way towards.
	Bool SM_HandleDodging (Actor Projectile, Bool DontJump = False)
	{
		If (!Projectile || bDormant || IsDead(Self) || Pos.Z > FloorZ+8) Return False;
		console.printf ("SM_HandleDodging(): Dodged a %s",projectile.getclassname());
		
		//The marine is behind cover but not crouching, so dodge by going prone.
		If (MarineState & MARINE_INCOVER)
		{console.printf ("marine is in cover, dodging by crouching down");
			Crouching = True;
			Height = MARINE_CROUCHHEIGHT;
			GrenadeDelay += GameTicRate/2;
			NextFireDelay += GameTicRate/2;
			Return True;
		}
		
		Bool RightSafe, LeftSafe;
		Double OldAngle = Angle; //Store the current angle before facing the projectile to dodge it.
		Double OldDropoffHeight = MaxDropoffHeight;
		
		MaxDropOffHeight = 128; //Temporarily increase the maximum height the marine can drop from.
		
		If (CheckFOV (Projectile,120/2)) //Marines will only know the movement direction if they can actually see it.
			Angle = VectorAngle (Projectile.Vel.X,Projectile.Vel.Y)-180; //Jump away from the projectiles' movement direction.
		
		//Check if it's safe to strafe 56 map units to the left or right, or both. Or none even, like in the case of crammed corridors.
		Bool DecidedLeft, DecidedRight;
		Double Delta = DeltaAngle (Angle,AngleTo(Projectile));
		If (Delta >= -2 && Random (0,255) < 200) //No, the projectile is heading too much towards the left side.
		{
			a_log ("the projectile is to the left of the marine");
			LeftSafe = False;
			DecidedLeft = True;
		}
		Else If (Delta <= 2 && Random (0,255) < 200) //Ditto, but for the right side.
		{
			a_log ("the projectile is to the right of the marine");
			RightSafe = False;
			DecidedRight = True;
		}
		
		If (!DecidedLeft) LeftSafe = CheckMove (Vec2Angle (56,Angle+90),PCM_DROPOFF);
		If (!DecidedRight) RightSafe = CheckMove (Vec2Angle (56,Angle-90),PCM_DROPOFF);
		
		Int StrafeDirection;
		
		If ((LeftSafe && RightSafe)) //Both directions are safe to strafe to.
			StrafeDirection = STRAFE_RANDOM;
		Else If ((!LeftSafe && !RightSafe)) //The area is too crammed to strafe anywhere here.
		{
			Angle = OldAngle; //Revert the marines' angle if you can't dodge.
			StrafeDirection = STRAFE_NONE; //Reset the strafe direction to none.
			MaxDropOffHeight = OldDropoffHeight; //Revert the property to the default again.
			Return False; //Don't break whatever state sequence the marine is currently in to tell him he can't dodge.
		}
		Else If (LeftSafe && !RightSafe) //Can only strafe left.
			StrafeDirection = STRAFE_LEFT;
		Else If (!LeftSafe && RightSafe) //Can only strafe right.
			StrafeDirection = STRAFE_RIGHT;
		
		MaxDropOffHeight = OldDropoffHeight; //Revert the property to the default again.
		
		If (!DontJump) //Don't jump in both the literal and Doom state machine sense.
		{
			Double JumpAng = StrafeDirection == STRAFE_RANDOM ? Angle+RandomPick (90,-90) : 0;
			If (StrafeDirection == STRAFE_LEFT)
				JumpAng = Angle+90;
			Else If (StrafeDirection == STRAFE_RIGHT)
				JumpAng = Angle-90;
			JumpPos.XY = Vec2Angle (96,JumpAng);
			JumpPos.Z = GetZAt (JumpPos.X,JumpPos.Y)+(Height/2);
			SetStateLabel ("Jump.Dodge");
		}
		
		Return True; //Found a direction to strafe at to dodge.
	}
	
	Enum DodgePickModes
	{
		DODGE_FIRST, //Simplest and cheapest, just dodge the first valid projectile found. Also how the marines originally dodged.
		DODGE_RANDOM, //Idiot mode.
		DODGE_STRONGEST, //Dodge the strongest projectile in range.
		DODGE_NEAREST, //Dodge the closest projectile in range.
	}
	
	//Find and return a pointer to a projectile for the marine to dodge.
	//MAYDO: For now I won't make it ignore grenades, but if it looks too stupid to have them dodge grenades, I'll add exceptions for them.
	//Update: Seems like because the default dodge radius is smaller than the grenade hazard radius, they run from grenades anyway.
	Actor SM_ShouldDodgeProjectile (Double Range = 384, Int DodgeMode = DODGE_STRONGEST, Actor Ignore = Null)
	{
		Array <Actor> Threats;
		
		//Actually find projectiles.
		ForEach (Proj : KAIHandler.ProjectileList)
		{
			If (!Proj) Continue;
			
			Bool DodgeAllyProjectiles; //If on, the marine will dodge the projectile even if it's fired by an ally.
			
			Double Dist = Distance3DSquared (Proj);
			If (Dist > Range*Range || Proj == Ignore) //Out of range or put on ignore.
				Continue;
			
			//Dodge even friendly projectiles if they'd do too much damage, unless friendly fire is off.
			DodgeAllyProjectiles = (!(Proj Is "KAI_BaseProjectile" && KAI_BaseProjectile(Proj).bNoFriendlyFire) && Proj.GetMissileDamage (1,7) >= Health/2);
			
			If (!DodgeAllyProjectiles && !IsActorHostile (Proj.Target)) //Ignore friendly projectiles.
				Continue;
			
			//Don't return true if the projectile is too far away from the marines' peripheral vision. Or if it isn't so close that it's impossible not to notice it.
			If (!CheckFOV (Proj,120/2) && Dist > MeleeRange*MeleeRange)
				Continue;
			
			//Is the projectile about to hit me ? Weird math nonsense written by RaveYard.
			bool projectile_is_flying_towards_me = (Vec3To(proj).Unit() dot proj.vel.Unit()) < -0.15;
			double projectileSafeRadius = sqrt(2 * ((proj.radius + radius) ** 2.5));
			if(projectile_is_flying_towards_me && KAI_Math.distance3dline(pos, proj.pos, proj.pos + proj.vel) < projectileSafeRadius && CheckSight(Proj,SF_IGNOREWATERBOUNDARY))
			{
				If (DodgeMode != DODGE_FIRST)
					Threats.Push (Proj);
				Else
					Return Proj;
			}
			else
				console.printf ("%s isn't dangerous enough for the marine to try dodging",proj.getclassname());
		}
		
		If (DodgeMode == DODGE_RANDOM)
			Return (Threats[Random (0,Threats.Size()-1)]);
		Else If (DodgeMode == DODGE_NEAREST)
		{
			Double NearestDistance = INT.MAX;
			Actor NearestProj;
			For (Int I = Threats.Size()-1; I >= 0; I--)
			{
				Double CurrentDistance = Distance3D(Threats[I]);
				If (NearestDistance > CurrentDistance)
				{
					NearestDistance = CurrentDistance;
					NearestProj = Threats[I];
				}
			}
			
			Return NearestProj;
		}
		Else If (DodgeMode == DODGE_STRONGEST)
		{
			Double HighestDamage;
			Actor StrongestProj;
			For (Int I = Threats.Size()-1; I >= 0; I--)
			{
				Double CurrentDamage = Threats[I].GetMissileDamage(1,7);
				If (HighestDamage < CurrentDamage)
				{
					HighestDamage = CurrentDamage;
					StrongestProj = Threats[I];
				}
			}
			
			Return StrongestProj;
		}
		
		Return Null;
	}
	
	//Identical to KAI's IsPosReachable, but also accounts for the marines' ability to climb, if available.
	Bool SM_IsPosReachable (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False)
	{
		//TODO: When I most likely make the climbing able to be turned off, account for that here.
		Double RealStepHeight = MaxStepHeight;
		MaxStepHeight = (Height*1.75); //Maximum height the marine can reach, by jumping and ledge grabbing.
		Bool Res = IsPosReachable (TargetPos, DistCutoff, Spacing, IgnoreActors);
		MaxStepHeight = RealStepHeight;
		Return Res;
	}
	
	//Get the max health of actors or player pawn actors.
	Int SM_GetMaxHealth (Actor Other)
	{
		If (!Other)
			Return 0;
		
		If (Other.Player)
			Return Other.GetMaxHealth();
		
		Return Other.SpawnHealth();
	}
	
	//====|Non-AI functions|====\\
	//Handles the coloring of the marines. And if the string says "Random" returns a random available color string.
	String SM_HandleMarineColoring (String WhatColor)
	{
		If (!WhatColor || WhatColor ~== "") Return WhatColor; //Don't run the code if the string is empty.
		
		//Handles the random color choice that is performed if the color name given is "Random".
		If (WhatColor ~== "Random")
		{
			Static Const String ColorArray[] = {"Red","Gray","White","Black","Blue","Yellow","Orange","Pink","DarkGreen","DarkRed","Default"}; //Contains all the valid color names.
			
			WhatColor = ColorArray[Random(0,ColorArray.Size()-1)]; //Randomly picks a color string.
		}
		
		If (!(WhatColor ~== "Default"))
			A_SetTranslation (String.Format("Marine_%s", WhatColor));
		Else
			A_SetTranslation ('');
		
		Return WhatColor;
	}
	
	//Change what sprite frame to display based on the marines' pitch.
	Int SM_UpdateElevation (Int Down, Int Straight, Int Up, Int KneelDown = -1, Int KneelStraight = -1, Int KneelUp = -1, Int LyingDown = -1)
	{
		If (Crouching) //Don't update if crouching, since the marine has no aim sprites when crouching, obviously.
			Return CurState.Frame;
		
		If (MarineState & MARINE_LYINGDOWN)
			Return LyingDown;
		
		If (!(MarineState & MARINE_KNEELING))
		{
			If (Pitch <= -15)
				Return Up;
			Else If (Pitch >= 10)
				Return Down;
		}
		Else
		{
			If (Pitch <= -15)
				Return KneelUp;
			Else If (Pitch >= 10)
				Return KneelDown;
		}
		
		If (!(MarineState & MARINE_KNEELING))
			Return Straight;
		Else
			Return KneelStraight;
	}
	
	//Update height based on marine state, used when the marine is firing while kneeling or lying down, and in the future when crouching.
	Void SM_UpdateHeight ()
	{
		If (Crouching) Return; //Crouching doesn't need updating from here, that's SM_HandlingCrouching()'s and SM_UpdateCover()'s job.
		
		If (MarineState & MARINE_KNEELING)
			A_SetSize (newheight:32);
		Else If (MarineState & MARINE_LYINGDOWN)
			A_SetSize (newheight:8);
		Else
			A_SetSize (newheight:Default.Height);
	}
	
	Void SM_FireBullet ()
	{
		A_StartSound ("Marine/Fire",CHAN_WEAPON);
		Double FireHeight = 42;
		Double Recoil = 0.25;
		If (MarineState & MARINE_KNEELING)
		{console.printf ("firing while kneeling.");
			FireHeight = 32;
			Recoil /= 2;
		}
		Else If (MarineState & MARINE_LYINGDOWN)
		{console.printf ("firing while lying down.");
			FireHeight = 14;
			Recoil /= 3;
		}
		If (Crouching)
		{if (MarineState & MARINE_INCOVER) console.printf ("im shooting while crouching and in cover");
			FireHeight = 25;
			Recoil /= 3;
		}
		If (MarineState & MARINE_INCOVER)
			Recoil = 0;
		
		Actor Bullet = A_SpawnProjectile ("SM_Bullet",FireHeight,-6,flags:CMF_AIMDIRECTION,Pitch);
		Double AccuracyBuff = SM_IsCrouched() ? 0.5 : 1.0; //Double the accuracy if the marine is sitting down and firing.
		Switch (AttackType)
		{
			Case FIRE_BURST:
				AddProjectileSpread (Bullet,(1.1,-1.1)*AccuracyBuff,(1.1,-1.1)*AccuracyBuff);
				Break;
			Case FIRE_SINGLE:
				AddProjectileSpread (Bullet,(0.4,-0.4)*AccuracyBuff,(0.4,-0.4)*AccuracyBuff);
				Break;
			Case FIRE_FULLAUTO:
				AddProjectileSpread (Bullet,(2.2,-2.2)*AccuracyBuff,(2.2,-2.2)*AccuracyBuff);
				A_Recoil (Recoil);
				Break;
		}
		A_SpawnItemEx ("SM_BulletCasing",0,-6,FireHeight,FRandom (0,-1),FRandom (-4,-8),FRandom(1,5));
		AmmoCount--;
	}
	
	//End the marines' firing sequence. Used by both the Fire.End: state, and when the marine abruptly dies.
	Void SM_EndFiring()
	{
		SM_SetMarineState (0,MARINE_FIRING|MARINE_THROWING|MARINE_MELEE|MARINE_KNEELING|MARINE_LYINGDOWN);
		If (!IsDead(Self)) NextFireDelay = GameTicRate*Random(2,4); //Only add the timer if you didn't stop shooting by dying.
		AimTimer = BurstCounter = BurstSize = 0; //Reset aim and burst counters.
		AttackType = FIRE_BURST; //Reset to default fire mode.
		SM_UpdateHeight();
	}
	
	//Ask what the dog is doing.
	Actor IsDogNearby (Double DogRange = 384)
	{
		Let DogSearch = BlockThingsIterator.Create (Self,DogRange);
		
		Actor Dog;
		While (DogSearch.Next())
		{
			Dog = DogSearch.Thing;
			If (!Dog || !(Dog Is "MBFHelperDog") || IsDead (Dog))
				Continue;
			
			If (IsActorHostile (Dog))
				Continue;
			
			If (Distance3DSquared (Dog) > DogRange*DogRange)
				Continue;
			
			If (!CheckSight (Dog,SF_IGNOREWATERBOUNDARY))
				Continue;
			
			Return Dog;
		}
		
		Return Null;
	}
	
	Int FindDeadDogs (Double DogRange = 384, Actor Killer = Null)
	{
		Let DogSearch = BlockThingsIterator.Create (Self,DogRange);
		
		Actor Dog;
		Int Dogs;
		While (DogSearch.Next())
		{
			Dog = DogSearch.Thing;
			If (!Dog || !(Dog Is "MBFHelperDog") || !IsDead (Dog) || !IsFriend(Dog))
				Continue;
			
			If (Killer && Dog.Target != Killer) //Only count dogs killed by the same actor.
				Continue;
			
			Dogs++;
		}
		Return Dogs;
	}
}

//Find the marines target in the line of fire, otherwise assume the LOF is bad.
Class SM_FindTargetInLOF : KAI_LOFRaycast
{
	Override ETraceStatus TraceCallback ()
	{
		If (Other && Results.HitActor == Other)
		{console.printf ("SM_FindTargetInLOF: %s found",Other.GetClassName());
			BadLOF = False;
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

//KLUDGE: Apparently LineTrace()'s LineTracer must be fucking broken because it does NOT return the 3D floor it found.
//Find and return the first 3DFloor you hit.
Class SM_Find3DFloor : KAI_LOFRaycast
{
	Bool HitSwimmable; //Hit swimmable 3D floors too.
	Override ETraceStatus TraceCallback ()
	{
		If (HitSwimmable && Results.Crossed3DWater)
		{
			console.printf ("hit swimmable water at %d %d %d",results.crossed3dwaterpos);
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

//KLUDGE: Copied from the MVPs' UniversalFunctions mixin. Because they are supposed to work independent of each other.
Mixin Class SM_SplashFunctions
{
	Enum LiquidTypes
	{
		LIQUID_NONE = 0,
		LIQUID_WATER = 1,
		LIQUID_NUKAGE = 2,
		LIQUID_BLOOD = 3,
		LIQUID_LAVA = 4,
		LIQUID_SLIME = 5
	};
	
	Int CheckLiquid (TextureID Texture)
	{
		/*===============================================================
		This class stores the names of the different textures used for each type of liquid.
		These lists can be expanded as seen fit for your project, in case it has additional custom water/nukage/blood/lava/slime textures.
		The lists already contain some names of liquid flats that don't exist in the vanilla game, for built-in mod compatibility.
		Such as by having waterfall textures that don't exist like WFALL# and NFALL#.
		===============================================================*/
		Static Const String WaterTextures[] = {"FWATER1", "FWATER2", "FWATER3", "FWATER4", "WFALL1", "WFALL2", "WFALL3", "WFALL4"};
		Static Const String NukageTextures[] = {"NUKAGE1", "NUKAGE2", "NUKAGE3", "NFALL1", "NFALL2", "NFALL3", "NFALL4"};
		Static Const String BloodTextures[] = {"BLOOD1", "BLOOD2", "BLOOD3", "BFALL1", "BFALL2", "BFALL3", "BFALL4"};
		Static Const String LavaTextures[] = {"LAVA1","LAVA2", "LAVA3", "LAVA4", "DBRAIN1", "DBRAIN2", "DBRAIN3", "DBRAIN4", "LFALL1", "LFALL2", "LFALL3", "LFALL4"};
		Static Const String SlimeTextures[] = {"SLIME01","SLIME02", "SLIME03", "SLIME04", "SLIME05","SLIME06", "SLIME07", "SLIME08", "SFALL1", "SFALL2", "SFALL3", "SFALL4"};
		
		For (Int I = 0; I < WaterTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (WaterTextures[I]) == Texture)
				Return LIQUID_WATER;
		For (Int I = 0; I < NukageTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (NukageTextures[I]) == Texture)
				Return LIQUID_NUKAGE;
		For (Int I = 0; I < BloodTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (BloodTextures[I]) == Texture)
				Return LIQUID_BLOOD;
		For (Int I = 0; I < LavaTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (LavaTextures[I]) == Texture)
				Return LIQUID_LAVA;
		For (Int I = 0; I < SlimeTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (SlimeTextures[I]) == Texture)
				Return LIQUID_SLIME;
		
		Return LIQUID_NONE;
	}
	
	//Allows to quickly set up a spawned liquid splash, and then returns a pointer the splash to allow for further modifications, like making it visually larger or calling A_QuakeEx from it.
	Actor SpawnLiquidSplash (Int LiquidType = LIQUID_WATER, Sound SplashSound = "SFX/LiquidExplosion", Double Volume = 1.0, Double Attenuation = 0.5,
	Int ExplosionDamage = 0, Double ExplosionRadius = 0, Double FullDamageRadius = 0, Name DamageType = "", Bool DontHarmSource = False)
	{
		Actor Splash = Spawn ("SM_LiquidSplash",Pos);
		
		If (Splash)
		{
			//Set the shooter of the projectile for DontHarmSource to work.
			If (bMissile)
				Splash.Target = Target; //Projectiles store their shooter in the target pointer, so transfer the shooter to the splash.
			Else
				Splash.Target = Self; //Otherwise set the shooter to the actor calling the function, if it's not a projectile somehow.
			
			SM_LiquidSplash(Splash).LiquidType = LiquidType;
			SM_LiquidSplash(Splash).SplashSound = SplashSound;
			SM_LiquidSplash(Splash).Volume = Volume;
			SM_LiquidSplash(Splash).Attenuation = Attenuation;
			SM_LiquidSplash(Splash).RadiusDamage = ExplosionDamage;
			SM_LiquidSplash(Splash).MaxTargetRange = ExplosionRadius;
			SM_LiquidSplash(Splash).MeleeRange = FullDamageRadius;
			SM_LiquidSplash(Splash).ExplosionDamageType = DamageType;
			SM_LiquidSplash(Splash).DontHarmSource = DontHarmSource;
			Return Splash;
		}
		
		Return Null;
	}
	
	F3DFloor FindWaterBelow (Double Distance = 8)
	{
		Let WaterCheck = New ("SM_Find3DFloor");
		WaterCheck.HitSwimmable = True; //We only care for swimmable floors.
		
		WaterCheck.Trace (Pos,CurSector,(0,0,-1),Distance,0);
		Let FFloor = WaterCheck.Results.Crossed3DWater;
		//If (HitPos != HitPos) HitPos = WaterCheck.Results.Crossed3DWaterPos;
		WaterCheck.Destroy();
		Return FFloor;
	}
}