Extend Class SM_Marine
{
	Enum MarineChaseFlags
	{
		SMC_NOUSESTATE = 1 << 0, //The marine will not wait in his interact state after using a line with no threat around.
	}
	//TODO: Add a chase timer that decrements as long as the target is not visible or dead, and once it reaches the threshold, jump to the Idle state.
	//Unlike in the original Smart Marines, this is VERY MUCH a custom function.
	Void SM_Chase (StateLabel WaitState = Null, StateLabel RetreatState = Null, Int Flags = 0, Int ChaseFlags = 0, Double TurnRadius = 25)
	{
		//Very marine specific things
		If (BurstCounter) BurstCounter = 0; //Reset the burst fire countdown when not firing. Like if the marine is hurt mid-burst.
		
		//ZScript exports of different segments of GZDooms' native AI code. This is the stuff not needed for movement.
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_Chase_FriendsAttackPlayerEnemies(ChaseFlags);
		KAI_Chase_Retarget(ChaseFlags,True); //Friendly marines go idle with no target too.
		KAI_Chase_HandleActiveSound(ChaseFlags); //MAYDO: Remove this ?
		
		Bool MovedAlready;
		Double MajorThreatRange = 1536*1536;//(RetreatRange*4)*(RetreatRange*4);
		
		//Run away from major threats.
		If (bNoFear && Target && !(Goal && bChaseGoal))
		{
			If (!(ChaseFlags & CHF_DONTMOVE))
			{
				//If you can't attack (But not because you are in a NOATTACK sector), run. Also run if the other actor is frightening or you're frightened.
				If ((!CanAttack() && !(CurSector.Flags & Sector.SECF_NOATTACK)) || bFrightened || IsFrightening (Target) ||
				//If the targets' threat level is over the threshold, and it's visible and nearby, GTFO.
				ThreatLevelThreshold != THREAT_ASSESS && AssessThreatLevel(Target, True) >= ThreatLevelThreshold && (Distance3DSquared(Target) < MajorThreatRange))
				{
					//And at last, check if the target is still visible.
					If (CheckSight (Target, SF_IGNOREWATERBOUNDARY))
					{
						If (!RetreatState)
							KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
						Else
							SetStateLabel (RetreatState);
						MovedAlready = True;
						Return;
					}
				}
			}
		}
		
		Bool UsedLine;
		//If you can move and haven't done so already.
		If (!(ChaseFlags & CHF_DONTMOVE))
		{
			//Only update the nearest enemy to run from when not focused on a route.
			If (bAvoidMelee && !(IsPatrolling(Self) && bChaseGoal)) NearestEnemy = FindNearestEnemy (128); //TODO: Unhardcode the retreat range probably.
			//If you aren't patrolling and not allowed off your route, and there is an enemy nearby.
			If (bAvoidMelee && NearestEnemy)
			{
				If (!RetreatState)
					KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
				Else
					SetStateLabel (RetreatState);
				MovedAlready = True;
				//Return; //Might still melee you.
			}
			//Actual movement handling.
			Else
			{
				Bool B;
				KAI_Chase_HandleStrafing (Target,ChaseFlags);
				[B,MovedAlready] = KAI_Chase_PatrolHandling(WaitState, 0.2, anglelimit:TurnRadius, chaseflags:ChaseFlags);
				
				/*If there is no danger in sight, the marine will wait for lines he used like doors and platforms to move. Instead of moving around like a
				normal monster. However, if there IS danger nearby, the marine will keep moving after using the line like normal.*/
				Int NoStockUse;
				If (!IsDangerNearby())
				{
					NoStockUse = KMT_NOLINEUSE;
					UsedLine = SM_MarineUseLine(faceline:!(Flags & SMC_NOUSESTATE)); //Check if there's a line in front of use to use.
				}
				
				//Finally, if you do have a target, DO move towards it, but with KAI_MoveTowards instead of the shitty native movement code.
				If (Target && !MovedAlready)
					KAI_MoveTowards (Target.Pos, 0.5, TurnRadius, ChaseFlags, KMT_CHASEGOAL|KMT_ZIGZAG|NoStockUse);
			}
		}
		
		ShouldAttack(); //Run attack decision code.
		//TODO: Commented out this state until I can figure out how to actually check if a sector is moving, and get the middle point of a line.
		//If (!(Flags & SMC_NOUSESTATE) && UsedLine) 
			//SetStateLabel ("Interact");
	}
	
	//Marine's use lines in front of them.
	//IDEA: Make the marine detect doors or platforms in front of him, then if it's switch activated, search for nearby switches he can go up to and use. Dynamically.
	Sector UseSec;
	Bool SM_MarineUseLine (Double UseRange = 64, Bool FaceLine = False)
	{
		InteractWaits = 0; //Reset it here just in case.
		//Let LineSearch = BlockLinesIterator.Create (Self,Radius+64);
		//Count pushable lines as uses too.
        If (bCanPushWalls && BlockingLine && BlockingLine.Special && BlockingLine.Activate (Self,0,SPAC_Push))
		{
			//If (FaceLine) Angle = GetAngleToPos ((GetLinePos(BlockingLine),0));
			UseSec = GetLiftOrDoorSector(BlockingLine);//BlockingLine.BackSector;
			Return True;
		}
		
		If (!bCanUseWalls) Return False;
		FLineTraceData Usage;
		
		LineTrace (Angle,UseRange,0,TRF_BLOCKUSE,Height/2,data:Usage);
		
		FSpawnParticleParams P; P.Color1 = "Pink"; P.Style = STYLE_None; P.Lifetime = 1; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
		KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(Height/2),Usage.HitLocation,Usage.Distance,4,p);
		
		//Used a line in front of us.
		Line UseLine = Usage.HitLine;
		If (UseLine && UseLine.Special && UseLine.Activate (Self,Usage.LineSide,SPAC_Use))
		{
			//If (FaceLine) Angle = GetAngleToPos ((GetLinePos(UseLine),0));
			UseSec = GetLiftOrDoorSector(UseLine);//UseLine.BackSector;
			a_log ("a marine ran his custom line use function");
			Return True;
		}
		
		Return False;
	}
	
	//Gets the lift or door sector from the built in sector specials, instead of assuming the back sector is the door or lift, just in case.
	Sector GetLiftOrDoorSector (Line TheLine)
	{
		Sector Result;
		//Generally, it seems that args[0] is the tag of the affected sector. So this is what we assume.
		Switch (TheLine.Special)
		{
			Case 11: //Door_Open
			Case 12: //Door_Raise
			Case 202: //Door_Generic
			Case 105: //Door_WaitRase
			Case 203: //Generic_Lift
			{
				Let TagIter = Level.CreateSectorTagIterator (TheLine.Args[0],TheLine);
				Result = Level.Sectors[TagIter.Next()];
				Break;
			}
		}
		
		//If (TheLine.Args[0] == 0)
		//	Return TheLine.BackSector;
		
		Return Result;
	}
	
	//KLUDGE: Sector.PlaneMoving doesn't work, despite doing the same thing as this. So we have to use this, epic.
	Bool SM_SectorInMotion (Sector Sec)
	{
		If (!Sec)
			Return False;
		
		If (Sec.FloorData || Sec.CeilingData)
			Return True;
		
		Return False;
	}
	
	//Get the middle point of a line.
	//KLUDGE: GZDoom really doesn't like this formula I found on the Unreal Engine forum. Probably because it's too straightforward for its' esoteric tastes.
	Vector2 GetLinePos (Line TheLine)
	{
		//If (!TheLine)
			Return (Double.NaN, Double.NaN);
		
		//Return ((TheLine.V2.P - TheLine.V1.P) / TheLine.V2.P + TheLine.V1.P); 
	}
	
	//KAI_MoveAway wrapper.
	//MAYDO: Try and add code to make marines avoid smashing right into obstables ?
	Void SM_RunAway (Actor Other, Double RunRad = 64, Int MaxSteps = 32, Double TurnRadius = 25, Int ChaseFlags = 0)
	{
		KAI_MoveAway (Other, 16, RunRad, MaxSteps, 0.5, TurnRadius, ChaseFlags);
	}
	
	//Returns true if the marine is down on the ground in some capacity, as opposed to standing up.
	Bool SM_IsCrouched()
	{
		Return (MarineState & (MARINE_KNEELING|MARINE_LYINGDOWN));
	}
	
	//DECORATE-esque function for use in states.
	Void SM_SetMarineState (Int Add, Int Remove, Bool RemoveAll = False/*, Int Action = 0*/)
	{
		MarineState |= Add;
		If (!RemoveAll)
			MarineState &= ~Remove;
		Else
			MarineState = 0;
	}
	
	//End the marines' firing sequence. Used by both the Fire.End: state, and when the marine abruptly dies.
	Void SM_EndFiring()
	{
		SM_SetMarineState (0,MARINE_FIRING|MARINE_THROWING|MARINE_MELEE);
		If (!IsDead(Self)) NextFireDelay = GameTicRate*Random(2,4); //Only add the timer if you didn't stop shooting by dying.
		AimTimer = BurstCounter = BurstSize = 0; //Reset aim and burst counters.
		AttackType = FIRE_BURST; //Reset to default fire mode.
	}
	
	Void SM_FireBullet ()
	{
		A_StartSound ("Marine/Fire",CHAN_WEAPON);
		Actor Bullet = A_SpawnProjectile ("SM_Bullet",42,-6,flags:CMF_AIMDIRECTION,Pitch);
		Double AccuracyBuff = SittingDown ? 0.5 : 1.0; //Double the accuracy if the marine is sitting down and firing.
		Switch (AttackType) //TODO: Add slight recoil for full auto.
		{
			Case FIRE_BURST:
				AddProjectileSpread (Bullet,(1.1,-1.1)*AccuracyBuff,(1.1,-1.1)*AccuracyBuff);
				Break;
			Case FIRE_SINGLE:
				AddProjectileSpread (Bullet,(0.4,-0.4)*AccuracyBuff,(0.4,-0.4)*AccuracyBuff);
				Break;
			Case FIRE_FULLAUTO:
				AddProjectileSpread (Bullet,(2.2,-2.2)*AccuracyBuff,(2.2,-2.2)*AccuracyBuff);
				A_Recoil (0.25);
				Break;
		}
		A_SpawnItemEx ("SM_BulletCasing",0,-6,42,FRandom (0,-1),FRandom (-4,-8),FRandom(1,5));
		AmmoCount--;
	}
	
	State SM_CheckRefire (Int Chance, StateLabel AbortState, Double FOV = 360)
	{
		If (CurSector.Flags & Sector.SECF_NOATTACK)
			Return FindState (AbortState);
		
		AimPos = GetFAFAimPos (Target);
			
		If (Random2[pr_monsterrefire]() < Chance)
			Return State (Null);
		
		If (!Target || IsDead (Target) || (Target && !CheckFOV (Target,FOV)) || !CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES))
			{a_log ("marine refire cancelled");Return FindState (AbortState);}
		
		Return State (Null);
	}
	
	//Marines just fire SM_Bullet, so for now at least, so we mostly just need the trace offsets.
	Bool SM_CheckLOF (Vector3 CheckOffsets = (0,0,32), Int PropHealthThreshold = 25, Bool AimingAt = False)
	{
		Let Check = New ("KAI_ProjectileLOFCheck");
		
		AimPos = GetFAFAimPos (Target);
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Target)
			{
				Double PitchTo = PitchTo (Target,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Target), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Double Distance = !AimingAt ? MaxTargetRange : Distance3D (Target)+8;
		Check.Shooter = Self;
		Check.Other = Target;
		Check.PropHealthThreshold = PropHealthThreshold; //This can depend on factors like how many rounds the marine is firing.
		
		Check.ProjInfo = New ('LOFProjInfo'); //Assign data class.
		Check.ProjInfo.Projectile = "SM_Bullet"; //Pass projectile class to trace.
		Check.ProjInfo.InitializeProjectileInfo(); //Let it infer the rest.
		
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Distance,0);
		
		//KAI_LOFRaycast.VisualizeTracePath (Level.Vec3Offset (Pos,CheckOffsets),Check.Results.HitPos,Check.Results.Distance);
		Bool BadLoaf = Check.BadLOF;
		If (Check.ProjInfo) Check.ProjInfo.Destroy();
		Check.Destroy();
		Return !BadLoaf;
	}
	
	Bool SM_FindInLOF (Actor Who, Vector3 CheckOffsets = (0,0,32), Bool AimingAt = False)
	{
		Let Check = New ("SM_FindTargetInLOF");
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Who)
			{
				Double PitchTo = PitchTo (Who,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Who), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Check.Shooter = Self;
		Check.Other = Who;
		Check.BadLOF = True; //We have to assume the LOF is bad, and if the trace finds the other actor, then it's a good LOF.
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,MaxTargetRange,0);
		Bool Res = Check.BadLOF;
		Check.Destroy();
		Return !Res;
	}
	
	//Get what part of the actor the marine is aiming at now.
	Double GetAimPosOffset ()
	{
		Switch (AimPos)
		{
			Case FAF_MIDDLE:
				Return Target.Height/2;
			Case FAF_TOP:
				Return Target.Height;
			Case FAF_BOTTOM:
				Return 0; //The bottom is the origin of actors.
			Default:
				Return 0;
		}
	}
	
	
	//MAYDO: I might move this to the KAI, as a shared humanoid and vehicle function that is part of a mixin.
	
	Enum HitChanceFlags
	{
		DHC_HOSTILES	= 1 << 0, //Count any enemies of the marine hit by the smart check as successful hits as well. Smart check only.
		DHC_THRUHOSTILES= 1 << 1, //Implies DHC_HOSTILES too, makes the smart check go through any hostiles that have already been hit.
	}
	
	//Determines the chance of the marine hitting the other actor with his rifle.
	//Other: The actor to check, obviously.
	/*Smart: If this is on, usually when the (insert name here) CVAR is false. The marine will fire a series of hitscans at Other and return how many hit,
	instead of using a basic distance check.*/
	/*Distance: The distance to the Other actor, used for caching for the basic hit chance algorithm, if it's kept to -Double.NaN and Smart is false,
	it calculates the distance itself.*/
	//DumbSpread: The perfect conical spread of the attack, only used by the dumb hit chance algorithm.
	//Shots: How many hypothetical shots is the marine firing ? Use by both check types.
	//Offset: Offset the origin of the smart check by these coordinates relative to the marine.
	//Spread: A vector4 that stores: X = Minimum horizontal spread Y = Maximum horizontal spread Z = Minimum vertical spread W = Maximum vertical spread.
	//Range: The maximum range of the attack.
	//Flags: The flags passed to the check.
	Int DetermineHitChance (Actor Other, Bool Smart, Double Distance = Double.NaN, Double DumbSpread = 1,
	Int Shots = 1, Vector3 Offsets = (0,0,0), Vector4 Spread = (0,0,0,0), Double Range = 4096, Int Flags = DHC_HOSTILES)
	{
		If (!Other) Return 0;
		If (!Smart) //Credit: TonynUBarnes for the tangent code.
		{
			If (Distance != Distance) //No cached distance passed, calculate it ourselves.
				Distance = Distance3D(Other);
			//Double FunnelDiv = KAI_Math.LinearMap (Distance,0,MaxTargetRange,32,1);
			Console.Printf ("DetermineHitChance(): Distance to other is %.2f",Distance);
			Double MathFunnel = Distance * Tan (DumbSpread);
			Double Chance = (Other.Radius / MathFunnel)+FRandom(0,0.05);
			Console.Printf ("Hit ratio %.3f",Chance);
			
			Int Hits;
			
			//Credit: RNG code written by RaveYard.
			For (Int I = 0; I < Shots; I++)
			{
				If (FRandom (0,1.0) <= Chance)
					Hits++;
			}
			
			Console.Printf ("DetermineHitChance(): I will land %d shots with the dumb algorithm.",Hits);
			console.printf ("funnel is %.2f",MathFunnel);
			Return Hits;
		}
		Else
		{
			Console.Printf ("DetermineHitChance(): Angle %.2f, Pitch %.2f",Angle,Pitch);
			Let Check = New ("SM_HitChanceTracer");
			Int Hits;
			Vector3 Start = Level.Vec3Offset (Pos,Offsets);
			Vector3 AimDir;
			Double HSpread, VSpread;
			
			If (Flags & DHC_THRUHOSTILES) //Turn DHC_HOSTILES too if DHC_THRUHOSTILES is true.
				Flags |= (DHC_HOSTILES|DHC_THRUHOSTILES);
			
			Check.Shooter = Self;
			Check.Other = Other;
			Check.HostilesToo = Flags & DHC_HOSTILES;
			Check.ThruHostiles= Flags & DHC_THRUHOSTILES;
			
			While (--Shots >= 0)
			{
				Console.Printf ("Firing imaginary bullet.");
				//Add spread and all that good stuff.
				HSpread = AngleTo(Other)+FRandom (Spread.X,Spread.Y);
				VSpread = PitchTo(Other,Offsets.Z,GetAimPosOffset())+FRandom (Spread.Z,Spread.W);
				AimDir = (AngleToVector(HSpread, Cos(VSpread)), -Sin(VSpread));
				
				Check.Trace (Start,CurSector,AimDir,Range,0);
				
				Console.Printf ("Trace fired at %d %d %d, Ended at %d %d %d",Start,Check.Results.HitPos);
				Spawn ("KAI_DebugPoint",Check.Results.HitPos);
				If (Check.Success)
				{
					FSpawnParticleParams P; P.Color1 = "Green"; P.Style = STYLE_None; P.Lifetime = 35; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
					KAI_LOFRaycast.VisualizeTracePath(Start,Check.Results.HitPos,Check.Results.Distance,8,p);
					Hits++; //Another happy landing.
					console.printf ("successful hitscan went %.2f MU",check.results.distance);
				}
				Else
				{
					FSpawnParticleParams P; P.Color1 = "Red"; P.Style = STYLE_None; P.Lifetime = 35; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
					KAI_LOFRaycast.VisualizeTracePath(Start,Check.Results.HitPos,Check.Results.Distance,8,p);
					console.printf ("failed hitscan went %.2f MU",check.results.distance);
				}
				Check.Success = False; //Try again.
			}
			Console.Printf ("DetermineHitChance(): I will land %d shots with the smart algorithm.",Hits);
			Check.Destroy();
			Return Hits;
		}
		Return 0;
	}
	
	//Search for dangerous enemies around you.
	Bool IsDangerNearby (Double Range = 1024)
	{return false; //DEBUG
		If (Target && CheckSight (Target, SF_IGNOREWATERBOUNDARY)) //My target is visible, that's an enemy.
			{a_log ("IsDangerNearby(): Found target");Return True;}
		
		For (Int pn = 0; pn < MAXPLAYERS; pn++)  //An enemy player is visible, now THAT'S an enemy.
		{
			If(!PlayerInGame[pn])
				Continue;
			PlayerInfo plr = Players[pn];
			
			If (Plr && !IsFriend (Plr.Mo) && CheckSight(Plr.Mo,SF_IGNOREWATERBOUNDARY))
				{a_log ("IsDangerNearby(): Found enemy player");Return True;}
		}
		
		//Look for dangerous enemies.
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || IsInanimateObject(Mobj) || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			a_log ("IsDangerNearby(): Found random enemy NPC");
			Return True;
		}
		
		Return False;
	}
}

//Find the marines target in the line of fire, otherwise assume the LOF is bad.
Class SM_FindTargetInLOF : KAI_LOFRaycast
{
	Override ETraceStatus TraceCallback ()
	{
		If (Other && Results.HitActor == Other)
		{console.printf ("SM_FindTargetInLOF: %s found",Other.GetClassName());
			BadLOF = False;
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

Class SM_HitChanceTracer : KAI_LOFRaycast
{
	Bool Success; //The hypotherical trace hit the Other actor or any other enemy of the shooter.
	Bool HostilesToo; //Count hypothetical projectiles/hitscans stopped by enemies of the shooter successes too.
	Bool ThruHostiles; //Used with HostilesToo. Makes the tracer ignore hostiles it has already hit.
	Override ETraceStatus TraceCallback()
	{
		Actor Mobj = Results.HitActor;
		//We hit the target or another enemy.
		If (Other && Mobj == Other || HostilesToo && IsHostile(Shooter,Mobj)
		//Ignore enemies we've hit already.
		&& !(ThruHostiles && Mobjs.Find(Mobj)))
		{
			Success = True; //This was a triumph.
			If (ThruHostiles) AddToMobjList(Mobj); //Add already hit hostiles to the list.
			Return Trace_Stop;
		}
		
		If (Mobj && Mobj != Shooter && IsCollidable(Mobj)) //Hit an actor that isn't an enemy.
			Return Trace_Stop;
		
		//The trace specifically hit a projectile blocking line. e.g a window linedef or a polyobject.
		If (BlockingLineInTheWay (Results.HitLine,0))
			Return Trace_Stop;
		
		//Level geometry is in the way.
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Results.HitActor = Null;
		Return Trace_Skip;
	}
}

//KLUDGE: Copied from the MVPs' UniversalFunctions mixin. Because they are supposed to work independent of each other.
Mixin Class SM_SplashFunctions
{
	Enum LiquidTypes
	{
		LIQUID_NONE = 0,
		LIQUID_WATER = 1,
		LIQUID_NUKAGE = 2,
		LIQUID_BLOOD = 3,
		LIQUID_LAVA = 4,
		LIQUID_SLIME = 5
	};
	
	Int CheckLiquid (TextureID Texture)
	{
		/*===============================================================
		This class stores the names of the different textures used for each type of liquid.
		These lists can be expanded as seen fit for your project, in case it has additional custom water/nukage/blood/lava/slime textures.
		The lists already contain some names of liquid flats that don't exist in the vanilla game, for built-in mod compatibility.
		Such as by having waterfall textures that don't exist like WFALL# and NFALL#.
		===============================================================*/
		Static Const String WaterTextures[] = {"FWATER1", "FWATER2", "FWATER3", "FWATER4", "WFALL1", "WFALL2", "WFALL3", "WFALL4"};
		Static Const String NukageTextures[] = {"NUKAGE1", "NUKAGE2", "NUKAGE3", "NFALL1", "NFALL2", "NFALL3", "NFALL4"};
		Static Const String BloodTextures[] = {"BLOOD1", "BLOOD2", "BLOOD3", "BFALL1", "BFALL2", "BFALL3", "BFALL4"};
		Static Const String LavaTextures[] = {"LAVA1","LAVA2", "LAVA3", "LAVA4", "DBRAIN1", "DBRAIN2", "DBRAIN3", "DBRAIN4", "LFALL1", "LFALL2", "LFALL3", "LFALL4"};
		Static Const String SlimeTextures[] = {"SLIME01","SLIME02", "SLIME03", "SLIME04", "SLIME05","SLIME06", "SLIME07", "SLIME08", "SFALL1", "SFALL2", "SFALL3", "SFALL4"};
		
		For (Int I = 0; I < WaterTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (WaterTextures[I]) == Texture)
				Return LIQUID_WATER;
		For (Int I = 0; I < NukageTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (NukageTextures[I]) == Texture)
				Return LIQUID_NUKAGE;
		For (Int I = 0; I < BloodTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (BloodTextures[I]) == Texture)
				Return LIQUID_BLOOD;
		For (Int I = 0; I < LavaTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (LavaTextures[I]) == Texture)
				Return LIQUID_LAVA;
		For (Int I = 0; I < SlimeTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (SlimeTextures[I]) == Texture)
				Return LIQUID_SLIME;
		
		Return LIQUID_NONE;
	}
}