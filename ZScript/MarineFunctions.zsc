Extend Class SM_Marine
{
	Enum MarineChaseFlags
	{
		SMC_NOUSESTATE		= 1 << 0, //The marine will not wait in his interact state after using a line with no threat around.
		SMC_IGNOREHAZARDS	= 1 << 1, //The marine ignores any nearby hazards.
		SMC_NOCOVERSTOP		= 1 << 2, //The marine doesn't stop moving when in cover.
		SMC_SEARCHFORCOVER	= 1 << 3, //The marine actively searches for nearby cover between the target and him, or on their sides.
		SMC_USEEMPLACEMENTS	= 1 << 4, //The marine will try to use KAI emplacements like the machine gun turrets (And any future ones like ATGMs and mortars).
		SMC_NOSPACECHECK	= 1 << 5, //The marine will try retreating even when in a crammed space.
	}
	
	Vector3 NearbyCoverPos; //A bit of nearby cover the marine can run at to hide behind.
	
	//Unlike in the original Smart Marines, this is VERY MUCH a custom function.
	Void SM_Chase (StateLabel WaitState = Null, StateLabel RetreatState = Null, Int Flags = SMC_SEARCHFORCOVER, Int ChaseFlags = 0, Double TurnRadius = 25)
	{
		//Very marine specific things
		If (BurstCounter) BurstCounter = 0; //Reset the burst fire countdown when not firing. Like if the marine is hurt mid-burst.
		bNoFriction = Default.bNoFriction; //Reset the friction flag to the default, in case the marine begun firing or something mid-jump.
		bNoGravity = Default.bNoGravity; //Reset gravity too, they just shouldn't fuckin' float around.
		HealTarget = Null;
		DodgingHomingProjectile = False;
		
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		
		//ZScript exports of different segments of GZDooms' native AI code. This is the stuff not needed for movement.
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_Chase_FriendsAttackPlayerEnemies(ChaseFlags);
		If (KAI_Chase_Retarget(ChaseFlags,True)) //Friendly marines go idle with no target too.
		{
			//Might sometimes not say anything when seeing a target before going back to wandering and stuff.
			If (Random (True,False) == True) SayVoiceLine(VOICE_SEE,KAIHandler.GetNPCVoice(User_Voice),volume:0.35,0.85,CHAN_SPEECH);
		}

		//KAI_Chase_HandleActiveSound(ChaseFlags);
		
		Bool MovedAlready;
		//If fast monsters (AKA fast projectile attacks too) is enabled, and it's a ranged target, stay 16 meters away, if not, stay 12 meters away.
		Double MajorThreatRange = (Target && G_SkillPropertyInt(SKILLP_FASTMONSTERS) && Target.MissileState) ? 512*512 : 384*384;//(RetreatRange*4)*(RetreatRange*4);
		Bool CancelAttack;
		Int TargetThreatLevel = AssessThreatLevel(Target, True);
		
		If (!(ChaseFlags & CHF_DONTMOVE) && !(Flags & SMC_IGNOREHAZARDS)) MovedAlready = SM_RunFromHazards(); //Avoid any major hazards.
		
		If (!(Flags & SMC_NOCOVERSTOP) && MarineState & MARINE_INCOVER) //Don't move when in cover.
			ChaseFlags |= CHF_DONTMOVE;
		
		//Search for nearby cover in a 256 MU range. But only some of the time, since it's expensive.
		If (Flags & SMC_SEARCHFORCOVER && !(ChaseFlags & CHF_DONTMOVE) && KAI_Math.IsEmptyVector3 (NearbyCoverPos)/* && Random (0,255) < 64*/)
			NearbyCoverPos = SM_LocateNearbyCover (Target);
		
		//Check if the space the marine is in is too crammed, so they don't try to uselessly run away in crammed areas.
		Bool TooCrammed = False;
		If (!(Flags & SMC_NOSPACECHECK))
		{
			Int Iterations; Double Rad; Double Eh;
			[Iterations, Rad, Eh] = CheckSpaceSize (384,384,16);
			If (Rad != -1) TooCrammed = Rad < 192; //If there's any level geometry blocking us less than 192MU away, we're in a crammed area.
		}
		
		//Run away from major actor threats.
		If (!bNoFear && !TooCrammed && Target && !(Goal && bChaseGoal) && KAI_Math.IsEmptyVector3 (NearbyCoverPos))
		{
			If (!(ChaseFlags & CHF_DONTMOVE) && !MovedAlready)
			{
				//If you can't attack (But not because you are in a NOATTACK sector), run. Also run if the other actor is frightening or you're frightened.
				If ((!CanAttack() && !(CurSector.Flags & Sector.SECF_NOATTACK)) || bFrightened || IsFrightening (Target) ||
				//If the targets' threat level is over the threshold, and it's visible and nearby, GTFO.
				ThreatLevelThreshold != THREAT_ASSESS && TargetThreatLevel >= ThreatLevelThreshold && (Distance3DSquared(Target) < MajorThreatRange))
				{
					//And at last, check if the target is still visible.
					If (CheckSight (Target, SF_IGNOREWATERBOUNDARY))
					{
						If (Random (0,255) < 192 && !IsActorPlayingSound(CHAN_SPEECH)) SayVoiceLine(VOICE_FEAR,KAIHandler.GetNPCVoice(User_Voice),volume:0.45,0.85,CHAN_SPEECH);
						If (!RetreatState)
							KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
						Else
							SetStateLabel (RetreatState);
						MovedAlready = True;
						Return;
					}
				}
			}
		}
		
		//We're in range to try using the turret we're heading to.
		If (!TurretDelay && TargetTurret && Distance3DSquared(TargetTurret) <= MeleeRange*MeleeRange)
		{
			TargetTurret.EnterEmplacement(Self);
			//TargetTurret = Null; //Nullify this, also just in case the EnterEmplacement() fails.
			Return;
		}
		
		Bool UsedLine;
		//If you can move and haven't done so already.
		If (!(ChaseFlags & CHF_DONTMOVE))
		{
			//Only update the nearest enemy to run from when not focused on a route.
			If (bAvoidMelee && !(IsPatrolling(Self) && bChaseGoal)) NearestEnemy = FindNearestEnemy (128); //IDEA: Unhardcode the retreat range.
			
			//If you aren't patrolling and not allowed off your route, and there is an enemy nearby. Get away.
			If (!TooCrammed && bAvoidMelee && NearestEnemy)
			{
				If (!RetreatState)
					KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
				Else
					SetStateLabel (RetreatState);
				
				MovedAlready = True;
			}
			//Actual movement handling.
			Else
			{
				Bool B;
				KAI_Chase_HandleStrafing (Target,ChaseFlags);
				[B,MovedAlready] = KAI_Chase_PatrolHandling(WaitState, 0.2, anglelimit:TurnRadius, chaseflags:ChaseFlags);
				
				/*If there is no danger in sight, the marine will wait for lines he used like doors and platforms to move. Instead of moving around like a
				normal monster. However, if there IS danger nearby, the marine will keep moving after using the line like normal.*/
				Int NoStockUse;
				FLineTraceData LineCheck;
				LineTrace (Angle,48,0,TRF_BLOCKUSE,Height/2,data:LineCheck);
				If (LineCheck.HitLine && LineCheck.HitLine.Special && !IsDangerNearby())
				{
					NoStockUse = KMT_NOLINEUSE;
					UsedLine = SM_MarineUseLine(faceline:!(Flags & SMC_NOUSESTATE),tracedata:LineCheck); //Check if there's a line in front of us to use.
				}
				
				//Crouching comes first.
				If (!(MarineState & MARINE_INCOVER) && !SM_IsRestricted (RESTRICT_CROUCHING)) Crouching = KAI_HandleCrouching(Default.Height,MARINE_CROUCHHEIGHT);
				
				If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) &&
				//DO NOT CLIMB OVER YOUR COVER
				//BUG: Probably prevents marines from climbing at all when running to cover.
				(!KAI_Math.IsEmptyVector3 (NearbyCoverPos) || Level.Vec3Diff (Pos,NearbyCoverPos).Length() > Radius*1.2))
				{
					If (KAI_HandleClimbing(ClimbPos,JumpPos,"Climb","Jump.Up",1.1,1.75))
						MovedAlready = True;
				}
				
				If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) && SM_HandleClimbDown(Height*1.75)) //Handle jumping down any ledges that you can still climb up to if you want.
					MovedAlready = True;
				
				Vector2 JumpPosition = (Double.NaN,Double.NaN);
				If (!SM_IsRestricted (RESTRICT_JUMPING)) JumpPosition = KAI_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
				If (JumpPosition == JumpPosition && !Crouching && !(MarineState & MARINE_INCOVER)) //We have a valid position we must jump to, AKA the returned vector isn't null.
				{
					JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
					Bool Reachable = True; //Assume we can jump there by default.
					//The jump destination is longer than half the jump distance, so do a long jump if there's space behind you for it.
					If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5 && (Reachable = SM_CanRunBack()))
					{
						PreJumpPos = Vec3Angle(MARINE_JUMPRUNLENGTH,Angle-180);
						SetStateLabel ("Jump.Running");
						MovedAlready = True;
					}
					Else If (Reachable) //If the gap is too short to do a running jump, do a normal one, but don't fall back to normal jumps for large gaps.
					{
						SetStateLabel ("Jump");
						MovedAlready = True;
					}
				}
				
				//Finally, if you do have a target, DO move towards it, but with KAI_MoveTowards instead of the shitty native movement code.
				Bool GoingToEnemy = True;
				If (!MovedAlready)
				{
					Bool DoZigZag;
					Vector3 MovePos = (Double.NaN,Double.NaN,Double.NaN);
					Double RealSpeed = Speed;
					//Go to a nearby turret when in combat if you aren't weak and the target is particularly strong.
					If (!TurretDelay && !TargetTurret && Target && !(TargetThreatLevel >= ThreatLevelThreshold && Health <= 30))
						TargetTurret = KAI_Emplacement(FindEmplacements());
					
					//Sprint to turret, very likely to do so.
					If (TargetTurret && Random (0,255) < 32)
					{
						RetreatLoops = 4;
						SetStateLabel("Retreat");
						Return;
					}
					
					If (KAI_Math.IsEmptyVector3(MovePos))
						[MovePos, DoZigZag, CancelAttack] = SM_RunToCoverPos (Target,dozigzag:KMT_ZIGZAG);
					
					If (!KAI_Math.IsEmptyVector3(LastSeenPos)) //Out of sight, walk to last seen pos instead.
					{
						If (Level.Vec3Diff (Pos,LastSeenPos).Length() >= Radius*1.2)
						{
							If (!Target || !CheckSight (Target,SF_IGNOREWATERBOUNDARY)) //Run the actual sight check last to save on performance a little.
								MovePos = LastSeenPos;
						}
						Else
							LastSeenPos = (Double.NaN, Double.NaN, Double.NaN); //We're in position, begin chasing normally again.
					}
					Else
					{
						MovePos = HandleFollowingActor (MovePos); //Check if we should be following anyone.
						//Nothing to follow? Try focusing on chasing your target. Especially if you were going to the last seen pos of them, and reached it.
						//Also handle marking the marine as idling even if still in See:, if we're currently just following someone before going to Idle:
						If (KAI_Math.IsEmptyVector3(MovePos) && Target)
						{
							MovePos = Target.Pos;
							SM_SetMarineState (MARINE_CHASING,MARINE_IDLING);
						}
						Else
							SM_SetMarineState (MARINE_IDLING,MARINE_CHASING);
					}
					
					If (TargetTurret) //Jog towards turret.
					{
						MovePos = TargetTurret.Pos;
						Speed *= 1.5;
					}
					
					If (Crouching)
						Speed *= 0.7;
					If (MovePos == LastSeenPos)
						Speed *= 1.25;
					
					GoingToEnemy = (Target && MovePos == Target.Pos);
					
					//Marines keep certain amounts of distance from powerful enough ranged attackers.
					If (!(GoingToEnemy && Target.MissileState && Distance3DSquared(Target) <= SM_GetDistKept(Target,TargetThreatLevel)
					//Check if we even have enough space to afford walking off like that.
					&& CheckSpaceSize (256,64,1) == -1 ))
					{
						SM_RevertSpriteRotation();
						KAI_MoveTowards (MovePos, 0.5, TurnRadius, ChaseFlags, KMT_CHASEGOAL|DoZigZag|NoStockUse);
					}
					Else //Back off if too close to the ranged target.
					{
						KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
						SpriteRotation = -180;
					}
					Speed = RealSpeed;
				}
			}
		}
		
		SM_UpdateChaseTimer();
		If (!CancelAttack)
		{
			If (ShouldAttack()) //Run attack decision code.
				SM_RevertSpriteRotation();
		}
		
		If (!(Flags & SMC_NOUSESTATE) && UsedLine)
		{
			SetStateLabel ("Interact");
			SM_RevertSpriteRotation();
		}
		
		//If you are set to not automatically idle, only do it when the timer is over the threshold.
		If (ChaseFlags & CHF_DONTIDLE && ChaseTimer >= MARINE_CHASETIME)
		{
			SM_RevertSpriteRotation();
			A_ClearTarget();
			ChaseTimer = 0;
			SetIdle();
		}
	}
	
	//No longer backing off, revert sprite rotation and make the the actual direction you're looking at.
	Void SM_RevertSpriteRotation()
	{
		If (SpriteRotation != 0)
		{
			Angle += SpriteRotation;
			SpriteRotation = 0;
		}
	}
	
	//Get the minimum distance that the marine generally keeps from ranged enemies.
	Double SM_GetDistKept (Actor Who, Int Threat = -1)
	{
		If (!Who)
			Return 0;
		
		//No precached threat level passed.
		If (Threat == -1)
			Threat = AssessThreatLevel (Who);
		
		Switch (Threat)
		{
			Case THREAT_UNSTOPPABLE:
			Case THREAT_SUPERDANGER:
			Case THREAT_VERYDANGEROUS:
			Case THREAT_DANGEROUS:
				Return 768*768;
			Case THREAT_ABOVENORMAL:
				Return 512*512;
			Case THREAT_NORMAL: 
				Return 384*384;
			Case THREAT_MILD:
				Return 256*256;
			Case THREAT_LOW:
			Case THREAT_VERYLOW:
			Default:
				Break;
		}
		
		Return 0;
	}
	
	//Marine will run away from major hazards.
	//Unless it's patrolling and sticking to his path, and even then, he will still run if the hazard is like, a nuke or something.
	Bool SM_RunFromHazards (Bool NoJump = False)
	{
		If (HazardToAvoid && ( !(Goal && bChaseGoal) || HazardToAvoid.Level >= HazardInfo.HAZARD_HUGE ) && SM_ShouldRunFromHazard(HazardToAvoid) == RUN_FAST)
		{
			//The amount of loops is the distance to the hazard divided by distance travelled by one retreat sequence + some change.
			Double RetreatDist = Speed*8; //8 (Formerly 12, but I guess that's too little) movement calls in one Retreat loop.
			RetreatPos = GetHazardOriginPos (HazardToAvoid);
			RetreatLoops = Int(GetHazardDistance(HazardToAvoid) / RetreatDist);
			console.printf ("calculated %d retreat loops to run, decimal is %.2f",retreatloops,(GetHazardDistance(HazardToAvoid) / RetreatDist));
			
			//Run a bit further for shrapnel.
			Bool IsGrenade, HasShrapnel;
			ForEach (CurTag : HazardToAvoid.CustomTags)
			{
				If (CurTag ~== "Grenade")
					IsGrenade = True;
				If (CurTag ~== "Shrapnel")
					HasShrapnel = True;
			}
			
			//Add extra retreat loop for frag grenades.
			//NOTE: But also if the marine was reloading, mainly to prevent a bug where they'll sometimes run from a hazard, try to reload, move again, repeat.
			If (IsGrenade && HasShrapnel || MarineState & MARINE_RELOAD)
				RetreatLoops++;
			
			If (KAI_DebugPrintMessages)
			{
				Console.Printf ("SM_RunFronHazards(): Breaking action to run %d times away from this hazard:",RetreatLoops);
				HAZARDTOAVOID.PRINTHAZARDINFO();
			}
			
			//Prevent marines from spamming their voice, since for some reason this function is called repeatedly.
			If (!IsActorPlayingSound(CHAN_SPEECH))
			{
				//Say special grenade lines.
				If (IsGrenade && Random (0,255) < 128)
					SayVoiceLine(VOICE_NONE,KAIHandler.GetNPCVoice(User_Voice),"Grenade",0.50,0.85,CHAN_SPEECH);
				//Or just the generic hazard ones sometimes.
				Else
					SayVoiceLine(VOICE_HAZARD,KAIHandler.GetNPCVoice(User_Voice),volume:0.50,0.85,CHAN_SPEECH);
			}
			
			If (!NoJump) SetStateLabel ("Retreat");
			Return True;
		}
		Return False;
	}
	
	//To not have to copy and paste between SM_Chase() and SM_RunAway().
	Vector3, Bool, Bool SM_RunToCoverPos (Actor Other, Double SpeedMul = 2, Bool DoZigZag = True, Bool StopRetreating = False)
	{
		Vector3 MovePos = (Double.NaN, Double.NaN, Double.NaN); If (Other) MovePos = Other.Pos;
		Bool CancelAttack;
		If (!KAI_Math.IsEmptyVector3 (NearbyCoverPos)) //We have a position to take cover behind, move there.
		{
			Vector3 RealPos = Pos;
			SetXYZ (NearbyCoverPos); //Check from the desired position.
			FindFloorCeiling (FFCF_ONLYSPAWNPOS); //DO. NOT. CHECK. UNDER. THE. WORLD.
			//Make sure the target didn't get behind the cover or something while you are still going there !.
			Bool StillValidCover = SM_UpdateCover (Other,False,256);
			SetXYZ (RealPos);
			FindFloorCeiling (FFCF_ONLYSPAWNPOS); //DO. NOT. CHECK. UNDER. THE. WORLD.
			Bool CanWalkThere = (Random (0,255) < 220) ? True : IsPosReachable (NearbyCoverPos,spacing:Speed,ignoreactors:True); //Only SOMETIMES check if we can still go there.
			If (Level.Vec3Diff (Pos,NearbyCoverPos).Length() > Radius*1.2 && StillValidCover && CanWalkThere)
			{
				MovePos = NearbyCoverPos;
				Speed *= SpeedMul; //Hurry up to hide.
				DoZigZag = 0; //Move in a straight line as well.
				CancelAttack = True; //Don't attack.
			}
			Else //We are basically at our destination, so get rid of the goal and try crouching behind here.
			{
				NearbyCoverPos = (Double.NaN, Double.NaN, Double.NaN);
				If (StillValidCover) //If we are no longer heading to NearbyCoverPos because it's now unsafe, just abort.
				{
					SM_StartCrouch(); //Just to be sure, if it's not valid for some reason, the marine uncrouches on his own anyway.
					If (StopRetreating) //Used when called by SM_RunAway() to put the marine back into the See state with its' special crouch handling.
					{
						RetreatLoops = 0;
						RetreatPos = (Double.NaN, Double.NaN, Double.NaN);
						SetStateLabel ("See");
					}
				}
			}
		}
		Return MovePos, DoZigZag, CancelAttack;
	}
	
	//Search for the closest cover between the marine and the target (e.g if there's cover 4 meters towards the target) and the marines' flanks.
	//Other: The actor to check if you can hide from.
	//Distance: How far the check traces can move forward to check for cover + how far to check on each side for said cover.
	//PitchBounds: The maximum and minimum pitch, in that order, of the marine. If the pitch is out of those bounds, the many side checks are aborted for optimization. 0 disables each pitch check.
	Vector3 SM_LocateNearbyCover (Actor Other, Double Distance = 256, Vector2 PitchBounds = (-50, 80))
	{
		If (!Other || Distance <= 0 || SM_IsRestricted (RESTRICT_TAKECOVER))
			Return (Double.NaN, Double.NaN, Double.NaN);
		
		//Check in front of the marine first.
		Vector3 FrontCover = (Double.NaN, Double.NaN, Double.NaN);
		Bool GotFrontCover;
		[GotFrontCover, FrontCover] = SM_UpdateCover (Other,False,Distance);
		If (GotFrontCover) FrontCover.Z = GetZAt();
		
		If (!GotFrontCover) //Didn't find cover right in front of the direction Other is at, so ignore the result.
			FrontCover = (Double.NaN, Double.NaN, Double.NaN);
		
		Double PitchTo = PitchTo(Other,50,Other.Height/2);
		If (PitchBounds.X != 0 && PitchTo < PitchBounds.X) Return FrontCover;
		If (PitchBounds.Y != 0 && PitchTo > PitchBounds.Y) Return FrontCover;
		
		Vector3 RealPos = Pos;
		Vector3 LeftCover = (Double.NaN, Double.NaN, Double.NaN);
		Vector3 RightCover = (Double.NaN, Double.NaN, Double.NaN);
		Bool GotLeftCover, GotRightCover;
		
		Double Spacing = Radius*2; //Check spacing.
		
		For (Int DistDiv = Distance/Spacing; DistDiv < Distance; DistDiv += Spacing)
		{
			SetXYZ (Vec3Angle (DistDiv,AngleTo(Other)+90)); //Check left.
			FindFloorCeiling (FFCF_ONLYSPAWNPOS); //DO. NOT. CHECK. UNDER. THE. WORLD.
			[GotLeftCover, LeftCover] = SM_UpdateCover (Other,False,Distance);
			//actor point = spawn ("kai_debugpoint",leftcover);
			If (GotLeftCover) LeftCover.Z = GetZAt();
			SetXYZ (RealPos);
			FindFloorCeiling (FFCF_ONLYSPAWNPOS);
			If (!GotLeftCover) LeftCover = (Double.NaN, Double.NaN, Double.NaN);
			Else If (GotLeftCover && IsPosReachable (LeftCover,Radius*1.1))
				Break; //Found a spot to hide behind on the left.
		}
		
		For (Int DistDiv = Distance/Spacing; DistDiv < Distance; DistDiv += Spacing)
		{
			SetXYZ (Vec3Angle (DistDiv,AngleTo(Other)-90)); //Check Right.
			FindFloorCeiling (FFCF_ONLYSPAWNPOS); //DO. NOT. CHECK. UNDER. THE. WORLD.
			[GotRightCover, RightCover] = SM_UpdateCover (Other,False,Distance);
			//actor point = spawn ("kai_debugpoint",rightcover);
			If (GotRightCover) RightCover.Z = GetZAt();
			SetXYZ (RealPos);
			FindFloorCeiling (FFCF_ONLYSPAWNPOS);
			If (!GotRightCover) RightCover = (Double.NaN, Double.NaN, Double.NaN);
			Else If (GotRightCover && IsPosReachable (RightCover))
				Break; //Found a spot to hide behind on the right.
		}
		
		//Get the smallest distance between these 3, and return the closest position.
		Double FrontDist = Int.Max;
		Double LeftDist = Int.Max;
		Double RightDist = Int.Max;
		
		If (!KAI_Math.IsEmptyVector3 (FrontCover)) FrontDist = Level.Vec3Diff (Pos,FrontCover).Length();
		If (!KAI_Math.IsEmptyVector3 (LeftCover)) LeftDist = Level.Vec3Diff (Pos,LeftCover).Length();
		If (!KAI_Math.IsEmptyVector3 (RightCover)) RightDist = Level.Vec3Diff (Pos,RightCover).Length();
		
		Double SmallestDist = Min (FrontDist,LeftDist,RightDist);
		
		If (SmallestDist != INT.MAX)
		{
			If (SmallestDist == FrontDist && !KAI_Math.IsEmptyVector3(FrontCover))
				{If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): Taking front cover %d %d %d",frontcover);Return FrontCover;}
			Else If (SmallestDist == LeftDist && !KAI_Math.IsEmptyVector3(LeftCover))
				{If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): Taking left cover %d %d %d",leftcover);Return LeftCover;}
			Else If (SmallestDist == RightDist && !KAI_Math.IsEmptyVector3(RightCover))
				{If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): Taking right cover %d %d %d",rightcover);Return RightCover;}
		}
		If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): All checks failed, returning NaN vector.");
		Return (Double.NaN, Double.NaN, Double.NaN);
	}
	
	Bool HipFalsePositive; //HACK: Sometimes traces go full retard and return that the marines' hip level isn't blocked, so only uncrouch if TWO hip checks are false.
	
	Bool, Vector3 SM_UpdateCover (Actor Other, Bool IsCrouchingAlready, Double TraceDist = 48)
	{
		Vector3 HipHitPos = (Double.NaN, Double.NaN, Double.NaN);
		
		//Don't crouch if Who is invalid, you are patrolling, crouching is restricted, or you're below the world.
		If (!Other || IsPatrolling (Self) || SM_IsRestricted (RESTRICT_TAKECOVER) || Pos.Z < FloorZ)
			Return False, HipHitPos;
		
		FLineTraceData EyeLevel, HipLevel;
		Bool EyeLevelUnblocked, HipLevelBlocked;
		Int HasHit;
		Actor Mobj;
		
		//If the other actor is this close to you, you probably can't crouch.
		If (Distance3DSquared(Other) <= 72*72)
			Return False, HipHitPos;
		
		/*
		This fires two raycasts from the marines' eyes and hips. Then the Eye and HipLevelBlocked booleans return true or false.
		Based on whether or not they hit any level geometry before stopping. The distance that the raycasts travel double when
		the marine is already crouched, so they don't get out of cover even when their target hasn't breached said cover.
		*/
		
		If (!IsCrouchingAlready)
			LineTrace (AngleTo (Other),TraceDist,PitchTo(Other,50,Other.Height/2),0,50,data:EyeLevel);
		Else
			LineTrace (AngleTo (Other),128,PitchTo(Other,50,Other.Height/2),0,50,data:EyeLevel);
		
		EyeLevelUnblocked = SM_EyeLevelClear (EyeLevel);

		If (!IsCrouchingAlready)
			LineTrace (AngleTo (Other),TraceDist,PitchTo(Other,18,Other.Height/2),TRF_THRUHITSCAN,18,data:HipLevel);
		Else //Run a longer range trace when crouched to not go out of cover as easily when behind strangely shaped cover like star shaped fountains.
			LineTrace (AngleTo (Other),128,PitchTo(Other,18,Other.Height/2),TRF_THRUHITSCAN,18,data:HipLevel);
		
		HasHit = HipLevel.HitType;
		Mobj = HipLevel.HitActor;
		HipHitPos = HipLevel.HitLocation - HipLevel.HitDir * (Radius*1.1);
		
		//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(50),EyeLevel.HitLocation,EyeLevel.Distance);
		//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(18),HipLevel.HitLocation,HipLevel.Distance);
		
		//Only take cover behind level geometry, and large enough actors that aren't other NPCs or players. And aren't about to break.
		If ((HasHit == TRACE_HitWall || HasHit == TRACE_HitFloor || HasHit == Trace_HitCeiling) ||
		(Mobj && !(Mobj.bIsMonster || Mobj.Player) && Mobj.Radius >= Radius && Mobj.Height <= 40 && Mobj.Health >= 30))
			HipLevelBlocked = True;
			
		Bool OtherInSight = CheckSight (Other,SF_SEEPASTSHOOTABLELINES|SF_IGNOREWATERBOUNDARY);
		//Only run this if the marine is not crouched already.
		If (!IsCrouchingAlready)
			If (EyelevelUnblocked && HipLevelBlocked && OtherInSight)
			{
				//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(50),EyeLevel.HitLocation,EyeLevel.Distance);
				//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(18),HipLevel.HitLocation,HipLevel.Distance);
				Return True, HipHitPos;
			}
		
		//If you are crouching already and have a line of sight to the other actor.
		If (IsCrouchingAlready && OtherInSight)
		{
			If (!HipLevelBlocked && !HipFalsePositive) //HACK: Catch retarded false positives from the trace.
			{
				HipFalsePositive = True;
				HipLevelBlocked = True;
			}
			If (!HipLevelBlocked && HipFalsePositive) //If it returns false a second time, it's probably for real.
				HipFalsePositive = False;
			Return HipLevelBlocked, HipHitPos; //Then return if you can crouch based on whether or not your hips are blocked by cover still.
		}
		
		If (!OtherInSight && Random (0,255) < 4) //If the other actor is out of sight, the marine will eventually give up staying behind cover.
			Return False, HipHitPos;
		
		//If none of the other checks are true, but you are crouching already, then just assume you can keep doing so.
		If (IsCrouchingAlready)
		{
			HipFalsePositive = True; //HACK: We need two false hip checks in a row to consider it to not be a fluke.
			Return True, HipHitPos;
		}
		
		Return False, HipHitPos;
	}
	
	//Makes marines able to enter their climb down sequence if their next step is down a short enough dropoff.
	//MAYDO: I should probably look for a way to integrate this into KAI_HandleClimbing() ?
	Bool SM_HandleClimbDown (Double DropoffHeight = 56)
	{
		If (Pos.Z > FloorZ) //In the air.
			Return False;
		Vector2 Ahead = Vec2Angle(Radius*2.2,Angle);
		Double ZAt = GetZAt (Ahead.X,Ahead.Y,0,GZF_ABSOLUTEPOS);
		If (!Level.IsPointInLevel((Ahead,ZAt))) //Welcome to boundary break.
			Return False;
		If (DropoffHeight > Pos.Z - ZAt && MaxDropoffHeight < Pos.Z - ZAt) //The dropoff height is as tall or shorter than the specified MaxDropoff.
		{
			JumpPos = (Vec2Angle (104,Angle),ZAt);
			SetStateLabel ("Jump"); //So jump down.
			Return True;
		}
		
		Return False;
	}
	
	//Clean wrapper for the eye level checks, copied from the original code and probably unnecessary.
	Bool SM_EyeLevelClear (FLineTraceData Data)
    {
        Int HasHit;
        
        HasHit = Data.HitType;
		
        If (Data.HitActor || HasHit == TRACE_HitWall || HasHit == TRACE_HitFloor || HasHit == Trace_HitCeiling)
            Return False;
        
        Return True;
    }
	
	//KLUDGE: Rest assured, this piece of shit is very broken.
	//Check if Other is within Viewer's FOV.
	Bool SM_CheckFOV (Actor Viewer, Actor Other, Double FOV)
	{
		Vector3 CameraPos;
		If (Viewer.Player)
			CameraPos = (Viewer.Player.Camera.Pos.XY,Viewer.Player.ViewZ);
		Else
			CameraPos = (Viewer.Pos.XY,Viewer.GetCameraHeight());
		
		If (Viewer.Player)
		{
			Double d1, d2, ViewWidth, ViewHeight;
			[d1,d2,ViewWidth,ViewHeight] = Screen.GetViewWindow();
			If (KAI_DebugPrintMessages)console.printf ("width %d, height %d",viewwidth,viewheight);
			FOV = FOV * (ViewWidth / ViewHeight);
		}
		
		Vector3 Coords = Level.SphericalCoords (CameraPos,Other.Pos.PlusZ(Other.Height/2),(Viewer.Angle,Viewer.Pitch));
		If (Abs(Coords.X) <= FOV/2)
			Return True;
		Return False;
	}
	
	Bool SM_CanRunBack()
	{
		Vector3 RealPos = Pos;
		Bool Moved = IsPosReachable (Vec3Angle(MARINE_JUMPRUNLENGTH,Angle-180),dropoff:False); //Doesn't use the SM_ wrapper since it's supposed to be one continuous running leap.
		If (Moved)
		{
			SetOrigin (Vec3Angle(MARINE_JUMPRUNLENGTH,Angle-180),False);
			Moved = IsPosReachable (Vec3Angle(MARINE_JUMPRUNLENGTH,Angle));
			SetOrigin (RealPos,False);
		}
		Return Moved;
	}
	
	//Decreases (Or maybe even increases) the retreat loops in certain cases where the marine decides to retreat, on factors like how many allies are near him.  
	Int AlterRetreatLoops (Int Loops)
	{
		If (IsIndestructible (Self)) Return 0; //Nothing to worry about.
		
		Array<Actor> Allies;
		Array<Actor> Groupies;
		Double Reduction; //Score that is then used to subtract from the give retreat loops. This can be decimal for way weaker allies, like THREAT_LOW friends.
		
		//Find allies around.
		ForEach(Mo : BlockThingsIterator.Create(Self, 1024))
		{
			//Unavailable.
			If (!Mo || Mo == Self || IsInanimateObject(Mo) || IsDead (Mo) || Mo.bDormant || Mo.IsFrozen() || !CheckSight (Mo,SF_IGNOREWATERBOUNDARY))
				Continue;
			
			//This is a group member in a group you're in. So they can be as far as 1024 MU away.
			If (SM_IsSquadMate(Mo))
			{
				If (Distance3DSquared (Mo) > 1024*1024)
					Continue;
				//Friendly squadmate, add an additional minor loop reduction for that and move on.
				Else If (!IsActorHostile(Mo))
				{
					Reduction += 2;
					Allies.Push (Mo);
					Continue;
				}
			}
			Else //If they ain't, then they must be pretty damn close to count!
			{
				If (Distance3DSquared (Mo) > 512*512)
					Continue;
			}
			
			If (!IsActorHostile(Mo) && (Mo.Player && Mo.Player.Cheats & CF_NOTARGET))
				Allies.Push (Mo);
		}
		
		If (Health <= 40) //We're low on health.
			Reduction -= 2;
		
		If (TargetTurret) //We're eyeing an emplacement, so make room for running towards it.
			Reduction -= 5;
		
		//Reduce retreats based on the threat level of your allies and their quantity.
		ForEach (Ally : Allies)
		{
			Switch (AssessThreatLevel(Ally))
			{
				Case THREAT_UNSTOPPABLE:
					Reduction += 25;
					Break;
				Case THREAT_SUPERDANGER:
					Reduction += 16;
					Break;
				Case THREAT_VERYDANGEROUS:
					Reduction += 8;
					Break;
				Case THREAT_DANGEROUS:
					Reduction += 4;
					Break;
				Case THREAT_ABOVENORMAL:
					Reduction += 2.5;
					Break;
				Case THREAT_NORMAL: 
					Reduction += 1;
					Break;
				Case THREAT_MILD:
					Reduction += 0.5;
					Break;
				Case THREAT_LOW:
					Reduction += 0.25;
					Break;
				Case THREAT_VERYLOW:
					Reduction += 0.1;
					Break;
				Default:
					Break;
			}
			//If (Ally Is "SM_Marine")
			//	Reduction += 0.5; //Slight increase for fellow marines.
		}
		
		Int Iterations; Double Rad; Double Eh;
		[Iterations, Rad, Eh] = CheckSpaceSize (512,512,24);
		If (Iterations == -1) Iterations = 0; //Open space.
		Double Score = Loops - Reduction - Iterations;
		If (Score > 0.2 && Score <= 1.0 || Rad != -1 && Rad < 88) //Our score is low, but not that low (Or it's too crammed), so keep one loop for good measure instead of reloading in place.
			Score = 1;
		Return Int(Score);
	}
	
	//Is this actor in a group that we share?
	Bool SM_IsSquadmate (Actor Who)
	{
		ForEach (Group : Groups)
		{
			ForEach (Member : Group.Members)
			{
				If (Who != Self && Member != Self && Who == Member)
					Return True;
			}
		}
		Return False;
	}
	
	Void SM_StartCrouch()
	{
		MarineState |= MARINE_INCOVER;
		Crouching = True;
		Height = MARINE_CROUCHHEIGHT;
	}
	
	Void SM_EndCrouch()
	{
		MarineState &= ~(MARINE_INCOVER);
		Crouching = False;
		Height = Default.Height;
		HipFalsePositive = False; //We're not crouching, turn off hack variable.
	}
	
	//Play taunt noise, can either be a custom "Taunt" type voice line if the User_Voice has such a type, or will instead exclusively be the laugh sound.
	Void SM_PlayTauntSound (Bool Loop = False)
	{
		//Do NOT play the stock taunt laugh on loop if you have taunt voicelines.
		If (Loop)
		{
			If (User_Voice && KAIHandler.GetNPCVoice(User_Voice) && KAIHandler.GetNPCVoice(User_Voice).GetCustomType("Taunt"))
				Return;
			Else
			{
				A_StartSound ("Marine/Taunt",CHAN_VOICE);
				Return;
			}
		}
		
		//Play taunt voice lines, if available
		If (SayVoiceLine(VOICE_NONE,KAIHandler.GetNPCVoice(User_Voice),"Taunt",0.35,0.85,CHAN_SPEECH))
			Return;
		//If we have no taunt voice lines, then play the stock laugh.
		Else
			A_StartSound ("Marine/Taunt",CHAN_VOICE);
	}
	
	//Get the chance of commenting on a dead ally.
	Int, Bool SM_GetDeadAllyCommentChance (Actor DeadAlly)
	{
		//Chance of the marine commenting on the death, depends on the threat level of the dead ally, or if they're a dead player.
		Bool StopSpeaking; //Stop what you were saying to comment on the dead NPC or player.
		Int Chance = Random (32,48);
		If (!DeadAlly.Player)
		{
			Switch (AssessThreatLevel(DeadAlly,checkdead:True))
			{
				Case THREAT_SUPERDANGER:
					Chance += 255;
					StopSpeaking = True;
					Break;
				Case THREAT_VERYDANGEROUS:
					Chance += 192;
					StopSpeaking = True;
					Break;
				Case THREAT_DANGEROUS:
					Chance += 64;
					StopSpeaking = True;
					Break;
				Case THREAT_ABOVENORMAL:
					Chance += 32;
					Break;
				Case THREAT_NORMAL: 
					Chance += 16;
					Break;
				Case THREAT_MILD:
					Chance += 8;
					Break;
				Default:
					Break;
			}
		}
		Else
		{
			Chance = 255;
			StopSpeaking = True;
		}
		If (DeadAlly Is "SM_Marine")
			Chance += 64;
		
		Return Chance, StopSpeaking;
	}
	
	//Increment the chase timer as long as the target is nonexistent, dead, or out of sight. And reset it if any of these conditions are false.
	//Also handles updating LastSeenPos.
	Void SM_UpdateChaseTimer()
	{
		If (IsPatrolling(Self)) //Ignore this if we are following a goal.
			ChaseTimer = 0;
		Bool Dead = IsDead(Target);
		Bool OuttaSight;
		If (!Target || Target && (Dead || (OuttaSight = !CheckSight(Target,SF_IGNOREWATERBOUNDARY))  ) )
			ChaseTimer++;
		Else
			ChaseTimer = 0;
		
		//Update LastSeenPos.
		If (Target && !OuttaSight && !Dead)
			LastSeenPos = Target.Pos;
		Else If (!Target || Dead)
			LastSeenPos = (Double.NaN, Double.NaN, Double.NaN); //The target is dead or gone.
		
		If (!Target || Dead) ChaseTimer++; //Decrement the timer extra fast if the target is just flat out gone.
		If (KAI_DebugPrintMessages) Console.Printf ("SM_UpdateChaseTimer(): Time is %d",ChaseTimer);
	}
	
	//Marines use lines in front of them.
	//IDEA: Make the marine detect doors or platforms in front of him, then if it's switch activated, search for nearby switches he can go up to and use. Dynamically.
	//IDEA: Make this account for polyobject doors and stuff?
	Sector UseSec;
	Bool SM_MarineUseLine (Double UseRange = 48, Bool FaceLine = False, FLineTraceData TraceData = Null)
	{
		InteractWaits = 0; //Reset it here just in case.
		
		//Count pushable lines as uses too.
        If (bCanPushWalls && BlockingLine && BlockingLine.Special && BlockingLine.Activate (Self,0,SPAC_Push))
		{
			If (FaceLine) Angle = VectorAngle(-BlockingLine.Delta.X,-BlockingLine.Delta.Y) - 90;
			UseSec = GetLiftOrDoorSector(BlockingLine);//BlockingLine.BackSector;
			Return True;
		}
		
		If (!bCanUseWalls) Return False;
		
		FLineTraceData Usage;
		//No precalculated trace data passed, do it ourselves.
		If (!TraceData)
			LineTrace (Angle,UseRange,0,TRF_BLOCKUSE,Height/2,data:Usage);
		
		//FSpawnParticleParams P; P.Color1 = "Pink"; P.Style = STYLE_None; P.Lifetime = 1; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
		//KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(Height/2),Usage.HitLocation,Usage.Distance,4,p);
		
		//Used a line in front of us.
		Line UseLine = TraceData ? TraceData.HitLine : Usage.HitLine;
		If (UseLine && UseLine.Special && UseLine.Activate (Self,Usage.LineSide,SPAC_Use))
		{
		//spawn ("kai_debugpoint",(GetLinePos(UseLine),0));
			If (FaceLine) Angle = VectorAngle(-UseLine.Delta.X,-UseLine.Delta.Y) - 90;
			UseSec = GetLiftOrDoorSector(UseLine);//UseLine.BackSector;
			If (KAI_DebugPrintMessages)console.printf ("a marine ran his custom line use function, his angle is %.2f",angle);
			Return True;
		}
		
		Return False;
	}
	
	
	//TODO: Replace this fucking shit with just accessing the sector thinker data that I exposed to ZScript in GZDoom 4.14.
	//Gets the lift or door sector from the built in sector specials, instead of assuming the back sector is the door or lift, just in case.
	Sector GetLiftOrDoorSector (Line TheLine)
	{
		Sector Result;
		//Generally, it seems that args[0] is the tag of the affected sector. So this is what we assume.
		Switch (TheLine.Special)
		{
			Case 11: //Door_Open
			Case 12: //Door_Raise
			Case 21: //Floor_LowerToNearest
			Case 202: //Door_Generic
			Case 105: //Door_WaitRase
			Case 203: //Generic_Lift
			{
				Let TagIter = Level.CreateSectorTagIterator (TheLine.Args[0],TheLine);
				Result = Level.Sectors[TagIter.Next()];
				Break;
			}
			Default: //No relevant special on the line lol.
				Return Null;
		}
		
		//Line has no sector tag it moves with the door or platform specials, so it only affects the sector behind the line.
		If (TheLine.Args[0] == 0)
			Return TheLine.BackSector;
		
		Return Result;
	}	
	//HACK: We ASSUME this is some for of door or platform in the sector, so wait for it to have moved enough for the marine to go through.
	Bool SM_DoorOrLiftFinished()
	{
		If (!UseSec || !UseSec.PlaneMoving(Sector.Floor) && !UseSec.PlaneMoving(Sector.Ceiling)) Return True; //No sector we used apparently, or there's not plane thinkers at all attached.
		
		/*Check if we can walk through the UseSec. AND there is a visible line of sight, because IsPosReachable() can be fucking stupid, and then cause a stack
		overflow in the Interact: state.*/
		//NOTE: The sectors' centerspot can be out of bounds if it's a weird shape, that's probably a problem.
		Vector3 CheckPos = Vec3Angle (64+8,Angle);
		Actor Temp = Spawn("KAI_TempPoint",CheckPos);
		If (UseSec && CheckSight (Temp,SF_IGNOREWATERBOUNDARY)/* && SM_IsPosReachable (CheckPos,ignoreactors:True,dontclimb:True)*/)
		{
			If (Temp) Temp.Destroy();
			Return True;
		}
		If (Temp) Temp.Destroy();
		Return False;
	}
	
	//Get the middle point of a line to face it.
	Vector2 GetLinePos (Line TheLine)
	{
		If (!TheLine)
			Return (Double.NaN, Double.NaN);
		
		Return ((TheLine.V2.P - TheLine.V1.P) * 0.5 + TheLine.V1.P); 
	}
	
	//KAI_MoveAway wrapper, handles running behind cover, as well as parkouring when retreating.
	//NOTE: If the RetreatPos marine variable is valid, the marine will run from that instead. Not the Other actor.
	Void SM_RunAway (Actor Other, Double RunRad = 64, Int MaxSteps = 32, Double TurnRadius = 25, Int ChaseFlags = 0, Int Flags = 0)//, Int KMAFlags = 0)
	{
		If (!(MarineState & MARINE_INCOVER))
		{
			If (!SM_IsRestricted (RESTRICT_CROUCHING)) Crouching = KAI_HandleCrouching (Default.Height,MARINE_CROUCHHEIGHT); //Handle crouching, duh.
			
			//Handle climbing
			If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) && KAI_HandleClimbing (ClimbPos,JumpPos,"Climb","Jump.Up",1.1,1.75))
				Return;
			
			If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) && SM_HandleClimbDown(Height*1.75)) //Handle jumping down any ledges that you can still climb up to if you want.
				Return;
			
			//Handle jumping.
			Vector2 JumpPosition = (Double.NaN,Double.NaN);
			If (!SM_IsRestricted (RESTRICT_JUMPING)) JumpPosition = KAI_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
			If (JumpPosition == JumpPosition && !Crouching) //We have a valid position we must jump to, AKA the returned vector isn't null.
			{
				JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
				//The jump is longer than half the max jump distance, normally we do a running jump, but since we are presumably running for our lives, don't bother.
				If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5)
					Return;
				Else
				{
					SetStateLabel ("Jump");
					Return;
				}
			}
		}
		
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		//We're running away, but we do have a turret to head to, so run towards it to use it instead.
		If (TargetTurret)
		{
			If (TargetTurret && Distance3DSquared(TargetTurret) <= (MeleeRange*MeleeRange)*1.2)
			{
				TargetTurret.EnterEmplacement(Self);
				TargetTurret = Null; //Nullify this, also just in case the EnterEmplacement() fails.
				Return;
			}
			Double RealSpeed = Speed;
			If (Crouching)
				Speed *= 0.7;
			KAI_MoveTowards(TargetTurret.Pos,0.5,TurnRadius,ChaseFlags);
			Speed = RealSpeed;
			Return;
		}
		
		//If (KAI_DebugPrintMessages)console.printf ("SM_RunAway(): NearbyCoverPos is %d %d %d",nearbycoverpos);
		//If (KAI_Math.IsEmptyVector3 (NearbyCoverPos))
		//{
			Double RealSpeed = Speed;
			If (Crouching)
				Speed *= 0.7;
			KAIMoveParams Data;
			Data.CornerDist = 384;
			Data.CornerDiv = 12; //Check every 32 MU, seems reasonable.
			Data.ObstacleDist = 128;
			Data.ObstacleSlices = 16;
			KAI_MoveAway (Other, 16, RunRad, MaxSteps, 0.5, TurnRadius, ChaseFlags, Flags, 0, RetreatPos, extraparams:Data);
			Speed = RealSpeed;
		/*	If (!HazardToAvoid) NearbyCoverPos = SM_LocateNearbyCover (Other);
		}
		Else
		{If (KAI_DebugPrintMessages)console.printf ("SM_RunAway(): %p retreating behind cover at %d %d %d",Self,NearbyCoverPos);
			SM_RunToCoverPos (Other,1,False); //Handle running to cover, specifically giving up if the cover is no longer good.
			KAI_MoveTowards (NearbyCoverPos, 0.5, TurnRadius, ChaseFlags);
		}*/
	}
	
	//Returns true if the marine is down on the ground in some capacity, as opposed to standing up.
	Bool SM_IsCrouched()
	{
		Return (Crouching || MarineState & (MARINE_KNEELING|MARINE_LYINGDOWN|MARINE_INCOVER));
	}
	
	//DECORATE-esque function for use in states.
	Void SM_SetMarineState (Int Add, Int Remove, Bool RemoveAll = False, Int Exceptions = 0/*, Int Action = 0*/)
	{
		If (!RemoveAll)
			MarineState &= ~Remove;
		Else
		{
			If (!Exceptions)
				MarineState = 0;
			Else
				MarineState &= Exceptions; //Remove all bits, excepts the ones passed in the Exceptions bitfield.
		}
		MarineState |= Add;
	}
	
	//Credit: Lewisk3
	actor SM_FireGrenade(Actor toAct, class<Actor> nade, double maxPitch = 90, double aimSens = 1.1, double aimDist = 128)
	{
		if(!toAct) return null;
		
		// Source and Destination
		vector3 fromPos = (
			pos.xy,
			pos.z + (height)
		);
		vector3 toPos = (
			toAct.pos.xy, 
			toAct.pos.z + (toAct.height * 0.5) 
		);
		
		vector3 diff = level.vec3diff(fromPos, toPos);
		
		// Spawn grenade, calculate values from instance.
		let nade = Spawn(nade, fromPos);
		if(!nade) return null;    
		nade.target = self;
		nade.tracer = target; //Pass target as tracer.
		
		// Modify toPos Z component based on how many units the thrown grenade
		// falls by the time it reaches the destination.
		double dist = diff.xy.Length();
		if(dist >= aimDist)
		{
			double grav = 1.0 + ceil(nade.GetGravity() * (level.gravity * 0.010769));
			double ticsDist = diff.Length() / double(max(nade.Speed,1.0));        
			double fallDist = ticsDist * grav;
			toPos.z += fallDist * aimSens;
		}
		
		// Recalculate differences.
		diff = level.vec3diff(fromPos, toPos);
		double aimPitch = VectorAngle( sqrt(diff.y*diff.y + diff.x*diff.x), diff.z );
		aimPitch = min(aimPitch, maxPitch);
		
		// Modify grenade velocity
		double a = AngleTo(toAct);
		double p = -aimPitch;
		nade.vel = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * nade.Speed;
		return nade;
	}
	
	//Give marines in an area a slight delay in how quickly they'll throw their next grenade, to prevent marines spamming like 2 grenades where it makes no sense.
	Void SM_AnnounceGrenadeThrow (Double Range = 384)
	{
		If (!Target) Return;
		
		Int Delay;
		Switch (AssessThreatLevel(Target))
		{
			Case THREAT_UNSTOPPABLE:
			Case THREAT_SUPERDANGER:
			Case THREAT_VERYDANGEROUS:
				Return; //Spam at will.
			Case THREAT_DANGEROUS:
				Delay = GameTicRate;
				Break;
			Case THREAT_ABOVENORMAL:
				Delay = GameTicRate*2;
				Break;
			Default:
				Delay = GameTicRate*3;
				Break;
		}
		
		ForEach(Mo : BlockThingsIterator.Create(Self, Range))
		{
			If (Mo && Mo Is "SM_Marine" && !SM_Marine(Mo).GrenadeDelay && !IsDead(Mo) && !Mo.bDormant && !IsActorHostile(Mo) && Distance3DSquared(Mo) <= Range*Range && CheckSight(MO,SF_IGNOREWATERBOUNDARY))
				SM_Marine(Mo).GrenadeDelay += Delay;
		}
	}
	
	State SM_CheckRefire (Int Chance, StateLabel AbortState, Double FOV = 360)
	{
		If (CurSector.Flags & Sector.SECF_NOATTACK)
			Return FindState (AbortState);
		
		AimPos = GetFAFAimPos (Target);
			
		If (Random2[pr_monsterrefire]() < Chance)
			Return State (Null);
		
		If (!Target || IsDead (Target) || (Target && !CheckFOV (Target,FOV)))
			Return FindState (AbortState);
		
		Double OldHeight = Height;
		If (SM_IsCrouched())
			Height = Default.Height; //Uncrouch for the sight check.
		
		If (!CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES))
		{
			Height = OldHeight;
			Return FindState (AbortState);
		}
		Height = OldHeight;
		
		Return State (Null);
	}
	
	//Marines just fire SM_Bullet, so for now at least, so we mostly just need the trace offsets.
	Bool, TraceResults SM_CheckLOF (Vector3 CheckOffsets = (0,0,32), Int PropHealthThreshold = 25, Bool AimingAt = False)
	{
		Let Check = New ("KAI_ProjectileLOFCheck");
		
		AimPos = GetFAFAimPos (Target);
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Target)
			{
				Double PitchTo = PitchTo (Target,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Target), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False, Null; //Actor stopped existing, so no need to fire.
		}
		
		Double Distance = (!AimingAt || AimingAt && !Target) ? MaxTargetRange : Distance3D (Target)+8;
		Check.Shooter = Self;
		Check.Other = Target;
		Check.PropHealthThreshold = PropHealthThreshold; //This can depend on factors like how many rounds the marine is firing.
		Check.FriendlyFire = True;
		
		Check.ProjInfo = New ('LOFProjInfo'); //Assign data class.
		Check.ProjInfo.Projectile = "SM_Bullet"; //Pass projectile class to ProjInfo.
		Check.ProjInfo.InitializeProjectileInfo(); //Let it infer the rest.
		
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Distance,0);
		
		//FSpawnParticleParams Debug; Debug.Lifetime = 8;
		//KAI_LOFRaycast.VisualizeTracePath (Level.Vec3Offset (Pos,CheckOffsets),Check.Results.HitPos,Check.Results.Distance,params:Debug);
		Bool BadLoaf = Check.BadLOF;
		If (Check.ProjInfo) Check.ProjInfo.Destroy();
		Check.Destroy();
		Return !BadLoaf, Check.Results;
	}
	
	Bool SM_FindInLOF (Actor Who, Vector3 CheckOffsets = (0,0,32), Bool AimingAt = False)
	{
		Let Check = New ("SM_FindTargetInLOF");
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Who)
			{
				Double PitchTo = PitchTo (Who,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Who), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Check.Shooter = Self;
		Check.Other = Who;
		Check.BadLOF = True; //We have to assume the LOF is bad, and if the trace finds the other actor, then it's a good LOF.
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,MaxTargetRange,0);
		Bool Res = Check.BadLOF;
		Check.Destroy();
		Return !Res;
	}
	
	//Get what part of the actor the marine is aiming at now.
	Double GetAimPosOffset ()
	{
		If (!Target)
			Return 0;
		Switch (AimPos)
		{
			Case FAF_MIDDLE:
				Return Target.Height/2;
			Case FAF_TOP:
				Return Target.Height;
			Case FAF_BOTTOM:
				Return 0; //The bottom is the origin of actors.
			Default:
				Return 0;
		}
	}
	
	//Return what grenade type is likely currently appropriate against the enemy.
	Int DecideGrenadeType (Actor Against, Int Threshold = MARINE_GRENADECHANCE)
	{
		//Don't bother if the other actor doesn't exist, it's not time yet, or if the enemy flies and is over your head !
		If (Threshold <= 0 || !Against || GrenadeDelay || IsFlying (Against) && Pos.Z+Height < Against.Pos.Z) Return GRENADE_NONE;
		//Not in throwing range. Or there is no direct LOF, yes, this doesn't account for arcing, I WILL NOT TRY.
		If (Distance3DSquared (Against) >= MARINE_GRENADERANGE*MARINE_GRENADERANGE || !SM_CheckLOF((0,0,Height),0))
		{
			If (KAI_DebugPrintMessages) Console.Printf ("DecideGrenadeType(): Target is too far or the LOF is bad");
			Return GRENADE_NONE;
		}
		
		Bool ImmuneToBlasts = (Against.bNoRadiusDmg || Against.GetRadiusDamage (Against,256,256,128,False,True) <= 256/8); //The enemy is immune or HIGHLY resistant to blasts.
		Bool UseHE, UseSmoke, UseStun;
		
		//Decide to throw the HE-FRAG grenade without the frag sleeve. Large blast radius and damage, good for strong enemies.
		//Based on RNG, if the target is super powerful, and if it's not effectively immune to pure explosion damage.
		If (!ImmuneToBlasts && (Random (0,255) < 96 || AssessThreatLevel (Against,False) >= ThreatLevelThreshold))
		{
			//Might throw a stun grenade
			If (Random (0,255) < 32 && SM_StunGrenade.CanStun(Against))
				UseStun = True;
			//Randomly decide to throw smoke, as long as the enemy CAN be affected by the smokescreen.
			Else If (Random (0,255) < 120 && (!Against.bSeeInvisible || Against.bShadowAim || Against.Player) && (Against.Player || Against.bDoShadowBlock))
				UseSmoke = True;
			Else
				UseHE = True;
		}
		
		//Lol, lmao, even.
		If (Random (0,255) < 128 && (IsIndestructible(Against) || HasGodMode (Against) || HasBuddha (Against)))
		{
			If (!(!Against.Player && Against.bNoPain) || !SM_StunGrenade.CanStun(Against))
			{
				UseStun = True;
				UseHE = UseSmoke = False;
			}
		}
		
		//Now, let's check the chance of actually throwing a grenade.
		Int BulletDamage = Against.ApplyDamageFactor ("SmallRifleBullet",100); //Return how much damage the actor would actually take if 10 bullets did maximum damage.
		Int GrenChance = (Threshold > 0) ? Random (0,Threshold-24) : INT.MAX;
		//Set chance of throwing lethal grenade.
		If (Threshold > 0 && !UseSmoke && !UseStun)
		{
			GrenChance += 100-BulletDamage; //Increase grenade chance based on how much bullet damage the enemy can absorb.
			GrenChance += SM_AttackByQuantity (Against,!UseHE ? 192 : 256,True); //Grenade chance is also based on crowd size.
		}
		
		//Throwing non-lethal grenade.
		Else If (Threshold > 0)
		{
			If (Against.Speed <= 6) //Our target is quite slow, so more likely to throw a nonlethal grenade.
				GrenChance += 32;
			
			If (UseStun)
				GrenChance += SM_AttackByQuantity (Against,256,False,ABQ_Smokescreen);
			Else If (UseSmoke)
				GrenChance += SM_AttackByQuantity (Against,256,False,ABQ_Stunner);
		}
		
		If (GrenChance >= Threshold) //Decide if you should throw an HE or frag grenade.
		{
			If (KAI_DebugPrintMessages) Console.Printf ("DecideGrenadeType(): Grenade chance is over the threshold, UseHE is %d, UseSmoke is %d",UseHE,UseSmoke);
			If (UseHE)
				Return GRENADE_HE;
			Else If (UseSmoke)
				Return GRENADE_SMOKE;
			Else If (UseStun)
				Return GRENADE_STUN;
			Else
				Return GRENADE_HEFRAG;
		}
		
		Return GRENADE_NONE;
	}
	
	//Prepare to throw a smoke grenade in front of you before retreating. That is to say like when running to reload.
	Bool PrepareForSmokeThrow (Int Chance = 48)
	{
		If (Target && Distance3DSquared (Target) <= 256*256) //If the target is too close, don't bother. Like if running away from a melee enemy.
			Return False;
		
		Chance += SM_AttackByQuantity (Target,flags:ABQ_Smokescreen); //Increase chance the more danger there is around the target.
		
		If (Health <= SpawnHealth()/3) //Extra chance if low on health.
			Chance += 30;
		
		If (Random (0,255) >= Chance)
			Return False;
		
		//SM_SetMarineState (MARINE_RETREAT,MARINE_IDLING|MARINE_CHASING); //Specifies to the grenade drop state that the marine needs to retreat afterwards.
		GrenadeType = GRENADE_SMOKE;
		QuickGrenade = True;
		Return True;
	}
	
	Enum ABQFlags
	{
		ABQ_Smokescreen = 1 << 0, //If on, ignore actors that can see through DOSHADOWBLOCK, unless they are players. 
		ABQ_Infight		= 1 << 1, //Give bonus points for monsters that can infight. Based on how many other monsters that can infight are found in Range.
		ABQ_Stunner		= 1 << 2, //Ignore NPCs that won't painlock from the flashbang, players still count tho since they actually get flashed.
	}
	
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks. Copied from the MVP !.
	//Range: The range around which to check for enemies.
	//AvoidAllies: Deduct points from the score for any allies in the AOE.
	//Smokescreen: This is a check for if the marine is throwing a smoke grenade. Makes actors that can see throw the smoke be ignored from the count.
	Int SM_AttackByQuantity (Actor Origin, Double Range = 256, Bool AvoidAllies = False, Int Flags = 0)
	{
		If (!Origin) Return 0;
		Actor Mobj;
		Int Chance;
		Bool IsHostile, IsVisible; //Caching
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Origin,Range);
		
		Int ViableEnemies;
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (!Mobj || IsDead (Mobj) || IsInanimateObject (Mobj) || Mobj == Self/* || Mobj == Origin*/) Continue;
			
			IsHostile = IsActorHostile (Mobj); IsVisible = IsVisible (Mobj,False);
			If (AvoidAllies && !IsHostile && IsVisible)
			{
				If (Mobj.bIsMonster) Chance -= 10;
				If (Mobj.Player) Chance -= 40;
				Continue;
			}
			
			//Actor can see through smoke grenades, because it's an NPC that's unfazed by SHADOWBLOCK.
			If (Flags & ABQ_Smokescreen && IsHostile && IsVisible && !(!Mobj.bSeeInvisible || Mobj.bShadowAim || Mobj.Player) && (Mobj.Player || Mobj.bDoShadowBlock))
				Continue;
			
			//Actor is immune to painlocking from the stun grenade.
			If (Flags & ABQ_Stunner && Mobj.bNoPain && !Mobj.Player)
				Continue;
			
			If (IsHostile)
				ViableEnemies++;
			
			If (Flags & ABQ_Infight && IsHostile && IsVisible && Mobj.OkayToSwitchTarget (Origin))
				Chance += ViableEnemies; //Give an additional bonus if the monster can infight with the target, based on every additional monster in range.
			
			If (IsHostile && IsVisible && Mobj.Distance3DSquared (Origin) <= Range*Range)
			{
				//Don't inherently consider players are more dangerous, mainly for grenade spam reasons.
				Switch (AssessThreatLevel (Mobj,False))
				{
					Case THREAT_UNSTOPPABLE:
						Chance += 500;
						Break;
					Case THREAT_SUPERDANGER:
						Chance += 200;
						Break;
					Case THREAT_VERYDANGEROUS:
						Chance += 80;
						Break;
					Case THREAT_DANGEROUS:
						Chance += 40;
						Break;
					Case THREAT_ABOVENORMAL:
						Chance += 20;
						Break;
					Case THREAT_NORMAL:
						Chance += 10;
						Break;
					Case THREAT_MILD:
						Chance += 8;
						Break;
					Case THREAT_LOW:
						Chance += 5;
						Break;
					Case THREAT_VERYLOW:
						Chance += 1;
						Break;
					Case THREAT_NONE:
						Break;
					Default:
						Chance += 1;
						Break;
				}
			}
		}
		
		Return Chance;
	}
	
	//Alert every KAI NPC in range of your current target, unless they're busy already.
	Void SM_AlertNearbyAllies (Double Range = 512, Bool IgnoreCreatures = False)
	{
		If (SM_IsRestricted (RESTRICT_WARNALLIES) || Range <= 0) Return;
		BlockThingsIterator FindAllies = BlockThingsIterator.Create (Self,Range);
		Actor Mobj;
		Bool AlertedSomeone;
		Array <Actor> Alerted;
		
		While (FindAllies.Next())
		{
			Mobj = FindAllies.Thing;
			If (!Mobj || IsDead (Mobj) || IsInanimateObject (Mobj) || Mobj == Self || Mobj.Target) Continue;
			
			If (!(Mobj Is "KAI_Actor") || IgnoreCreatures && Mobj Is "KAI_Creature" || IsActorHostile (Mobj)) Continue;
			
			If (Distance3DSquared (Mobj) > Range*Range) Continue;
			
			KAI_Actor(Mobj).KAI_ShareTarget(Self,Target);
			//NOTE: Marines need to have their LastSeenPos set to something to move towards the enemy, otherwise they just try following something instead.
			If (Mobj Is "SM_Marine")
				SM_Marine(Mobj).LastSeenPos = Target.Pos;
			AlertedSomeone = True;
			Alerted.Push (Mobj);
		}
		
		//Alert all actors in the groups you are leading chase that target if possible. If not alerted already.
		ForEach (Group : Groups)
		{
			If (Group.Leader != Self) Continue;
			ForEach (Member : Group.Members)
			{
				If (Member Is "KAI_Actor" && Alerted.Find(Member) == Alerted.Size() && Member != Self)
				{
					KAI_Actor(Member).KAI_ShareTarget (Self,Target);
					AlertedSomeone = True;
					Alerted.Push (Member);
				}
			}
		}
		
		If (AlertedSomeone)
		{
			If (Random (0,256) == Random (0,256))
				A_StartSound ("Marine/AlertAlliesAlt",CHAN_VOICE,attenuation:0.75);
			Else
				A_StartSound ("Marine/AlertAllies",CHAN_VOICE,attenuation:0.75);
		}
	}
	
	HazardInfo GetNearestHazard (Array<HazardInfo> HazardList)
	{
		Double ClosestDist = INT.MAX;
		HazardInfo Closest;
		
		ForEach (CurHaz : HazardList)
		{
			If (CurHaz)
			{
				If (CurHaz.Flags & HazardInfo.HAZ_SECTOR) //The first hazard found in the same sector as you is the closest.
					Return CurHaz;
				
				Double Dist = GetHazardDistance (CurHaz);
				If (Dist < ClosestDist)
				{
					ClosestDist = Dist;
					Closest = CurHaz;
				}
			}
		}
		
		Return Closest;
	}
	
	HazardInfo GetStrongestHazard (Array<HazardInfo> HazardList)
	{
		Int StrongestHaz = HazardInfo.HAZARD_HARMLESS;
		HazardInfo Strongest;
		
		ForEach (CurHaz : HazardList)
		{
			If (CurHaz)
			{
				Int Strength = CurHaz.Level;
				If (Strength > StrongestHaz)
				{
					StrongestHaz = Strength;
					Strongest = CurHaz;
				}
			}
		}
		
		Return Strongest;
	}
	
	Enum RunAwayTypes
	{
		RUN_NONE, //The marine doesn't need to move away at all.
		RUN_WALK, //The marine should probably avoid it, but just walk around it if possible, since it's not that serious.
		RUN_FAST, //Stop what you are doing and run away. Original marine behavior to grenades and the old SM_ImInDanger token.
	}
	
	//How should the marine run away from this hazard zome, if at all ?
	RunAwayTypes SM_ShouldRunFromHazard (HazardInfo Hazard)
	{
		If (!Hazard || !bAvoidHazards)
			Return RUN_NONE;
		
		//Run away from actually dangerous threats, or if the hazard in question is weak but you are close to dying.
		If (Hazard.Level >= HazardInfo.HAZARD_MEDIUM || Hazard.Level != HazardInfo.HAZARD_HARMLESS && Health <= SpawnHealth()/3)
			Return RUN_FAST;
		
		//Dealing with a minor threat, so just walk around it if not doing anything else and not low on health.
		If (Hazard.Level < HazardInfo.HAZARD_MEDIUM && Hazard.Level != HazardInfo.HAZARD_HARMLESS)
			Return RUN_WALK;
		
		Return RUN_NONE;
	}
	
	//Check if the marine should taunt after kill their target in an attack state.
	Bool SM_CheckTaunt (Actor Victim, Int Chance = 64)
	{
		If (!Victim)
			Return False;
		
		//We just killed a powerful enemy.
		If (IsDead(Victim) && IsActorHostile(Victim) && Victim.Target == Self && (Target.Player || AssessThreatLevel(Victim,checkdead:True) >= ThreatLevelThreshold))
			Return (Random(0,255) < Chance);
		Return False;
	}
	
	//Search for dangerous enemies around you.
	Bool IsDangerNearby (Double Range = 1024, Bool DistOnly = False, Vector3 CheckPos = (Double.NaN, Double.NaN, Double.NaN))
	{
		//My target is visible, that's an enemy. Or they're just very dangerous.
		If (!DistOnly && Target && (CheckSight (Target, SF_IGNOREWATERBOUNDARY) || AssessThreatLevel(Target,False) >= ThreatLevelThreshold))
			Return True;
		
		If (!DistOnly)
		{
			For (Int pn = 0; pn < MAXPLAYERS; pn++)  //An enemy player is visible, now THAT'S an enemy.
			{
				If(!PlayerInGame[pn])
					Continue;
				PlayerInfo plr = Players[pn];
				
				If (Plr && !IsFriend (Plr.Mo) && CheckSight(Plr.Mo,SF_IGNOREWATERBOUNDARY))
					Return True;
			}
		}
		
		//Look for dangerous enemies.
		Vector3 ThePos = !DistOnly && KAI_Math.IsEmptyVector3(CheckPos) ? Self.Pos : CheckPos;
		BlockThingsIterator FindEnemies = BlockThingsIterator.CreateFromPos (ThePos.X,ThePos.Y,ThePos.Z,Height,Range,False);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsInanimateObject(Mobj) || IsDead (Mobj) || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			Return True;
		}
		
		Return False;
	}
	
	Actor SM_FindAllyToHelp (Double Range = 1024, Int HealthThreshold = 7)
	{
		If (SM_IsRestricted(RESTRICT_HEALING)) Return Null;
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		Array <Actor> Friends; //Store nearby allies to potentially heal.
		Array <Actor> Marines; //And friendly marines too, to ignore allies another marine is going to anyway.
		Array <Actor> Players; //Store found players, so they take priority if they aren't targeted for healing to begin with.
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
		
			//If the ally is indestructible, not even alive, a prop, or hasn't lost more than 7 HP, we don't need to help them.
			If (!Mobj || Mobj == Self || IsIndestructible(Mobj) || IsInanimateObject (Mobj) || IsDead (Mobj) || SM_GetMaxHealth (Mobj)-HealthThreshold < Mobj.Health)
				Continue;
			
			If (Mobj.bNoBlood) //Don't heal inorganic things like robots and vehicles.
				Continue;
			
			If (IsActorHostile (Mobj)) //Duh
				Continue;
			
			//Out of range, sight, or reach, in order of cost.
			If (Distance3DSquared (Mobj) > Range*Range || !CheckSight (Mobj,SF_IGNOREWATERBOUNDARY) || !SM_IsPosReachable (Mobj.Pos,ignoreactors:True))
				Continue;
			
			If (Mobj Is "SM_Marine")
				Marines.Push (Mobj);
			
			If (Mobj.Player)
				Players.Push (Mobj);
			Friends.Push (Mobj);
		}
		
		//Ignore this if no other marines are near anyway.
		If (Marines.Size() > 0 && Friends.Size() > 0)
		{
			Actor HealTarg;
			//Check every nearby friendly marine to ignore allies they are already going to heal.
			For (Int I = Marines.Size()-1; 0 <= I; I--)
			{
				If (Marines[I] && (HealTarg = SM_Marine(Marines[I]).HealTarget))
					Friends.Delete (Friends.Find (HealTarg)); //This ally is already going to be healed.
			}
		}
		
		If (Players.Size() > 0) //Just pick the first player you find.
			Return Actor(Players[0]);
		
		//If (Friends.Size() > 0)
		//	Return Friends[Random (0,Friends.Size()-1)];
		If (Friends.Size() > 0)
		{
			Int LowestHealth = INT.MAX;
			Actor WeakestActor = Friends[Random (0,Friends.Size()-1)]; //Pick a random one just in case the sort fails or someshit.
			
			For (Int I = Friends.Size()-1; I >= 0; I--)
			{
				Int CurrentHealth = Friends[I].Health;
				If (LowestHealth > CurrentHealth)
				{
					LowestHealth = CurrentHealth;
					WeakestActor = Friends[I];
				}
			}
			
			Return WeakestActor;
		}
		
		Return Null;
	}
	
	Enum StrafeDirections
	{
		STRAFE_RANDOM = -1, //Strafe in a random direction.
		STRAFE_NONE = 0, //Don't strafe.
		STRAFE_LEFT = 1, //Strafe left.
		STRAFE_RIGHT = 2 //Strafe right.
	};
	
	//After a projectile to dodge is found by SM_Projectile, this function handles picking a direction, if any, to dodge out of the way towards.
	Bool SM_HandleDodging (Actor Projectile, Bool DontJump = False)
	{
		If (!Projectile || bDormant || IsDead(Self) || Pos.Z > FloorZ+8 || SM_IsRestricted (RESTRICT_DODGING)) Return False;
		If (KAI_DebugPrintMessages)
			Console.Printf ("SM_HandleDodging(): Dodged a %s",Projectile.GetClassName());
		
		//The marine is behind cover but not crouching, so dodge by going prone.
		If (MarineState & MARINE_INCOVER)
		{
			Crouching = True;
			Height = MARINE_CROUCHHEIGHT;
			GrenadeDelay += GameTicRate/2;
			NextFireDelay += GameTicRate/2;
			If (MarineState & MARINE_FIRING)
				SetStateLabel ("Fire.End");
			Return True;
		}
		
		Bool IsHoming = Projectile.bSeekerMissile;
		//HACK: Why did Carmack fucking code the stupid rocket like this.
		If (Projectile.GetClassName() == "RevenantTracer")
			IsHoming = Projectile.FindInventory ("SM_RevenantTracerToken");
		//Try to run from homing projectiles chasing you that are slower than 25 mu/tic...
		If (IsHoming && Projectile.Tracer == Self && Projectile.Speed <= 25 &&
		//...and as long as it does too much damage to you. TODO: Make it account for ALL damage methods, damage factors, virtual overrides, and armor items!
		(Health <= SpawnHealth()/3 || ApplyDamageFactor(Projectile.DamageType,Projectile.GetMissileDamage (1,7)) >= Health/6))
		{
			RetreatPos = Projectile.Pos;
			RetreatLoops = 4;
			DodgingHomingProjectile = True;
			SetStateLabel ("Retreat");
			Return True;
		}
		
		Bool RightSafe, LeftSafe;
		Double OldAngle = Angle; //Store the current angle before facing the projectile to dodge it.
		Double OldDropoffHeight = MaxDropoffHeight;
		
		MaxDropOffHeight = 128; //Temporarily increase the maximum height the marine can drop from.
		
		If (CheckFOV (Projectile,120/2)) //Marines will only know the movement direction if they can actually see it.
			Angle = VectorAngle (Projectile.Vel.X,Projectile.Vel.Y)-180; //Jump away from the projectiles' movement direction.
		
		//Check if it's safe to strafe 56 map units to the left or right, or both. Or none even, like in the case of crammed corridors.
		Bool DecidedLeft, DecidedRight;
		Double Delta = DeltaAngle (Angle,AngleTo(Projectile));
		If (Delta >= -2 && (Random (0,255) < 200 || IsFast(Self))) //No, the projectile is heading too much towards the left side.
		{
			LeftSafe = False;
			DecidedLeft = True;
		}
		Else If (Delta <= 2 && (Random (0,255) < 200 || IsFast(Self))) //Ditto, but for the right side.
		{
			RightSafe = False;
			DecidedRight = True;
		}
		
		If (!DecidedLeft) LeftSafe = CheckMove (Vec2Angle (56,Angle+90),PCM_DROPOFF);
		If (!DecidedRight) RightSafe = CheckMove (Vec2Angle (56,Angle-90),PCM_DROPOFF);
		
		Int StrafeDirection;
		
		If ((LeftSafe && RightSafe)) //Both directions are safe to strafe to.
			StrafeDirection = STRAFE_RANDOM;
		Else If ((!LeftSafe && !RightSafe)) //The area is too crammed to strafe anywhere here.
		{
			Angle = OldAngle; //Revert the marines' angle if you can't dodge.
			StrafeDirection = STRAFE_NONE; //Reset the strafe direction to none.
			MaxDropOffHeight = OldDropoffHeight; //Revert the property to the default again.
			Return False; //Don't break whatever state sequence the marine is currently in to tell him he can't dodge.
		}
		Else If (LeftSafe && !RightSafe) //Can only strafe left.
			StrafeDirection = STRAFE_LEFT;
		Else If (!LeftSafe && RightSafe) //Can only strafe right.
			StrafeDirection = STRAFE_RIGHT;
		
		MaxDropOffHeight = OldDropoffHeight; //Revert the property to the default again.
		
		If (!DontJump) //Don't jump in both the literal and Doom state machine sense.
		{
			Double JumpAng = StrafeDirection == STRAFE_RANDOM ? Angle+RandomPick (90,-90) : 0;
			If (StrafeDirection == STRAFE_LEFT)
				JumpAng = Angle+90;
			Else If (StrafeDirection == STRAFE_RIGHT)
				JumpAng = Angle-90;
			JumpPos.XY = Vec2Angle (96,JumpAng);
			JumpPos.Z = GetZAt (JumpPos.X,JumpPos.Y)+(Height/2);
			SetStateLabel ("Jump.Dodge");
		}
		
		Return True; //Found a direction to strafe at to dodge.
	}
	
	Enum DodgePickModes
	{
		DODGE_FIRST, //Simplest and cheapest, just dodge the first valid projectile found. Also how the marines originally dodged.
		DODGE_RANDOM, //Idiot mode.
		DODGE_STRONGEST, //Dodge the strongest projectile in range.
		DODGE_NEAREST, //Dodge the closest projectile in range.
	}
	
	//Find and return a pointer to a projectile for the marine to dodge.
	//Because the default dodge radius is smaller than the grenade hazard radius, they run from grenades anyway. So no special handling for that.
	//Up to you if you set User_DodgeRange higher than the hazard radius of the grenades.
	Actor SM_ShouldDodgeProjectile (Double Range = 384, Int DodgeMode = DODGE_STRONGEST, Actor Ignore = Null)
	{
		If (Range <= 0) //No dodging.
			Return Null;
		Array <Actor> Threats;
		
		//Actually find projectiles.
		ForEach (Proj : KAIHandler.ProjectileList)
		{
			If (!Proj) Continue;
			
			Bool DodgeAllyProjectiles; //If on, the marine will dodge the projectile even if it's fired by an ally.
			
			Bool IsHoming = Proj.bSeekerMissile;
			//HACK: Why did Carmack fucking code the stupid rocket like this. This is literally THE WORST way to implement a homing projectile!!!!!
			If (Proj.GetClassName() == "RevenantTracer")
				IsHoming = Proj.FindInventory ("SM_RevenantTracerToken");

			Double Dist = Distance3DSquared (Proj);
			If ((Dist > Range*Range || IsHoming && Proj.Tracer == Self && Dist > (Range*Range)*2 ) || Proj == Ignore) //Out of range or put on ignore. But if it's a seeker, check at double the range to potentially run away.
				Continue;
			
			//Dodge even friendly projectiles if they'd do too much damage, unless friendly fire is off.
			DodgeAllyProjectiles = (!(Proj Is "KAI_BaseProjectile" && KAI_BaseProjectile(Proj).bNoFriendlyFire) && Proj.GetMissileDamage (1,7) >= Health/2);
			
			If (!DodgeAllyProjectiles && !IsActorHostile (Proj.Target)) //Ignore friendly projectiles.
				Continue;
			
			//Don't return true if the projectile is too far away from the marines' peripheral vision. Or if it isn't so close that it's impossible not to notice it.
			If (!CheckFOV (Proj,120/2) && Dist > (MeleeRange*MeleeRange)*3)
				Continue;
			
			//Is the projectile about to hit me ? Weird math nonsense written by RaveYard.
			double blackBox = -0.15;
			If (IsHoming && Proj.Tracer == Self) blackBox = -0.075;
			bool projectile_is_flying_towards_me = (Vec3To(proj).Unit() dot proj.vel.Unit()) < blackBox;
			double projectileSafeRadius = sqrt(2 * ((proj.radius + radius) ** 2.5));
			if(projectile_is_flying_towards_me && KAI_Math.distance3dline(pos, proj.pos, proj.pos + proj.vel) < projectileSafeRadius && CheckSight(Proj,SF_IGNOREWATERBOUNDARY))
			{
				If (DodgeMode != DODGE_FIRST)
					Threats.Push (Proj);
				Else
					Return Proj;
			}
		}
		
		If (DodgeMode == DODGE_RANDOM)
			Return (Threats[Random (0,Threats.Size()-1)]);
		Else If (DodgeMode == DODGE_NEAREST)
		{
			Double NearestDistance = INT.MAX;
			Actor NearestProj;
			For (Int I = Threats.Size()-1; I >= 0; I--)
			{
				Double CurrentDistance = Distance3D(Threats[I]);
				If (NearestDistance > CurrentDistance)
				{
					NearestDistance = CurrentDistance;
					NearestProj = Threats[I];
				}
			}
			
			Return NearestProj;
		}
		Else If (DodgeMode == DODGE_STRONGEST)
		{
			Double HighestDamage;
			Actor StrongestProj;
			For (Int I = Threats.Size()-1; I >= 0; I--)
			{
				Double CurrentDamage = Threats[I].GetMissileDamage(1,7);
				If (HighestDamage < CurrentDamage)
				{
					HighestDamage = CurrentDamage;
					StrongestProj = Threats[I];
				}
			}
			
			Return StrongestProj;
		}
		
		Return Null;
	}
	
	//Runs the code that checks if the marine has landed on the ground again while mid-air.
	State SM_JumpLoop (Bool DodgeAttack = False)
	{
		If (DodgeAttack) //Aim towards a target to shoot at while dodging, only useful for Jump.Dodge.Attack:, really.
		{
			Actor Targ = Target;
			
			If (LastDodged && LastDodged.Target && AbsAngle(Angle,AngleTo(LastDodged.Target)) <= 25 && IsActorHostile(LastDodged.Target) && CanBeTargeted (Self, LastDodged.Target))
				Target = LastDodged.Target;
			
			AimAtTarget (8,8,attackspeed:170,200);
			
			Target = Targ;
		}
		
		bNoGravity = Default.bNoGravity; //We're checking for a landing? Then we shouldn't be floating.
		If (!SM_IsRestricted (RESTRICT_CLIMBING)) KAI_HandleClimbing(ClimbPos,Null,"Climb",Null,1.1,1.75);
		If (bOnMobj || Pos.Z <= GetZAt () || Pos.Z <= FloorZ) //The eagle has landed.
		{
			bNoFriction = Default.bNoFriction;
			A_Stop(); //Stop moving.
			GiveInventory ("SM_DropoffToken",1); //HACK: Zandronum Moment
			If (DodgeAttack) //We were firing while we were dodging, so specify that we're no longer MARINE_FIRING.
				SM_SetMarineState (0,MARINE_FIRING);
			If (MarineState & MARINE_IDLING) //We were bing chilling, go back to that.
				Return FindState ("Idle",True);
			//We were looking to reload at the time of the dodge.
			If (MarineState & MARINE_RELOAD)
				If (RetreatLoops) //Go back to retreating instead of reseting the retreat counter and shit.
					Return FindState ("Retreat");
				Else //Straight to reloading.
					Return FindState ("Reload");
			
			Return SeeState; //Or go back to chasing I guess.
		}
		
		Return State (Null);
	}
	
	//Identical to KAI's IsPosReachable, but also accounts for the marines' ability to climb, if available.
	Bool SM_IsPosReachable (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False, Bool DontClimb = False)
	{
		Double RealStepHeight = MaxStepHeight;
		Double RealHeight = Height;
		If (!SM_IsRestricted(RESTRICT_CLIMBING) && !DontClimb) MaxStepHeight = (Height*1.75); //Maximum height the marine can reach, by jumping and ledge grabbing.
		If (!SM_IsRestricted(RESTRICT_CROUCHING)) Height = MARINE_CROUCHHEIGHT;
		Bool Res = IsPosReachable (TargetPos, DistCutoff, Spacing, IgnoreActors);
		MaxStepHeight = RealStepHeight;
		Height = RealHeight;
		Return Res;
	}
	
	//Get the max health of actors or player pawn actors.
	Int SM_GetMaxHealth (Actor Other)
	{
		If (!Other)
			Return 0;
		
		If (Other.Player)
			Return Other.GetMaxHealth();
		
		Return Other.SpawnHealth();
	}
	
	//====|Non-AI functions|====\\
	//Handles the coloring of the marines. And if the string says "Random" returns a random available color string.
	String SM_HandleMarineColoring (String WhatColor)
	{
		If (!WhatColor || WhatColor ~== "") Return WhatColor; //Don't run the code if the string is empty.
		
		//Handles the random color choice that is performed if the color name given is "Random".
		If (WhatColor ~== "Random")
		{
			Static Const String ColorArray[] = {"Red","Gray","White","Black","Blue","Yellow","Orange","Pink","DarkGreen","DarkRed","Default"}; //Contains all the valid color names.
			
			WhatColor = ColorArray[Random(0,ColorArray.Size()-1)]; //Randomly picks a color string.
		}
		
		If (!(WhatColor ~== "Default"))
			A_SetTranslation (String.Format("Marine_%s", WhatColor));
		Else
			A_SetTranslation ('');
		
		Return WhatColor;
	}
	
	//Change what sprite frame to display based on the marines' pitch.
	Int SM_UpdateElevation (Int Down, Int Straight, Int Up, Int KneelDown = -1, Int KneelStraight = -1, Int KneelUp = -1, Int LyingDown = -1)
	{
		If (Crouching) //Don't update if crouching, since the marine has no aim sprites when crouching, obviously.
			Return CurState.Frame;
		
		If (MarineState & MARINE_LYINGDOWN)
			Return LyingDown;
		
		If (!(MarineState & MARINE_KNEELING))
		{
			If (Pitch <= -15)
				Return Up;
			Else If (Pitch >= 10)
				Return Down;
		}
		Else
		{
			If (Pitch <= -15)
				Return KneelUp;
			Else If (Pitch >= 10)
				Return KneelDown;
		}
		
		If (!(MarineState & MARINE_KNEELING))
			Return Straight;
		Else
			Return KneelStraight;
	}
	
	//Update height based on marine state, used when the marine is firing while kneeling or lying down, and in the future when crouching.
	Void SM_UpdateHeight ()
	{
		If (Crouching) Return; //Crouching doesn't need updating from here, that's KAI_HandleCrouching()'s and SM_UpdateCover()'s job.
		
		If (MarineState & MARINE_LYINGDOWN)
			A_SetSize (newheight:8);
		Else If (MarineState & MARINE_KNEELING)
			A_SetSize (newheight:32);
		Else If (MarineState & MARINE_INCOVER && MarineState & MARINE_RELOAD) //Marine is loading while behind cover, so he's reloading kneeling down.
			A_SetSize (newheight:32);
		Else
			A_SetSize (newheight:Default.Height);
	}
	
	Void SM_FireBullet ()
	{
		A_StartSound ("Marine/Fire",CHAN_WEAPON,attenuation:0.6);
		Double FireHeight = 42;
		Double Recoil = 0.25;
		If (MarineState & MARINE_LYINGDOWN)
		{
			FireHeight = 14;
			Recoil /= 3;
		}
		Else If (MarineState & MARINE_KNEELING)
		{
			FireHeight = 32;
			Recoil /= 2;
		}
		If (Crouching)
		{
			FireHeight = 25;
			Recoil /= 3;
		}
		If (MarineState & MARINE_INCOVER)
			Recoil = 0;
		
		Actor Bullet = A_SpawnProjectile ("SM_Bullet",FireHeight,-6,flags:CMF_AIMDIRECTION,Pitch);
		Double AccuracyBuff = SM_IsCrouched() ? 0.5 : 1.0; //Double the accuracy if the marine is sitting down and firing.
		If (IsInState(Self,"Jump.Dodge.Attack")) AccuracyBuff *= 1.5; //Accuracy debuff for when firing in mid-dodge.
		
		Switch (AttackType)
		{
			Case FIRE_BURST:
				AddProjectileSpread (Bullet,(0.7,-0.7)*AccuracyBuff,(0.7,-0.7)*AccuracyBuff);
				Break;
			Case FIRE_SINGLE:
				AddProjectileSpread (Bullet,(0.4,-0.4)*AccuracyBuff,(0.4,-0.4)*AccuracyBuff);
				Break;
			Case FIRE_FULLAUTO:
				AddProjectileSpread (Bullet,(1.75,-1.75)*AccuracyBuff,(1.75,-1.75)*AccuracyBuff);
				A_Recoil (Recoil);
				Break;
		}
		A_SpawnItemEx ("SM_BulletCasing",0,-6,FireHeight,FRandom (0,-1),FRandom (-4,-8),FRandom(1,5));
		If (!User_NoReload) AmmoCount--;
	}
	
	//End the marines' firing sequence. Used by both the Fire.End: state, and when the marine abruptly dies.
	Void SM_EndFiring()
	{
		SM_SetMarineState (0,MARINE_FIRING|MARINE_THROWING|MARINE_MELEE|MARINE_KNEELING|MARINE_LYINGDOWN);
		SM_UpdateHeight();
		
		//Set the next time we decide to fire.
		If (!IsDead(Self))
		{
			If (!IsFast(Self))
				NextFireDelay = GameTicRate*Random(1,4); //Only add the timer if you didn't stop shooting by dying.
			Else
				NextFireDelay = GameTicRate*Random(1,2); //Fire twice as frequently.
				
			If (G_SkillPropertyInt(SKILLP_SLOWMONSTERS))
				NextFireDelay *= FRandom(1.2f,2);
			
			If (MarineState & MARINE_INCOVER)
				NextFireDelay /= 2; //Fire more frequently when hiding.
		}
		
		AimTimer = BurstCounter = BurstSize = 0; //Reset aim and burst counters.
		AttackType = FIRE_BURST; //Reset to default fire mode.
	}
	
	Enum RestrictableActions
	{
		RESTRICT_NOACTION, //We aren't checking any action ?
		RESTRICT_TAKECOVER, //Marine hiding behind cover.
		RESTRICT_CLIMBING, //Marine climbs over obstacles.
		RESTRICT_JUMPING, //Marine jumps over gaps.
		RESTRICT_CROUCHING, //Marine crouching under tight spaces.
		RESTRICT_SWIMMING, //Marine swimming over swimmable 3D floors.
		RESTRICT_DODGING, //Marine dodging incoming projectiles.
		RESTRICT_HEALING, //Marine occasionally giving stimpacks to allies.
		RESTRICT_WARNALLIES, //Marine warning nearby friendly marines.
		RESTRICT_RELOADRUN, //Marine running away a bit before reloading.
		RESTRICT_EMPLACEMENTS, //Marine using emplacements.
		RESTRICT_SMOKESCREENS, //Marine throwing smoke before retreating.
	}
	
	//Check if the following action is restricted by a token given from a restriction zone, or a user variable.
	Bool SM_IsRestricted (Int MarineAction)
	{
		If (MarineAction == RESTRICT_NOACTION)
			Return False;
		
		Let Token = SM_RestrictionToken(FindInventory ("SM_RestrictionToken"));
		
		If (MarineAction == RESTRICT_TAKECOVER && (User_NoCover || Token && Token.NoCover))
			Return True;
		If (MarineAction == RESTRICT_CLIMBING && (User_NoParkour || Token && Token.NoClimb))
			Return True;
		If (MarineAction == RESTRICT_JUMPING && (User_NoParkour || Token && Token.NoJump))
			Return True;
		If (MarineAction == RESTRICT_CROUCHING && (User_NoParkour || Token && Token.NoCrouch))
			Return True;
		If (MarineAction == RESTRICT_SWIMMING && (User_NoParkour || Token && Token.NoSwim))
			Return True;
		If (MarineAction == RESTRICT_DODGING && Token && Token.NoDodge)
			Return True;
		If (MarineAction == RESTRICT_HEALING && (User_HealCooldown == 0 || Token && Token.NoHeal))
			Return True;
		If (MarineAction == RESTRICT_WARNALLIES && Token && Token.NoWarn)
			Return True;
		If (MarineAction == RESTRICT_RELOADRUN && (User_RetreatFactor <= 0 || Token && Token.NoReloadRun))
			Return True;
		If (MarineAction == RESTRICT_EMPLACEMENTS && (User_TurretDelay <= 0 || Token && Token.NoEmplacements))
			Return True;
		If (MarineAction == RESTRICT_SMOKESCREENS && Token && Token.NoSmokescreens)
			Return True;
		
		Return False;
	}
	
	//Ask what the dog is doing.
	Actor IsDogNearby (Double DogRange = 384)
	{
		Let DogSearch = BlockThingsIterator.Create (Self,DogRange);
		
		Actor Dog;
		While (DogSearch.Next())
		{
			Dog = DogSearch.Thing;
			If (!Dog || !(Dog Is "MBFHelperDog") || IsDead (Dog))
				Continue;
			
			If (IsActorHostile (Dog))
				Continue;
			
			If (Distance3DSquared (Dog) > DogRange*DogRange)
				Continue;
			
			If (!CheckSight (Dog,SF_IGNOREWATERBOUNDARY))
				Continue;
			
			Return Dog;
		}
		
		Return Null;
	}
	
	Int FindDeadDogs (Double DogRange = 384, Actor Killer = Null)
	{
		Let DogSearch = BlockThingsIterator.Create (Self,DogRange);
		
		Actor Dog;
		Int Dogs;
		While (DogSearch.Next())
		{
			Dog = DogSearch.Thing;
			If (!Dog || !(Dog Is "MBFHelperDog") || !IsDead (Dog) || !IsFriend(Dog))
				Continue;
			
			If (Killer && Dog.Target != Killer) //Only count dogs killed by the same actor.
				Continue;
			
			Dogs++;
		}
		Return Dogs;
	}
}

//Find the marines target in the line of fire, otherwise assume the LOF is bad.
Class SM_FindTargetInLOF : KAI_LOFRaycast
{
	Override ETraceStatus TraceCallback ()
	{
		If (Other && Results.HitActor == Other)
		{
			BadLOF = False;
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

//KLUDGE: Apparently LineTrace()'s LineTracer must be fucking broken because it does NOT return the 3D floor it found.
//Find and return the first 3DFloor you hit.
Class SM_Find3DFloor : KAI_LOFRaycast
{
	Bool HitSwimmable; //Hit swimmable 3D floors too.
	Override ETraceStatus TraceCallback ()
	{
		If (HitSwimmable && Results.Crossed3DWater)
		{
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

//KLUDGE: Copied from the MVPs' UniversalFunctions mixin. Because they are supposed to work independent of each other.
Mixin Class SM_SplashFunctions
{
	Enum LiquidTypes
	{
		LIQUID_NONE = 0,
		LIQUID_WATER = 1,
		LIQUID_NUKAGE = 2,
		LIQUID_BLOOD = 3,
		LIQUID_LAVA = 4,
		LIQUID_SLIME = 5
	};
	
	Int CheckLiquid (TextureID Texture)
	{
		/*===============================================================
		This class stores the names of the different textures used for each type of liquid.
		These lists can be expanded as seen fit for your project, in case it has additional custom water/nukage/blood/lava/slime textures.
		The lists already contain some names of liquid flats that don't exist in the vanilla game, for built-in mod compatibility.
		Such as by having waterfall textures that don't exist like WFALL# and NFALL#.
		===============================================================*/
		Static Const String WaterTextures[] = {"FWATER1", "FWATER2", "FWATER3", "FWATER4", "WFALL1", "WFALL2", "WFALL3", "WFALL4"};
		Static Const String NukageTextures[] = {"NUKAGE1", "NUKAGE2", "NUKAGE3", "NFALL1", "NFALL2", "NFALL3", "NFALL4"};
		Static Const String BloodTextures[] = {"BLOOD1", "BLOOD2", "BLOOD3", "BFALL1", "BFALL2", "BFALL3", "BFALL4"};
		Static Const String LavaTextures[] = {"LAVA1","LAVA2", "LAVA3", "LAVA4", "DBRAIN1", "DBRAIN2", "DBRAIN3", "DBRAIN4", "LFALL1", "LFALL2", "LFALL3", "LFALL4"};
		Static Const String SlimeTextures[] = {"SLIME01","SLIME02", "SLIME03", "SLIME04", "SLIME05","SLIME06", "SLIME07", "SLIME08", "SFALL1", "SFALL2", "SFALL3", "SFALL4"};
		
		For (Int I = 0; I < WaterTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (WaterTextures[I]) == Texture)
				Return LIQUID_WATER;
		For (Int I = 0; I < NukageTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (NukageTextures[I]) == Texture)
				Return LIQUID_NUKAGE;
		For (Int I = 0; I < BloodTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (BloodTextures[I]) == Texture)
				Return LIQUID_BLOOD;
		For (Int I = 0; I < LavaTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (LavaTextures[I]) == Texture)
				Return LIQUID_LAVA;
		For (Int I = 0; I < SlimeTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (SlimeTextures[I]) == Texture)
				Return LIQUID_SLIME;
		
		Return LIQUID_NONE;
	}
	
	//Allows to quickly set up a spawned liquid splash, and then returns a pointer the splash to allow for further modifications, like making it visually larger or calling A_QuakeEx from it.
	Actor SpawnLiquidSplash (Int LiquidType = LIQUID_WATER, Sound SplashSound = "SFX/LiquidExplosion", Double Volume = 1.0, Double Attenuation = 0.5,
	Int ExplosionDamage = 0, Double ExplosionRadius = 0, Double FullDamageRadius = 0, Name DamageType = "", Bool DontHarmSource = False)
	{
		Actor Splash = Spawn ("SM_LiquidSplash",Pos);
		
		If (Splash)
		{
			//Set the shooter of the projectile for DontHarmSource to work.
			If (bMissile)
				Splash.Target = Target; //Projectiles store their shooter in the target pointer, so transfer the shooter to the splash.
			Else
				Splash.Target = Self; //Otherwise set the shooter to the actor calling the function, if it's not a projectile somehow.
			
			SM_LiquidSplash(Splash).LiquidType = LiquidType;
			SM_LiquidSplash(Splash).SplashSound = SplashSound;
			SM_LiquidSplash(Splash).Volume = Volume;
			SM_LiquidSplash(Splash).Attenuation = Attenuation;
			SM_LiquidSplash(Splash).RadiusDamage = ExplosionDamage;
			SM_LiquidSplash(Splash).MaxTargetRange = ExplosionRadius;
			SM_LiquidSplash(Splash).MeleeRange = FullDamageRadius;
			SM_LiquidSplash(Splash).ExplosionDamageType = DamageType;
			SM_LiquidSplash(Splash).DontHarmSource = DontHarmSource;
			Return Splash;
		}
		
		Return Null;
	}
	
	F3DFloor FindWaterBelow (Double Distance = 8)
	{
		Let WaterCheck = New ("SM_Find3DFloor");
		WaterCheck.HitSwimmable = True; //We only care for swimmable floors.
		
		WaterCheck.Trace (Pos,CurSector,(0,0,-1),Distance,0);
		Let FFloor = WaterCheck.Results.Crossed3DWater;
		//If (HitPos != HitPos) HitPos = WaterCheck.Results.Crossed3DWaterPos;
		WaterCheck.Destroy();
		Return FFloor;
	}
}