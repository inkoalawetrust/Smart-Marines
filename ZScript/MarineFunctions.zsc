Extend Class SM_Marine
{
	Enum MarineChaseFlags
	{
		SMC_NOUSESTATE		= 1 << 0, //The marine will not wait in his interact state after using a line with no threat around.
		SMC_IGNOREHAZARDS	= 1 << 1, //The marine ignores any nearby hazards.
		SMC_NOCOVERSTOP		= 1 << 2, //The marine doesn't stop moving when in cover.
		SMC_SEARCHFORCOVER	= 1 << 3, //The marine actively searches for nearby cover between the target and him, or on their sides.
		SMC_USEEMPLACEMENTS	= 1 << 4, //The marine will try to use KAI emplacements like the machine gun turrets (And any future ones like ATGMs and mortars).
	}
	
	Vector3 NearbyCoverPos; //A bit of nearby cover the marine can run at to hide behind.
	
	//Unlike in the original Smart Marines, this is VERY MUCH a custom function.
	Void SM_Chase (StateLabel WaitState = Null, StateLabel RetreatState = Null, Int Flags = SMC_SEARCHFORCOVER, Int ChaseFlags = 0, Double TurnRadius = 25)
	{
		//Very marine specific things
		If (BurstCounter) BurstCounter = 0; //Reset the burst fire countdown when not firing. Like if the marine is hurt mid-burst.
		bNoFriction = Default.bNoFriction; //Reset the friction flag to the default, in case the marine begun firing or something mid-jump.
		bNoGravity = Default.bNoGravity; //Reset gravity too, they just shouldn't fuckin' float around.
		HealTarget = Null;
		DodgingHomingProjectile = False;
		
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		
		//ZScript exports of different segments of GZDooms' native AI code. This is the stuff not needed for movement.
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_Chase_FriendsAttackPlayerEnemies(ChaseFlags);
		KAI_Chase_Retarget(ChaseFlags,True); //Friendly marines go idle with no target too.
		//KAI_Chase_HandleActiveSound(ChaseFlags);
		
		Bool MovedAlready;
		//If fast monsters (AKA fast projectile attacks too) is enabled, and it's a ranged target, stay 16 meters away, if not, stay 12 meters away.
		Double MajorThreatRange = (G_SkillPropertyInt(SKILLP_FASTMONSTERS) && Target.MissileState) ? 512*512 : 384*384;//(RetreatRange*4)*(RetreatRange*4);
		Bool CancelAttack;
		Int TargetThreatLevel = AssessThreatLevel(Target, True);
		
		If (!(ChaseFlags & CHF_DONTMOVE) && !(Flags & SMC_IGNOREHAZARDS)) MovedAlready = SM_RunFromHazards(); //Avoid any major hazards.
		
		If (!(Flags & SMC_NOCOVERSTOP) && MarineState & MARINE_INCOVER) //Don't move when in cover.
			ChaseFlags |= CHF_DONTMOVE;
		
		//Search for nearby cover in a 256 MU range. But only some of the time, since it's expensive.
		If (Flags & SMC_SEARCHFORCOVER && !(ChaseFlags & CHF_DONTMOVE) && KAI_Math.IsEmptyVector3 (NearbyCoverPos)/* && Random (0,255) < 64*/)
			NearbyCoverPos = SM_LocateNearbyCover (Target);
		
		//Run away from major actor threats.
		If (!bNoFear && Target && !(Goal && bChaseGoal) && KAI_Math.IsEmptyVector3 (NearbyCoverPos))
		{
			If (!(ChaseFlags & CHF_DONTMOVE) && !MovedAlready)
			{
				//If you can't attack (But not because you are in a NOATTACK sector), run. Also run if the other actor is frightening or you're frightened.
				If ((!CanAttack() && !(CurSector.Flags & Sector.SECF_NOATTACK)) || bFrightened || IsFrightening (Target) ||
				//If the targets' threat level is over the threshold, and it's visible and nearby, GTFO.
				ThreatLevelThreshold != THREAT_ASSESS && TargetThreatLevel >= ThreatLevelThreshold && (Distance3DSquared(Target) < MajorThreatRange))
				{
					//And at last, check if the target is still visible.
					If (CheckSight (Target, SF_IGNOREWATERBOUNDARY))
					{
						If (!RetreatState)
							KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
						Else
							SetStateLabel (RetreatState);
						MovedAlready = True;
						Return;
					}
				}
			}
		}
		
		//We're in range to try using the turret we're heading to.
		If (!TurretDelay && TargetTurret && Distance3DSquared(TargetTurret) <= MeleeRange*MeleeRange)
		{console.printf ("I DID IT, I AM USING THE STUPID GUN");
			TargetTurret.EnterEmplacement(Self);
			//TargetTurret = Null; //Nullify this, also just in case the EnterEmplacement() fails.
			Return;
		}
		
		Bool UsedLine;
		//If you can move and haven't done so already.
		If (!(ChaseFlags & CHF_DONTMOVE))
		{
			//Only update the nearest enemy to run from when not focused on a route.
			If (bAvoidMelee && !(IsPatrolling(Self) && bChaseGoal)) NearestEnemy = FindNearestEnemy (128); //IDEA: Unhardcode the retreat range.
			
			//URGENT: MAYDO: I think I commented this out for test? So probably put it back in.
			/*Bool MeleeAnyway; //The enemy is weak and nearby, go up to them and kick their ass even without berserk.
			//Sometimes, be less afraid to do melee if the enemy is weak enough.
			If (bAvoidMelee && NearestEnemy && !IsIndestructible (NearestEnemy) && !HasGodMode (NearestEnemy))
			{
				If (!NearestEnemy.MissileState && NearestEnemy.Health <= 80 || //If they are melee only and weak enough.
				NearestEnemy.MissileState && NearestEnemy.Health <= 40) //But even if they are ranged, but VERY weak.
					QuickMelee = True;
			}*/
			
			//If you aren't patrolling and not allowed off your route, and there is an enemy nearby. Get away.
			If (bAvoidMelee && NearestEnemy)
			{
				If (!RetreatState)
					KAI_MoveAway (Target,detourfactor:0.5,TurnRadius,ChaseFlags,KMT_CHASEGOAL|KMT_ZIGZAG);
				Else
					SetStateLabel (RetreatState);
				
				MovedAlready = True;
			}
			//Actual movement handling.
			Else
			{
				Bool B;
				KAI_Chase_HandleStrafing (Target,ChaseFlags);
				[B,MovedAlready] = KAI_Chase_PatrolHandling(WaitState, 0.2, anglelimit:TurnRadius, chaseflags:ChaseFlags);
				
				/*If there is no danger in sight, the marine will wait for lines he used like doors and platforms to move. Instead of moving around like a
				normal monster. However, if there IS danger nearby, the marine will keep moving after using the line like normal.*/
				Int NoStockUse;
				If (!IsDangerNearby())
				{
					NoStockUse = KMT_NOLINEUSE;
					UsedLine = SM_MarineUseLine(faceline:!(Flags & SMC_NOUSESTATE)); //Check if there's a line in front of use to use.
				}
				
				//Crouching comes first.
				If (!(MarineState & MARINE_INCOVER) && !SM_IsRestricted (RESTRICT_CROUCHING)) Crouching = KAI_HandleCrouching(Default.Height,MARINE_CROUCHHEIGHT);
				
				If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) &&
				//DO NOT CLIMB OVER YOUR COVER
				//BUG: Probably prevents marines from climbing at all when running to cover.
				(!KAI_Math.IsEmptyVector3 (NearbyCoverPos) || Level.Vec3Diff (Pos,NearbyCoverPos).Length() > Radius*1.2))
				{
					If (KAI_HandleClimbing(ClimbPos,JumpPos,"Climb","Jump.Up",1.1,1.75))
						MovedAlready = True;
				}
				
				If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) && SM_HandleClimbDown(Height*1.75)) //Handle jumping down any ledges that you can still climb up to if you want.
					MovedAlready = True;
				
				Vector2 JumpPosition = (Double.NaN,Double.NaN);
				If (!SM_IsRestricted (RESTRICT_JUMPING)) JumpPosition = KAI_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
				If (JumpPosition == JumpPosition && !Crouching && !(MarineState & MARINE_INCOVER)) //We have a valid position we must jump to, AKA the returned vector isn't null.
				{
					JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
					Bool Reachable = True; //Assume we can jump there by default.
					//The jump destination is longer than half the jump distance, so do a long jump if there's space behind you for it.
					If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5 && (Reachable = SM_CanRunBack()))
					{
						PreJumpPos = Vec3Angle(256,Angle-180);
						SetStateLabel ("Jump.Running");
						MovedAlready = True;
					}
					Else If (Reachable) //If the gap is too short to do a running jump, do a normal one, but don't fall back to normal jumps for large gaps.
					{
						SetStateLabel ("Jump");
						MovedAlready = True;
					}
				}
				
				//Finally, if you do have a target, DO move towards it, but with KAI_MoveTowards instead of the shitty native movement code.
				If (!MovedAlready)
				{
					Bool DoZigZag;
					Vector3 MovePos = (Double.NaN,Double.NaN,Double.NaN);
					Double RealSpeed = Speed;
					//Go to a nearby turret when in combat if you aren't weak and the target is particularly strong.
					If (!TurretDelay && !TargetTurret && Target && !(TargetThreatLevel >= ThreatLevelThreshold && Health <= 30))
						TargetTurret = KAI_Emplacement(FindEmplacements());
					
					If (KAI_Math.IsEmptyVector3(MovePos))
						[MovePos, DoZigZag, CancelAttack] = SM_RunToCoverPos (Target,dozigzag:KMT_ZIGZAG);
					
					If (!KAI_Math.IsEmptyVector3(LastSeenPos)) //Out of sight, walk to last seen pos instead.
					{
						If (Level.Vec3Diff (Pos,LastSeenPos).Length() >= Radius*1.2)
						{
							If (!CheckSight (Target,SF_IGNOREWATERBOUNDARY)) //Run the actual sight check last to save on performance a little.
								MovePos = LastSeenPos;
						}
						Else
							LastSeenPos = (Double.NaN, Double.NaN, Double.NaN); //We're in position, begin chasing normally again.
					}
					Else
						MovePos = HandleFollowingActor (MovePos); //Check if we should be following anyone, if not, just focus on chasing the target or whatever.
					
					If (TargetTurret)
						MovePos = TargetTurret.Pos;
					
					If (KAI_DebugPrintMessages)console.printf ("heading to %d %d %d",movepos);
					If (Crouching)
						Speed *= 0.7;
					If (MovePos == LastSeenPos)
						Speed *= 1.25;
					
					KAI_MoveTowards (MovePos, 0.5, TurnRadius, ChaseFlags, KMT_CHASEGOAL|DoZigZag|NoStockUse);
					Speed = RealSpeed;
				}
			}
		}
		
		SM_UpdateChaseTimer();
		If (!CancelAttack) ShouldAttack(); //Run attack decision code.
		
		If (!(Flags & SMC_NOUSESTATE) && UsedLine) 
			SetStateLabel ("Interact");
		
		//If you are set to not automatically idle, only do it when the timer is over the threshold.
		If (ChaseFlags & CHF_DONTIDLE && ChaseTimer >= MARINE_CHASETIME)
		{
			A_ClearTarget();
			ChaseTimer = 0;
			SetIdle();
		}
	}
	
	//Marine will run away from major hazards.
	//Unless it's patrolling and sticking to his path, and even then, he will still run if the hazard is like, a nuke or something.
	Bool SM_RunFromHazards (Bool NoJump = FaLse)
	{
		If (HazardToAvoid && ( !(Goal && bChaseGoal) || HazardToAvoid.Level >= HazardInfo.HAZARD_HUGE ) && SM_ShouldRunFromHazard(HazardToAvoid) == RUN_FAST)
		{
			//The amount of loops is the distance to the hazard divided by distance travelled by one retreat sequence + some change.
			Double RetreatDist = Speed*12; //12 movement calls in one Retreat loop.
			RetreatPos = GetHazardOriginPos (HazardToAvoid);
			RetreatLoops = Int(GetHazardDistance(HazardToAvoid) / RetreatDist);
			
			//Run a bit further for shrapnel.
			Bool IsGrenade, HasShrapnel;
			ForEach (CurTag : HazardToAvoid.CustomTags)
			{
				If (CurTag ~== "Grenade")
					IsGrenade = True;
				If (CurTag ~== "Shrapnel")
					HasShrapnel = True;
			}
			If (IsGrenade && HasShrapnel)
				RetreatLoops++;
			
			If (KAI_DebugPrintMessages)
			{
				console.printf ("marine breaking action to run %d times away from hazard %p",retreatloops,hazardtoavoid);
				HAZARDTOAVOID.PRINTHAZARDINFO();
			}
			If (!NoJump) SetStateLabel ("Retreat");
			Return True;
		}
		Return False;
	}
	
	//To not have to copy and paste between SM_Chase() and SM_RunAway().
	Vector3, Bool, Bool SM_RunToCoverPos (Actor Other, Double SpeedMul = 2, Bool DoZigZag = True, Bool StopRetreating = False)
	{
		Vector3 MovePos = (Double.NaN, Double.NaN, Double.NaN); If (Other) MovePos = Other.Pos;
		Bool CancelAttack;
		If (!KAI_Math.IsEmptyVector3 (NearbyCoverPos)) //We have a position to take cover behind, move there.
		{
			Vector3 RealPos = Pos;
			SetXYZ (NearbyCoverPos); //Check from the desired position.
			//Make sure the target didn't get behind the cover or something while you are still going there !.
			Bool StillValidCover = SM_UpdateCover (Other,False,256);
			SetXYZ (RealPos);
			Bool CanWalkThere = (Random (0,255) < 220) ? True : IsPosReachable (NearbyCoverPos); //Only SOMETIMES check if we can still go there.
			if (!stillvalidcover && KAI_DebugPrintMessages) console.printf ("SM_CHASE(): THE COVER THE MARINE IS MOVING TO AT %d %d %d IS NO LONGER VALID",NearbyCoverPos);
			if (!canwalkthere && KAI_DebugPrintMessages) console.printf ("SM_CHASE(): THE COVER THE MARINE IS MOVING TO AT %d %d %d IS NOW OUTTA REACH",NearbyCoverPos);
			If (Level.Vec3Diff (Pos,NearbyCoverPos).Length() > Radius*1.2 && StillValidCover && CanWalkThere)
			{
				If (KAI_DebugPrintMessages)console.printf ("taking a step towards cover");
				MovePos = NearbyCoverPos;
				Speed *= SpeedMul; //Hurry up to hide.
				DoZigZag = 0; //Move in a straight line as well.
				CancelAttack = True; //Don't attack.
			}
			Else //We are basically at our destination, so get rid of the goal and try crouching behind here.
			{
				If (KAI_DebugPrintMessages)console.printf ("clearing cover pos !");
				NearbyCoverPos = (Double.NaN, Double.NaN, Double.NaN);
				If (!StillValidCover) //If we are no longer heading to NearbyCoverPos because it's now unsafe, just abort.
				{
					SM_StartCrouch(); //Just to be sure, if it's not valid for some reason, the marine uncrouches on his own anyway.
					If (StopRetreating) //Used when called by SM_RunAway() to put the marine back into the See state with its' special crouch handling.
					{
						RetreatLoops = 0;
						RetreatPos = (Double.NaN, Double.NaN, Double.NaN);
						SetStateLabel ("See");
					}
				}
			}
		If (KAI_DebugPrintMessages)console.printf ("the distance to my cover is %.2f",Level.Vec3Diff (Pos,NearbyCoverPos).Length());
		}
		Return MovePos, DoZigZag, CancelAttack;
	}
	
	//Search for the closest cover between the marine and the target and marine (e.g if there's cover 4 meters towards the target) and the marines' flanks.
	//Other: The actor to check if you can hide from.
	//Distance: How far the check traces can move forward to check for cover + how far to check on each side for said cover.
	//PitchBounds: The maximum and minimum pitch, in that order, of the marine. If the pitch is out of those bounds, the many side checks are aborted for optimization. 0 disables each pitch check.
	Vector3 SM_LocateNearbyCover (Actor Other, Double Distance = 256, Vector2 PitchBounds = (-50, 80))
	{
		If (!Other || Distance <= 0 || SM_IsRestricted (RESTRICT_TAKECOVER))
			Return (Double.NaN, Double.NaN, Double.NaN);
		
		//Check in front of the marine first.
		Vector3 FrontCover = (Double.NaN, Double.NaN, Double.NaN);
		Bool GotFrontCover;
		[GotFrontCover, FrontCover] = SM_UpdateCover (Other,False,Distance);
		If (GotFrontCover) FrontCover.Z = GetZAt();
		
		If (!GotFrontCover) //Didn't find cover right in front of the direction Other is at, so ignore the result.
			FrontCover = (Double.NaN, Double.NaN, Double.NaN);
		
		Double PitchTo = PitchTo(Other,50,Other.Height/2);
		If (PitchBounds.X != 0 && PitchTo < PitchBounds.X) Return FrontCover;
		If (PitchBounds.Y != 0 && PitchTo > PitchBounds.Y) Return FrontCover;
		
		Vector3 RealPos = Pos;
		Vector3 LeftCover, RightCover;
		Bool GotLeftCover, GotRightCover;
		
		Double Spacing = Radius*2; //Check spacing.
		
		For (Int DistDiv = Distance/Spacing; DistDiv < Distance; DistDiv += Spacing)
		{
			SetXYZ (Vec3Angle (DistDiv,AngleTo(Other)-90)); //Check left.
			[GotLeftCover, LeftCover] = SM_UpdateCover (Other,False,Distance);
			//actor point = spawn ("kai_debugpoint",leftcover);
			If (GotLeftCover) LeftCover.Z = GetZAt();
			SetXYZ (RealPos);
			If (!GotLeftCover) LeftCover = (Double.NaN, Double.NaN, Double.NaN);
			Else If (GotLeftCover && IsPosReachable (LeftCover,Radius*1.1))
				/*{point.setxyz (point.pos.plusz(64));*/Break;//} //Found a spot to hide behind on the left.
		}
		
		For (Int DistDiv = Distance/Spacing; DistDiv < Distance; DistDiv += Spacing)
		{
			SetXYZ (Vec3Angle (DistDiv,AngleTo(Other)+90)); //Check Right.
			[GotRightCover, RightCover] = SM_UpdateCover (Other,False,Distance);
			//actor point = spawn ("kai_debugpoint",rightcover);
			If (GotRightCover) RightCover.Z = GetZAt();
			SetXYZ (RealPos);
			If (!GotRightCover) RightCover = (Double.NaN, Double.NaN, Double.NaN);
			Else If (GotRightCover && IsPosReachable (RightCover))
				/*{point.setxyz (point.pos.plusz(64));*/Break;//} //Found a spot to hide behind on the right.
		}
		
		//Get the smallest distance between these 3, and return the closest position.
		Double FrontDist = Int.Max;
		Double LeftDist = Int.Max;
		Double RightDist = Int.Max;
		
		If (!KAI_Math.IsEmptyVector3 (FrontCover)) FrontDist = Level.Vec3Diff (Pos,FrontCover).Length();
		If (!KAI_Math.IsEmptyVector3 (LeftCover)) LeftDist = Level.Vec3Diff (Pos,LeftCover).Length();
		If (!KAI_Math.IsEmptyVector3 (RightCover)) RightDist = Level.Vec3Diff (Pos,RightCover).Length();
		
		//If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): The distances to the 3 potential cover spots is %d %d %d",FrontDist,LeftDist,RightDist);
		
		Double SmallestDist = Min (FrontDist,LeftDist,RightDist);
		
		If (SmallestDist != INT.MAX)
		{
			If (SmallestDist == FrontDist)
				/*{If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): taking front cover %d %d %d",frontcover);*/Return FrontCover;//}
			Else If (SmallestDist == LeftDist)
				/*{If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): taking left cover %d %d %d",leftcover);*/Return LeftCover;//}
			Else If (SmallestDist == RightDist)
				/*{If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): taking right cover %d %d %d",rightcover);*/Return RightCover;//}
		}
		//If (KAI_DebugPrintMessages)console.printf ("SM_LocateNearbyCover(): All checks failed, returning NaN vector.");
		Return (Double.NaN, Double.NaN, Double.NaN);
	}
	
	Bool HipFalsePositive; //HACK: Sometimes traces go full retard and return that the marines' hip level isn't blocked, so only uncrouch if TWO hip checks are false.
	
	//BUG: URGENT: Fix the cover check causing them to teabag the air when on slopes.
	Bool, Vector3 SM_UpdateCover (Actor Other, Bool IsCrouchingAlready, Double TraceDist = 48)
	{
		Vector3 HipHitPos = (Double.NaN, Double.NaN, Double.NaN);
		
		//Don't crouch if Who is invalid, you are patrolling, or it's just restricted.
		If (!Other || IsPatrolling (Self) || SM_IsRestricted (RESTRICT_TAKECOVER))
			Return False, HipHitPos;
		
		FLineTraceData EyeLevel, HipLevel;
		Bool EyeLevelUnblocked, HipLevelBlocked;
		Int HasHit;
		Actor Mobj;
		
		//If the other actor is this close to you, you probably can't crouch.
		If (Distance3DSquared(Other) <= 72*72)
			{If (KAI_DebugPrintMessages)console.printf ("SM_UpdateCover(): other is too close to take cover.");Return False, HipHitPos;}
		
		/*
		This fires two raycasts from the marines' eyes and hips. Then the Eye and HipLevelBlocked booleans return true or false.
		Based on whether or not they hit any level geometry before stopping. The distance that the raycasts travel double when
		the marine is already crouched, so they don't get out of cover even when their target hasn't breached said cover.
		*/
		
		If (!IsCrouchingAlready)
			LineTrace (AngleTo (Other),TraceDist,PitchTo(Other,50,Other.Height/2),0,50,data:EyeLevel);
		Else
			LineTrace (AngleTo (Other),128,PitchTo(Other,50,Other.Height/2),0,50,data:EyeLevel);
		
		EyeLevelUnblocked = SM_EyeLevelClear (EyeLevel);

		If (!IsCrouchingAlready)
			LineTrace (AngleTo (Other),TraceDist,PitchTo(Other,18,Other.Height/2),TRF_THRUHITSCAN,18,data:HipLevel);
		Else //Run a longer range trace when crouched to not go out of cover as easily when behind strangely shaped cover like star shaped fountains.
			LineTrace (AngleTo (Other),128,PitchTo(Other,18,Other.Height/2),TRF_THRUHITSCAN,18,data:HipLevel);
		
		HasHit = HipLevel.HitType;
		Mobj = HipLevel.HitActor;
		HipHitPos = HipLevel.HitLocation - HipLevel.HitDir * (Radius*1.1);
		//IF (MOBJ&&KAI_DebugPrintMessages)CONSOLE.PRINTF ("SM_UPDATECOVER: DEBUG: HIP CHECK HIT ACTOR %s %p",MOBJ.GETCLASSNAME(),MOBJ);
		
		//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(50),EyeLevel.HitLocation,EyeLevel.Distance);
		//KAI_LOFRaycast.VisualizeTracePath (Pos.PlusZ(18),HipLevel.HitLocation,HipLevel.Distance);
		
		//Only take cover behind level geometry, and large enough actors that aren't other NPCs or players. And aren't about to break.
		If ((HasHit == TRACE_HitWall || HasHit == TRACE_HitFloor || HasHit == Trace_HitCeiling) ||
		(Mobj && !(Mobj.bIsMonster || Mobj.Player) && Mobj.Radius >= Radius && Mobj.Height <= 40 && Mobj.Health >= 40))
			HipLevelBlocked = True;
			
		//If (KAI_DebugPrintMessages)console.printf ("SM_UPDATECOVER YADDA YADDA FUCK OFF: HIPLEVELBLOCKED IS %d",hiplevelblocked);
		
		Bool OtherInSight = CheckSight (Other,SF_SEEPASTSHOOTABLELINES|SF_IGNOREWATERBOUNDARY);
		//Only run this if the marine is not crouched already.
		If (!IsCrouchingAlready)
			If (EyelevelUnblocked && HipLevelBlocked && OtherInSight)
				{If (KAI_DebugPrintMessages)console.printf ("SM_UpdateCover(): marine can take cover");Return True, HipHitPos;}
		
		//If you are crouching already and have a line of sight to the other actor.
		If (IsCrouchingAlready && OtherInSight)
			//Then return if you can crouch based on whether or not your hips are blocked by cover still.
		{if (!hiplevelblocked) console.printf ("SM_UpdateCover(): marine can no longer hide behind here");
			If (!HipLevelBlocked && !HipFalsePositive) //HACK: Catch retarded false positives from the trace.
			{If (KAI_DebugPrintMessages)console.printf ("SM_UPDATECOVER: CAUGHT RETARDED MALFORMED FALSE POSITIVE");
				HipFalsePositive = True;
				HipLevelBlocked = True;
			}
			If (!HipLevelBlocked && HipFalsePositive) //If it returns false a second time, it's probably for real.
				{If (KAI_DebugPrintMessages)console.printf ("SM_UPDATECOVER: PROBABLY NOT A FALSE POSITIVE, COVER REALLY IS BROKEN");HipFalsePositive = False;}
			Return HipLevelBlocked, HipHitPos; //Then return if you can crouch based on whether or not your hips are blocked by cover still.
		}
		
		If (!OtherInSight && Random (0,255) < 4) //If the other actor is out of sight, the marine will eventually give up staying behind cover.
			{If (KAI_DebugPrintMessages)console.printf ("SM_UpdateCover(): %p is out of sight",other);Return False, HipHitPos;}
		
		//If none of the other checks are true, but you are crouching already, then just assume you can keep doing so.
		If (IsCrouchingAlready)
		{
			HipFalsePositive = True; //HACK: We need two false hip checks in a row to consider it to not be a fluke.
			Return True, HipHitPos;
		}
		
		Return False, HipHitPos;
	}
	
	//Makes marines able to enter their climb down sequence if their next step is down a short enough dropoff.
	//MAYDO: I should probably look for a way to integrate this into KAI_HandleClimbing() ?
	Bool SM_HandleClimbDown (Double DropoffHeight = 56)
	{
		Vector2 Ahead = Vec2Angle(Radius*2.2,Angle);
		Double ZAt = GetZAt (Ahead.X,Ahead.Y,0,GZF_ABSOLUTEPOS);
		If (DropoffHeight > Pos.Z - ZAt && MaxDropoffHeight < Pos.Z - ZAt) //The dropoff height is as tall or shorter than the specified MaxDropoff.
		{
			JumpPos = (Vec2Angle (104,Angle),ZAt);
			SetStateLabel ("Jump"); //So jump down.
			Return True;
		}
		
		Return False;
	}
	
	//Clean wrapper for the eye level checks, copied from the original code and probably unnecessary.
	Bool SM_EyeLevelClear (FLineTraceData Data)
    {
        Int HasHit;
        
        HasHit = Data.HitType;
		
        If (Data.HitActor || HasHit == TRACE_HitWall || HasHit == TRACE_HitFloor || HasHit == Trace_HitCeiling)
            Return False;
        
        Return True;
    }
	
	Bool SM_CheckFOV (Actor Viewer, Actor Other, Double FOV)
	{
		Vector3 CameraPos;
		If (Viewer.Player)
			CameraPos = (Viewer.Player.Camera.Pos.XY,Viewer.Player.ViewZ);
		Else
			CameraPos = (Viewer.Pos.XY,Viewer.GetCameraHeight());
		
		If (Viewer.Player)
		{
			Double d1, d2, ViewWidth, ViewHeight;
			[d1,d2,ViewWidth,ViewHeight] = Screen.GetViewWindow();
			If (KAI_DebugPrintMessages)console.printf ("width %d, height %d",viewwidth,viewheight);
			FOV = FOV * (ViewWidth / ViewHeight);
		}
		
		Vector3 Coords = Level.SphericalCoords (CameraPos,Other.Pos.PlusZ(Other.Height/2),(Viewer.Angle,Viewer.Pitch));
		If (KAI_DebugPrintMessages)console.printf ("%s is in the %d FOV of %s, coords.z is %f, coords.x is %f, inverse square %f",other.getclassname(),fov/2,viewer.getclassname(),coords.z,coords.x,(Abs(Coords.X) / (Coords.Z * Coords.Z)));
		If (Abs(Coords.X) <= FOV/2)
		{If (KAI_DebugPrintMessages)a_log ("we passed");
			Return True;
		}
		Return False;
	}
	
	Bool SM_CanRunBack()
	{
		Vector3 RealPos = Pos;
		Bool Moved = IsPosReachable (Vec3Angle(256,Angle-180),dropoff:False); //Doesn't use the SM_ wrapper since it's supposed to be one continuous running leap.
		If (Moved)
		{
			SetOrigin (Vec3Angle(256,Angle-180),False);
			Moved = IsPosReachable (Vec3Angle(256,Angle));
			SetOrigin (RealPos,False);
		}
		Return Moved;
	}
	
	Void SM_StartCrouch()
	{
		MarineState |= MARINE_INCOVER;
		Crouching = True;
		Height = MARINE_CROUCHHEIGHT;
	}
	
	Void SM_EndCrouch()
	{
		MarineState &= ~(MARINE_INCOVER);
		Crouching = False;
		Height = Default.Height;
	}
	
	//Increment the chase timer as long as the target is nonexistent, dead, or out of sight. And reset it if any of these conditions are false.
	//Also handles updating LastSeenPos.
	Void SM_UpdateChaseTimer()
	{
		If (IsPatrolling(Self)) //Ignore this if we are following a goal.
			ChaseTimer = 0;
		Bool Dead = IsDead(Target);
		Bool OuttaSight;
		If (!Target || Target && (Dead || (OuttaSight = !CheckSight(Target,SF_IGNOREWATERBOUNDARY))  ) )
			ChaseTimer++;
		Else
			ChaseTimer = 0;
		
		//Update LastSeenPos.
		If (Target && !OuttaSight && !Dead)
			LastSeenPos = Target.Pos;
		Else If (!Target || Dead)
			LastSeenPos = (Double.NaN, Double.NaN, Double.NaN); //The target is dead or gone.
		
		If (!Target || Dead) ChaseTimer++; //Decrement the timer extra fast if the target is just flat out gone.
		//If (KAI_DebugPrintMessages)Console.Printf ("SM_UpdateChaseTimer(): Time is %d",ChaseTimer);
	}
	
	//Marines use lines in front of them.
	//IDEA: Make the marine detect doors or platforms in front of him, then if it's switch activated, search for nearby switches he can go up to and use. Dynamically.
	Sector UseSec;
	Bool SM_MarineUseLine (Double UseRange = 64, Bool FaceLine = False)
	{
		InteractWaits = 0; //Reset it here just in case.
		//Let LineSearch = BlockLinesIterator.Create (Self,Radius+64);
		//Count pushable lines as uses too.
        If (bCanPushWalls && BlockingLine && BlockingLine.Special && BlockingLine.Activate (Self,0,SPAC_Push))
		{
			//If (FaceLine) Angle = GetAngleToPos ((GetLinePos(BlockingLine),0));
			UseSec = GetLiftOrDoorSector(BlockingLine);//BlockingLine.BackSector;
			Return True;
		}
		
		If (!bCanUseWalls) Return False;
		FLineTraceData Usage;
		
		LineTrace (Angle,UseRange,0,TRF_BLOCKUSE,Height/2,data:Usage);
		
		FSpawnParticleParams P; P.Color1 = "Pink"; P.Style = STYLE_None; P.Lifetime = 1; P.Size = 4; P.StartAlpha = 1; P.FadeStep = -1; P.Flags = SPF_FULLBRIGHT;
		KAI_LOFRaycast.VisualizeTracePath(Pos.PlusZ(Height/2),Usage.HitLocation,Usage.Distance,4,p);
		
		//Used a line in front of us.
		Line UseLine = Usage.HitLine;
		If (UseLine && UseLine.Special && UseLine.Activate (Self,Usage.LineSide,SPAC_Use))
		{
			//If (FaceLine) Angle = GetAngleToPos ((GetLinePos(UseLine),0));
			UseSec = GetLiftOrDoorSector(UseLine);//UseLine.BackSector;
			If (KAI_DebugPrintMessages)a_log ("a marine ran his custom line use function");
			Return True;
		}
		
		Return False;
	}
	
	//Gets the lift or door sector from the built in sector specials, instead of assuming the back sector is the door or lift, just in case.
	Sector GetLiftOrDoorSector (Line TheLine)
	{
		Sector Result;
		//Generally, it seems that args[0] is the tag of the affected sector. So this is what we assume.
		Switch (TheLine.Special)
		{
			Case 11: //Door_Open
			Case 12: //Door_Raise
			Case 21: //Floor_LowerToNearest
			Case 202: //Door_Generic
			Case 105: //Door_WaitRase
			Case 203: //Generic_Lift
			{
				Let TagIter = Level.CreateSectorTagIterator (TheLine.Args[0],TheLine);
				Result = Level.Sectors[TagIter.Next()];
				Break;
			}
		}
		
		If (TheLine.Args[0] == 0)
			Return TheLine.BackSector;
		
		Return Result;
	}
	
	//KLUDGE: Sector.PlaneMoving doesn't work, despite doing the same thing as this. So we have to use this, epic.
	Bool SM_SectorInMotion (Sector Sec)
	{
		If (!Sec)
			Return False;
		
		If (Sec.FloorData || Sec.CeilingData)
			Return True;
		
		Return False;
	}
	
	//Get the middle point of a line.
	//KLUDGE: GZDoom really doesn't like this formula I found on the Unreal Engine forum. Probably because it's too straightforward for its' esoteric tastes.
	Vector2 GetLinePos (Line TheLine)
	{
		If (!TheLine)
			Return (Double.NaN, Double.NaN);
		
		Return ((TheLine.V2.P - TheLine.V1.P) * 0.5 + TheLine.V1.P); 
	}
	
	//KAI_MoveAway wrapper, handles running behind cover, as well as parkouring when retreating.
	//NOTE: If the RetreatPos marine variable is valid, the marine will run from that instead. Not the Other actor.
	Void SM_RunAway (Actor Other, Double RunRad = 64, Int MaxSteps = 32, Double TurnRadius = 25, Int ChaseFlags = 0, Int Flags = 0)//, Int KMAFlags = 0)
	{
		If (!(MarineState & MARINE_INCOVER))
		{
			If (!SM_IsRestricted (RESTRICT_CROUCHING)) Crouching = KAI_HandleCrouching (Default.Height,MARINE_CROUCHHEIGHT); //Handle crouching, duh.
			
			//Handle climbing
			If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) && KAI_HandleClimbing (ClimbPos,JumpPos,"Climb","Jump.Up",1.1,1.75))
				Return;
			
			If (!Crouching && !SM_IsRestricted (RESTRICT_CLIMBING) && SM_HandleClimbDown(Height*1.75)) //Handle jumping down any ledges that you can still climb up to if you want.
				Return;
			
			//Handle jumping.
			Vector2 JumpPosition = (Double.NaN,Double.NaN);
			If (!SM_IsRestricted (RESTRICT_JUMPING)) JumpPosition = KAI_GetJumpPosition (MARINE_JUMPLENGTH,Angle);
			If (JumpPosition == JumpPosition && !Crouching) //We have a valid position we must jump to, AKA the returned vector isn't null.
			{
				JumpPos = (JumpPosition,Double.NaN); //The GetJumpPosition function is only concerned with 2D coordinates.
				//The jump is longer than half the max jump distance, normally we do a running jump, but since we are presumably running for our lives, don't bother.
				If (Level.Vec2Diff (Pos.XY,JumpPosition).Length() >= MARINE_JUMPLENGTH/1.5)
					Return;
				Else
				{
					SetStateLabel ("Jump");
					Return;
				}
			}
		}
		
		If (!FindInventory ("SM_DropoffToken") || bOnMobj) bDropoff = bOnMobj; //Allow the marine to walk up around really tall actors like trucks. But not do shit like walk of cliffs.
		//We're running away because we need to reload, but we do have a turret to head to, so runs towards it to use it instead..
		If (TargetTurret && MarineState & MARINE_RELOAD)
		{
			If (TargetTurret && Distance3DSquared(TargetTurret) <= (MeleeRange*MeleeRange)*1.2)
			{
				TargetTurret.EnterEmplacement(Self);
				TargetTurret = Null; //Nullify this, also just in case the EnterEmplacement() fails.
				Return;
			}
			Double RealSpeed = Speed;
			If (Crouching)
				Speed *= 0.7;
			KAI_MoveTowards(TargetTurret.Pos,0.5,TurnRadius,ChaseFlags);
			Speed = RealSpeed;
			Return;
		}
		
		//If (KAI_DebugPrintMessages)console.printf ("SM_RunAway(): NearbyCoverPos is %d %d %d",nearbycoverpos);
		//If (KAI_Math.IsEmptyVector3 (NearbyCoverPos))
		//{
			Double RealSpeed = Speed;
			If (Crouching)
				Speed *= 0.7;
			KAIMoveParams Data;
			Data.CornerDist = 384;
			Data.CornerDiv = 12; //Check every 32 MU, seems reasonable.
			Data.ObstacleDist = 128;
			Data.ObstacleSlices = 16;
			KAI_MoveAway (Other, 16, RunRad, MaxSteps, 0.5, TurnRadius, ChaseFlags, Flags, 0, RetreatPos, extraparams:Data);
			Speed = RealSpeed;
		/*	If (!HazardToAvoid) NearbyCoverPos = SM_LocateNearbyCover (Other);
		}
		Else
		{If (KAI_DebugPrintMessages)console.printf ("SM_RunAway(): %p retreating behind cover at %d %d %d",Self,NearbyCoverPos);
			SM_RunToCoverPos (Other,1,False); //Handle running to cover, specifically giving up if the cover is no longer good.
			KAI_MoveTowards (NearbyCoverPos, 0.5, TurnRadius, ChaseFlags);
		}*/
	}
	
	//Returns true if the marine is down on the ground in some capacity, as opposed to standing up.
	Bool SM_IsCrouched()
	{
		Return (Crouching || MarineState & (MARINE_KNEELING|MARINE_LYINGDOWN|MARINE_INCOVER));
	}
	
	//DECORATE-esque function for use in states.
	Void SM_SetMarineState (Int Add, Int Remove, Bool RemoveAll = False, Int Exceptions = 0/*, Int Action = 0*/)
	{
		If (!RemoveAll)
			MarineState &= ~Remove;
		Else
		{
			If (!Exceptions)
				MarineState = 0;
			Else
				MarineState &= Exceptions; //Remove all bits, excepts the ones passed in the Exceptions bitfield.
		}
		MarineState |= Add;
	}
	
	//Credit: Lewisk3
	void SM_FireGrenade(Actor toAct, class<Actor> nade, double maxPitch = 90, double aimSens = 1.0, double aimDist = 128)
	{
		if(!toAct) return;
		
		// Source and Destination
		vector3 fromPos = (
			pos.xy,
			pos.z + (height)
		);
		vector3 toPos = (
			toAct.pos.xy, 
			toAct.pos.z + (toAct.height * 0.5) 
		);
		
		vector3 diff = level.vec3diff(fromPos, toPos);
		
		// Spawn grenade, calculate values from instance.
		let nade = Spawn(nade, fromPos);
		if(!nade) return;    
		nade.target = self;
		
		// Modify toPos Z component based on how many units the thrown grenade
		// fall by the time it reaches the destination.
		double dist = diff.xy.Length();
		if(dist >= aimDist)
		{
			double grav = 1.0 + ceil(nade.GetGravity() * (level.gravity * 0.010769));
			double ticsDist = diff.Length() / double(max(nade.Speed,1.0));        
			double fallDist = ticsDist * grav;
			toPos.z += fallDist * aimSens;
		}
		
		// Recalculate differences.
		diff = level.vec3diff(fromPos, toPos);
		double aimPitch = VectorAngle( sqrt(diff.y*diff.y + diff.x*diff.x), diff.z );
		aimPitch = min(aimPitch, maxPitch);
		
		// Modify grenade velocity
		double a = AngleTo(toAct);
		double p = -aimPitch;
		nade.vel = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * nade.Speed;
	}
	
	State SM_CheckRefire (Int Chance, StateLabel AbortState, Double FOV = 360)
	{
		If (CurSector.Flags & Sector.SECF_NOATTACK)
			Return FindState (AbortState);
		
		AimPos = GetFAFAimPos (Target);
			
		If (Random2[pr_monsterrefire]() < Chance)
			Return State (Null);
		
		If (!Target || IsDead (Target) || (Target && !CheckFOV (Target,FOV)))
			{If (KAI_DebugPrintMessages)a_log ("marine refire cancelled");Return FindState (AbortState);}
		
		Double OldHeight = Height;
		If (SM_IsCrouched())
			Height = Default.Height; //Uncrouch for the sight check.
		
		If (!CheckSight (Target,SF_SEEPASTBLOCKEVERYTHING|SF_SEEPASTSHOOTABLELINES))
		{
			Height = OldHeight; If (KAI_DebugPrintMessages)a_log ("marine refire cancelled");
			Return FindState (AbortState);
		}
		Height = OldHeight;
		
		Return State (Null);
	}
	
	//Marines just fire SM_Bullet, so for now at least, so we mostly just need the trace offsets.
	Bool SM_CheckLOF (Vector3 CheckOffsets = (0,0,32), Int PropHealthThreshold = 25, Bool AimingAt = False)
	{
		Let Check = New ("KAI_ProjectileLOFCheck");
		
		AimPos = GetFAFAimPos (Target);
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Target)
			{
				Double PitchTo = PitchTo (Target,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Target), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Double Distance = !AimingAt ? MaxTargetRange : Distance3D (Target)+8;
		Check.Shooter = Self;
		Check.Other = Target;
		Check.PropHealthThreshold = PropHealthThreshold; //This can depend on factors like how many rounds the marine is firing.
		Check.FriendlyFire = True;
		
		Check.ProjInfo = New ('LOFProjInfo'); //Assign data class.
		Check.ProjInfo.Projectile = "SM_Bullet"; //Pass projectile class to trace.
		Check.ProjInfo.InitializeProjectileInfo(); //Let it infer the rest.
		
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,Distance,0);
		
		//FSpawnParticleParams Debug; Debug.Lifetime = 8;
		//KAI_LOFRaycast.VisualizeTracePath (Level.Vec3Offset (Pos,CheckOffsets),Check.Results.HitPos,Check.Results.Distance,params:Debug);
		Bool BadLoaf = Check.BadLOF;
		If (Check.ProjInfo) Check.ProjInfo.Destroy();
		Check.Destroy();
		Return !BadLoaf;
	}
	
	Bool SM_FindInLOF (Actor Who, Vector3 CheckOffsets = (0,0,32), Bool AimingAt = False)
	{
		Let Check = New ("SM_FindTargetInLOF");
		
		Vector3 Direction;
		If (AimingAt)
			Direction = (AngleToVector(Angle, Cos(Pitch)), -Sin(Pitch));
		Else
		{
			If (Who)
			{
				Double PitchTo = PitchTo (Who,Height/2,GetAimPosOffset());
				Direction = (AngleToVector(AngleTo(Who), Cos(PitchTo)), -Sin(PitchTo));
			}
			Else
				Return False; //Actor stopped existing, so no need to fire.
		}
		
		Check.Shooter = Self;
		Check.Other = Who;
		Check.BadLOF = True; //We have to assume the LOF is bad, and if the trace finds the other actor, then it's a good LOF.
		Check.Trace (Level.Vec3Offset (Pos,CheckOffsets),CurSector,Direction,MaxTargetRange,0);
		Bool Res = Check.BadLOF;
		Check.Destroy();
		Return !Res;
	}
	
	//Get what part of the actor the marine is aiming at now.
	Double GetAimPosOffset ()
	{
		Switch (AimPos)
		{
			Case FAF_MIDDLE:
				Return Target.Height/2;
			Case FAF_TOP:
				Return Target.Height;
			Case FAF_BOTTOM:
				Return 0; //The bottom is the origin of actors.
			Default:
				Return 0;
		}
	}
	
	//Return what grenade type is likely currently appropriate against the enemy.
	Int DecideGrenadeType (Actor Against, Int Threshold = MARINE_GRENADECHANCE)
	{
		//Don't bother if the other actor doesn't exist, it's not time yet, or if the enemy flies and is over your head !
		If (Threshold <= 0 || !Against || GrenadeDelay || IsFlying (Against) && Pos.Z+Height < Against.Pos.Z) Return GRENADE_NONE;
		If (Distance3DSquared (Against) >= 768*768 || !SM_CheckLOF((0,0,Height),0)) //Not in throwing range. Or there is no direct LOF, yes, this doesn't account for arcing, I WILL NOT TRY.
			{If (KAI_DebugPrintMessages)console.printf ("DecideGrenadeType(): target is too close or the LOF is bad");Return GRENADE_NONE;}
		
		Bool ImmuneToBlasts = (Against.bNoRadiusDmg || Against.GetRadiusDamage (Against,256,256,128,False,True) <= 256/8); //The enemy is immune or HIGHLY resistant to blasts.
		Bool UseHE, UseSmoke;
		
		//Decide to throw the HE-FRAG grenade without the frag sleeve. Large blast radius and damage, good for strong enemies.
		//Based on RNG, if the target is super powerful, and if it's not effectively immune to pure explosion damage.
		If (!ImmuneToBlasts && (Random (0,255) < 96 || AssessThreatLevel (Against) >= ThreatLevelThreshold))
		{
			//Randomly decide to throw smoke, as long as the enemy CAN be affected by the smokescreen.
			If (Random (0,255) < 120 && (!Against.bSeeInvisible || Against.bShadowAim || Against.Player) && (Against.Player || Against.bDoShadowBlock))
				UseSmoke = True;
			Else
				UseHE = True;
		}
		
		//Now, let's check the chance of actually throwing a grenade.
		Int BulletDamage = Against.ApplyDamageFactor ("SmallRifleBullet",100); //Return how much damage the actor would actually take if 10 bullets did maximum damage.
		Int GrenChance = (Threshold > 0) ? Random (0,Threshold-24) : INT.MAX;
		Int PreGrenChance = GrenChance; //The grenade chance before being incremented by AttackByQuantity.
		Double BlastRadius = 192;
		If (Threshold > 0)
		{
			GrenChance += 100-BulletDamage; //Increase grenade chance based on how much bullet damage the enemy can absorb.
			If (Target.Speed <= 6 || Random (0,255) < 64) //Our target is quite slow, lets see about throwing a smoke grenade.
				GrenChance += SM_AttackByQuantity (Target,!UseHE ? 192 : 256,True,ABQ_Infight|ABQ_Smokescreen);
			Else
				GrenChance += SM_AttackByQuantity (Target,!UseHE ? 192 : 256,True); //Grenade chance is also based on crowd size.
		}
		If (GrenChance >= Threshold) //Decide if you should throw an HE or frag grenade.
		{If (KAI_DebugPrintMessages)console.printf ("DecideGrenadeType(): grenade chance is over the threshold");
			If (UseHE)
				Return GRENADE_HE;
			Else If (UseSmoke)
				Return GRENADE_SMOKE;
			Else
				Return GRENADE_HEFRAG;
		}
		
		Return GRENADE_NONE;
	}
	
	//Prepare to throw a smoke grenade in front of you before retreating. That is to say like when running to reload.
	Bool PrepareForSmokeThrow (Int Chance = 48)
	{
		If (Target && Distance3DSquared (Target) <= 256*256) //If the target is too close, don't bother. Like if running away from a melee enemy.
			{If (KAI_DebugPrintMessages)A_LOG ("PrepareForSmokeThrow(): target is too close");Return False;}
		
		Chance += SM_AttackByQuantity (Target,flags:ABQ_Smokescreen); //Increase chance the more danger their is around.
		
		If (Health <= SpawnHealth()/3) //Extra chance if low on health.
			Chance += 30;
		
		If (Random (0,255) >= Chance)
			{If (KAI_DebugPrintMessages)console.printf ("a smoke chance of %d wasn't enough",chance);Return False;}
		
		//SM_SetMarineState (MARINE_RETREAT,MARINE_IDLING|MARINE_CHASING); //Specifies to the grenade drop state that the marine needs to retreat afterwards.
		GrenadeType = GRENADE_SMOKE;
		QuickGrenade = True;If (KAI_DebugPrintMessages)a_log ("throwing quick grenade and dipping.");
		Return True;
	}
	
	Enum ABQFlags
	{
		ABQ_Smokescreen = 1 << 0, //If on, ignore actors that can see through DOSHADOWBLOCK, unless they are players. 
		ABQ_Infight		= 1 << 1, //Give bonus points for monsters that can infight. Based on how many other monsters that can infight are found in Range.
	}
	
	//Increase an integer value based on the amount of enemies and how powerful they are, to use for AOE attacks. Copied from the MVP !.
	//Range: The range around which to check for enemies.
	//AvoidAllies: Deduct points from the score for any allies in the AOE.
	//Smokescreen: This is a check for if the marine is throwing a smoke grenade. Makes actors that can see throw the smoke be ignored from the count.
	Int SM_AttackByQuantity (Actor Origin, Double Range = 256, Bool AvoidAllies = False, Int Flags = 0)
	{
		If (!Origin) Return 0;
		Actor Mobj;
		Int Chance;
		Bool IsHostile, IsVisible; //Caching
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Origin,Range);
		
		Int ViableEnemies;
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			If (!Mobj || IsDead (Mobj) || IsInanimateObject (Mobj) || Mobj == Self/* || Mobj == Origin*/) Continue;
			
			IsHostile = IsActorHostile (Mobj); IsVisible = IsVisible (Mobj,False);
			If (AvoidAllies && !IsHostile && IsVisible)
			{
				If (Mobj.bIsMonster) Chance -= 10;
				If (Mobj.Player) Chance -= 40;
				Continue;
			}
			
			//Actor can see through smoke grenades, because it's an NPC that's unfazed by SHADOWBLOCK.
			If (Flags & ABQ_Smokescreen && IsHostile && IsVisible && !(!Mobj.bSeeInvisible || Mobj.bShadowAim || Mobj.Player) && (Mobj.Player || Mobj.bDoShadowBlock))
				Continue;
			
			If (IsHostile)
				ViableEnemies++;
			
			If (Flags & ABQ_Infight && IsHostile && IsVisible && Mobj.OkayToSwitchTarget (Origin))
				Chance += ViableEnemies; //Give an additional bonus if the monster can infight with the target, based on every additional monster in range.
			//If (KAI_DebugPrintMessages)console.printf ("%s can infight with %s, so the chance is now %d",mobj.getclassname(),origin.getclassname(),chance);}
			If (IsHostile && IsVisible && Mobj.Distance3DSquared (Origin) <= Range*Range)
			{
				Switch (AssessThreatLevel (Mobj))
				{
					Case THREAT_UNSTOPPABLE:
						Chance += 500;
						Break;
					Case THREAT_SUPERDANGER:
						Chance += 200;
						Break;
					Case THREAT_VERYDANGEROUS:
						Chance += 80;
						Break;
					Case THREAT_DANGEROUS:
						Chance += 40;
						Break;
					Case THREAT_ABOVENORMAL:
						Chance += 20;
						Break;
					Case THREAT_NORMAL:
						Chance += 10;
						Break;
					Case THREAT_MILD:
						Chance += 8;
						Break;
					Case THREAT_LOW:
						Chance += 5;
						Break;
					Case THREAT_VERYLOW:
						Chance += 1;
						Break;
					Case THREAT_NONE:
						Break;
					Default:
						Chance += 1;
						Break;
				}
			}
		}
		
		Return Chance;
	}
	
	//Alert every KAI NPC in range of your current target, unless they're busy already.
	Void SM_AlertNearbyAllies (Double Range = 512, Bool IgnoreCreatures = False)
	{
		If (SM_IsRestricted (RESTRICT_WARNALLIES) || Range <= 0) Return;
		BlockThingsIterator FindAllies = BlockThingsIterator.Create (Self,Range);
		Actor Mobj;
		Bool AlertedSomeone;
		Array <Actor> Alerted;
		
		While (FindAllies.Next())
		{
			Mobj = FindAllies.Thing;
			If (!Mobj || IsDead (Mobj) || IsInanimateObject (Mobj) || Mobj == Self || Mobj.Target) Continue;
			
			If (!(Mobj Is "KAI_Actor") || IgnoreCreatures && Mobj Is "KAI_Creature" || IsActorHostile (Mobj)) Continue;
			
			If (Distance3DSquared (Mobj) > Range*Range) Continue;
			
			KAI_Actor(Mobj).KAI_ShareTarget(Self,Target);
			AlertedSomeone = True;
			Alerted.Push (Mobj);
		}
		
		//Alert all actors in the groups you are leading chase that target if possible. If no alerted already.
		ForEach (Group : Groups)
		{
			If (Group.Leader != Self) Continue;
			ForEach (Member : Group.Members)
			{
				If (Member Is "KAI_Actor" && Alerted.Find(Member) == Alerted.Size() && Member != Self)
				{
					If (KAI_DebugPrintMessages) console.printf ("alerting group member %p (%s) of %s",member,member.getclassname(),target.getclassname());
					KAI_Actor(Member).KAI_ShareTarget (Self,Target);
					AlertedSomeone = True;
					Alerted.Push (Member);
				}
			}
		}
		
		If (AlertedSomeone)
		{
			If (Random (0,256) == Random (0,256))
				A_StartSound ("Marine/AlertAlliesAlt",CHAN_VOICE,attenuation:0.75);
			Else
				A_StartSound ("Marine/AlertAllies",CHAN_VOICE,attenuation:0.75);
		}
	}
	
	HazardInfo GetNearestHazard (Array<HazardInfo> HazardList)
	{
		Double ClosestDist = INT.MAX;
		HazardInfo Closest;
		
		ForEach (CurHaz : HazardList)
		{
			If (CurHaz)
			{
				If (CurHaz.Flags & HazardInfo.HAZ_SECTOR) //The first hazard found in the same sector as you is the closest.
					Return CurHaz;
				
				Double Dist = GetHazardDistance (CurHaz);
				If (Dist < ClosestDist)
				{
					ClosestDist = Dist;
					Closest = CurHaz;
				}
			}
		}
		
		Return Closest;
	}
	
	HazardInfo GetStrongestHazard (Array<HazardInfo> HazardList)
	{
		Int StrongestHaz = HazardInfo.HAZARD_HARMLESS;
		HazardInfo Strongest;
		
		ForEach (CurHaz : HazardList)
		{
			If (CurHaz)
			{
				Int Strength = CurHaz.Level;
				If (Strength > StrongestHaz)
				{
					StrongestHaz = Strength;
					Strongest = CurHaz;
				}
			}
		}
		
		if (strongest) {console.printf ("running from this hazard:");strongest.printhazardinfo();}
		Return Strongest;
	}
	
	Enum RunAwayTypes //How should the marine run from a dangerous hazard, if at all ?
	{
		RUN_NONE, //The marine doesn't need to run.
		RUN_WALK, //The marine should probably avoid it, but just walk around it if possible, since it's not that serious.
		RUN_FAST, //Stop what you are doing and run away. Original marine behavior to grenades and the old SM_ImInDanger token.
	}
	
	//How should the marine run away from this hazard zome, if at all ?
	RunAwayTypes SM_ShouldRunFromHazard (HazardInfo Hazard)
	{
		If (!Hazard || !bAvoidHazards)
			Return RUN_NONE;
		
		//Run away from actually dangerous threats, or if the hazard in question is weak but you are close to dying.
		If (Hazard.Level >= HazardInfo.HAZARD_MEDIUM || Hazard.Level != HazardInfo.HAZARD_HARMLESS && Health <= SpawnHealth()/3)
			Return RUN_FAST;
		
		//Dealing with a minor threat, so just walk around it if not doing anything else and not low on health.
		If (Hazard.Level < HazardInfo.HAZARD_MEDIUM && Hazard.Level != HazardInfo.HAZARD_HARMLESS)
			Return RUN_WALK;
		
		Return RUN_NONE;
	}
	
	//Search for dangerous enemies around you.
	Bool IsDangerNearby (Double Range = 1024)
	{
		If (Target && CheckSight (Target, SF_IGNOREWATERBOUNDARY)) //My target is visible, that's an enemy.
			{If (KAI_DebugPrintMessages)a_log ("IsDangerNearby(): Found target");Return True;}
		
		For (Int pn = 0; pn < MAXPLAYERS; pn++)  //An enemy player is visible, now THAT'S an enemy.
		{
			If(!PlayerInGame[pn])
				Continue;
			PlayerInfo plr = Players[pn];
			
			If (Plr && !IsFriend (Plr.Mo) && CheckSight(Plr.Mo,SF_IGNOREWATERBOUNDARY))
				{If (KAI_DebugPrintMessages)a_log ("IsDangerNearby(): Found enemy player");Return True;}
		}
		
		//Look for dangerous enemies.
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
			
			//Skip this actor if it's dead, cannot be targeted, is not a monster nor a player, or is not even an enemy.
			If (!Mobj || IsDead (Mobj) || IsInanimateObject(Mobj) || !CanBeTargeted (Self, Mobj) || !IsActorHostile (Mobj)) Continue;
			
			If (!CheckSight (Mobj)) Continue; //And at last, check if the enemy is even visible.
			If (KAI_DebugPrintMessages)a_log ("IsDangerNearby(): Found random enemy NPC");
			Return True;
		}
		
		Return False;
	}
	
	//IDEA: Maybe add some kind of health sort, to pick the most frail or powerful ally ?
	Actor SM_FindAllyToHelp (Double Range = 1024, Int HealthThreshold = 7)
	{
		If (SM_IsRestricted(RESTRICT_HEALING)) Return Null;
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,Range);
		Array <Actor> Friends; //Store nearby allies to potentially heal.
		Array <Actor> Marines; //And friendly marines too, to ignore allies another marine is going to anyway.
		Array <Actor> Players; //Store found players, so they take priority if they aren't targeted for healing to begin with.
		
		While (FindEnemies.Next())
		{
			Actor Mobj = FindEnemies.Thing;
		
			//If the ally is indestructible, not even alive, a prop, or hasn't lost more than 7 HP, we don't need to help them.
			If (!Mobj || Mobj == Self || IsIndestructible(Mobj) || IsInanimateObject (Mobj) || IsDead (Mobj) || SM_GetMaxHealth (Mobj)-HealthThreshold < Mobj.Health)
				Continue;
			
			If (Mobj.bNoBlood) //Don't heal inorganic things like robots and vehicles.
				Continue;
			
			If (IsActorHostile (Mobj)) //Duh
				{If (KAI_DebugPrintMessages)console.printf ("%s %p is hostile",mobj.getclassname(),mobj);Continue;}
			
			//Out of range, sight, or reach, in order of cost.
			If (Distance3DSquared (Mobj) > Range*Range || !CheckSight (Mobj,SF_IGNOREWATERBOUNDARY) || !SM_IsPosReachable (Mobj.Pos,ignoreactors:True))
				Continue;
			
			If (Mobj Is "SM_Marine")
				Marines.Push (Mobj);
			
			If (Mobj.Player)
				Players.Push (Mobj);
			If (KAI_DebugPrintMessages)a_log ("SM_FindAllyToHelp: found a friend");
			Friends.Push (Mobj);
		}
		
		//Ignore this if no other marines are near anyway.
		If (Marines.Size() > 0 && Friends.Size() > 0)
		{
			Actor HealTarg;
			//Check every nearby friendly marine to ignore allies they are already going to heal.
			For (Int I = Marines.Size()-1; 0 <= I; I--)
			{
				If (Marines[I] && (HealTarg = SM_Marine(Marines[I]).HealTarget))
					Friends.Delete (Friends.Find (HealTarg)); //This ally is already going to be healed.
			}
		}
		
		If (Players.Size() > 0) //Just pick the first player you find.
			Return Actor(Players[0]);
		
		If (Friends.Size() > 0)
			Return Friends[Random (0,Friends.Size()-1)];
		
		Return Null;
	}
	
	Enum StrafeDirections
	{
		STRAFE_RANDOM = -1, //Strafe in a random direction.
		STRAFE_NONE = 0, //Don't strafe.
		STRAFE_LEFT = 1, //Strafe left.
		STRAFE_RIGHT = 2 //Strafe right.
	};
	
	//After a projectile to dodge is found by SM_ShouldDodgeProjectile, this function handles picking a direction, if any, to dodge out of the way towards.
	Bool SM_HandleDodging (Actor Projectile, Bool DontJump = False)
	{
		If (!Projectile || bDormant || IsDead(Self) || Pos.Z > FloorZ+8 || SM_IsRestricted (RESTRICT_DODGING)) Return False;
		If (KAI_DebugPrintMessages)console.printf ("SM_HandleDodging(): Dodged a %s",projectile.getclassname());
		
		//The marine is behind cover but not crouching, so dodge by going prone.
		If (MarineState & MARINE_INCOVER)
		{If (KAI_DebugPrintMessages)console.printf ("marine is in cover, dodging by crouching down");
			Crouching = True;
			Height = MARINE_CROUCHHEIGHT;
			GrenadeDelay += GameTicRate/2;
			NextFireDelay += GameTicRate/2;
			If (MarineState & MARINE_FIRING)
				SetStateLabel ("Fire.End");
			Return True;
		}
		
		Bool IsHoming = Projectile.bSeekerMissile;
		//HACK: Why did Carmack fucking code the stupid rocket like this.
		If (Projectile.GetClassName() == "RevenantTracer")
			IsHoming = Projectile.FindInventory ("SM_RevenantTracerToken");
		//Try to run from homing projectiles chasing you that are slower than 25 mu/tic...
		If (IsHoming && Projectile.Tracer == Self && Projectile.Speed <= 25 &&
		//...and as long as it does too much damage to you. TODO: Make it account for ALL damage methods, damage factors, virtual overrides, and armor items!
		(Health <= SpawnHealth()/3 || ApplyDamageFactor(Projectile.DamageType,Projectile.GetMissileDamage (1,7)) >= Health/6))
		{
			If (KAI_DebugPrintMessages) console.printf ("SM_HandleDodging(): Running from %s",projectile.getclassname());
			RetreatPos = Projectile.Pos;
			RetreatLoops = 4;
			DodgingHomingProjectile = True;
			SetStateLabel ("Retreat");
			Return True;
		}
		
		Bool RightSafe, LeftSafe;
		Double OldAngle = Angle; //Store the current angle before facing the projectile to dodge it.
		Double OldDropoffHeight = MaxDropoffHeight;
		
		MaxDropOffHeight = 128; //Temporarily increase the maximum height the marine can drop from.
		
		If (CheckFOV (Projectile,120/2)) //Marines will only know the movement direction if they can actually see it.
			Angle = VectorAngle (Projectile.Vel.X,Projectile.Vel.Y)-180; //Jump away from the projectiles' movement direction.
		
		//Check if it's safe to strafe 56 map units to the left or right, or both. Or none even, like in the case of crammed corridors.
		Bool DecidedLeft, DecidedRight;
		Double Delta = DeltaAngle (Angle,AngleTo(Projectile));
		If (Delta >= -2 && Random (0,255) < 200) //No, the projectile is heading too much towards the left side.
		{
			If (KAI_DebugPrintMessages)a_log ("the projectile is to the left of the marine");
			LeftSafe = False;
			DecidedLeft = True;
		}
		Else If (Delta <= 2 && Random (0,255) < 200) //Ditto, but for the right side.
		{
			If (KAI_DebugPrintMessages)a_log ("the projectile is to the right of the marine");
			RightSafe = False;
			DecidedRight = True;
		}
		
		If (!DecidedLeft) LeftSafe = CheckMove (Vec2Angle (56,Angle+90),PCM_DROPOFF);
		If (!DecidedRight) RightSafe = CheckMove (Vec2Angle (56,Angle-90),PCM_DROPOFF);
		
		Int StrafeDirection;
		
		If ((LeftSafe && RightSafe)) //Both directions are safe to strafe to.
			StrafeDirection = STRAFE_RANDOM;
		Else If ((!LeftSafe && !RightSafe)) //The area is too crammed to strafe anywhere here.
		{
			Angle = OldAngle; //Revert the marines' angle if you can't dodge.
			StrafeDirection = STRAFE_NONE; //Reset the strafe direction to none.
			MaxDropOffHeight = OldDropoffHeight; //Revert the property to the default again.
			Return False; //Don't break whatever state sequence the marine is currently in to tell him he can't dodge.
		}
		Else If (LeftSafe && !RightSafe) //Can only strafe left.
			StrafeDirection = STRAFE_LEFT;
		Else If (!LeftSafe && RightSafe) //Can only strafe right.
			StrafeDirection = STRAFE_RIGHT;
		
		MaxDropOffHeight = OldDropoffHeight; //Revert the property to the default again.
		
		If (!DontJump) //Don't jump in both the literal and Doom state machine sense.
		{
			Double JumpAng = StrafeDirection == STRAFE_RANDOM ? Angle+RandomPick (90,-90) : 0;
			If (StrafeDirection == STRAFE_LEFT)
				JumpAng = Angle+90;
			Else If (StrafeDirection == STRAFE_RIGHT)
				JumpAng = Angle-90;
			JumpPos.XY = Vec2Angle (96,JumpAng);
			JumpPos.Z = GetZAt (JumpPos.X,JumpPos.Y)+(Height/2);
			SetStateLabel ("Jump.Dodge");
		}
		
		Return True; //Found a direction to strafe at to dodge.
	}
	
	Enum DodgePickModes
	{
		DODGE_FIRST, //Simplest and cheapest, just dodge the first valid projectile found. Also how the marines originally dodged.
		DODGE_RANDOM, //Idiot mode.
		DODGE_STRONGEST, //Dodge the strongest projectile in range.
		DODGE_NEAREST, //Dodge the closest projectile in range.
	}
	
	//Find and return a pointer to a projectile for the marine to dodge.
	//Update: Seems like because the default dodge radius is smaller than the grenade hazard radius, they run from grenades anyway.
	Actor SM_ShouldDodgeProjectile (Double Range = 384, Int DodgeMode = DODGE_STRONGEST, Actor Ignore = Null)
	{
		Array <Actor> Threats;
		
		//Actually find projectiles.
		ForEach (Proj : KAIHandler.ProjectileList)
		{
			If (!Proj) Continue;
			
			Bool DodgeAllyProjectiles; //If on, the marine will dodge the projectile even if it's fired by an ally.
			
			Bool IsHoming = Proj.bSeekerMissile;
			//HACK: Why did Carmack fucking code the stupid rocket like this.
			If (Proj.GetClassName() == "RevenantTracer")
				IsHoming = Proj.FindInventory ("SM_RevenantTracerToken");

			Double Dist = Distance3DSquared (Proj);
			If ((Dist > Range*Range || IsHoming && Proj.Tracer == Self && Dist > (Range*Range)*2 ) || Proj == Ignore) //Out of range or put on ignore. But if it's a seeker, check at double the range to potentially run away.
				Continue;
			
			//Dodge even friendly projectiles if they'd do too much damage, unless friendly fire is off.
			DodgeAllyProjectiles = (!(Proj Is "KAI_BaseProjectile" && KAI_BaseProjectile(Proj).bNoFriendlyFire) && Proj.GetMissileDamage (1,7) >= Health/2);
			
			If (!DodgeAllyProjectiles && !IsActorHostile (Proj.Target)) //Ignore friendly projectiles.
				Continue;
			
			//Don't return true if the projectile is too far away from the marines' peripheral vision. Or if it isn't so close that it's impossible not to notice it.
			If (!CheckFOV (Proj,120/2) && Dist > MeleeRange*MeleeRange)
				Continue;
			
			//Is the projectile about to hit me ? Weird math nonsense written by RaveYard.
			double blackBox = -0.15;
			If (IsHoming && Proj.Tracer == Self) blackBox = -0.075;
			bool projectile_is_flying_towards_me = (Vec3To(proj).Unit() dot proj.vel.Unit()) < blackBox;
			double projectileSafeRadius = sqrt(2 * ((proj.radius + radius) ** 2.5));
			if(projectile_is_flying_towards_me && KAI_Math.distance3dline(pos, proj.pos, proj.pos + proj.vel) < projectileSafeRadius && CheckSight(Proj,SF_IGNOREWATERBOUNDARY))
			{
				If (DodgeMode != DODGE_FIRST)
					Threats.Push (Proj);
				Else
					Return Proj;
			}
		}
		
		If (DodgeMode == DODGE_RANDOM)
			Return (Threats[Random (0,Threats.Size()-1)]);
		Else If (DodgeMode == DODGE_NEAREST)
		{
			Double NearestDistance = INT.MAX;
			Actor NearestProj;
			For (Int I = Threats.Size()-1; I >= 0; I--)
			{
				Double CurrentDistance = Distance3D(Threats[I]);
				If (NearestDistance > CurrentDistance)
				{
					NearestDistance = CurrentDistance;
					NearestProj = Threats[I];
				}
			}
			
			Return NearestProj;
		}
		Else If (DodgeMode == DODGE_STRONGEST)
		{
			Double HighestDamage;
			Actor StrongestProj;
			For (Int I = Threats.Size()-1; I >= 0; I--)
			{
				Double CurrentDamage = Threats[I].GetMissileDamage(1,7);
				If (HighestDamage < CurrentDamage)
				{
					HighestDamage = CurrentDamage;
					StrongestProj = Threats[I];
				}
			}
			
			Return StrongestProj;
		}
		
		Return Null;
	}
	
	//Runs the code that checks if the marine has landed on the ground again while mid-air.
	State SM_JumpLoop (Bool DodgeAttack = False)
	{
		If (DodgeAttack) //Aim towards a target to shoot at while dodging, only useful for Jump.Dodge.Attack:, really.
		{
			Actor Targ = Target;
			
			If (LastDodged && LastDodged.Target && AbsAngle(Angle,AngleTo(LastDodged.Target)) <= 25 && IsActorHostile(LastDodged.Target) && CanBeTargeted (Self, LastDodged.Target))
				Target = LastDodged.Target;
			
			AimAtTarget (8,8,attackspeed:170,200);
			
			Target = Targ;
		}
		
		If (!SM_IsRestricted (RESTRICT_CLIMBING)) KAI_HandleClimbing(ClimbPos,Null,"Climb",Null,1.1,1.75);
		If (bOnMobj || Pos.Z <= GetZAt ()) //The eagle has landed.
		{
			bNoFriction = Default.bNoFriction;
			A_Stop(); //Stop moving.
			GiveInventory ("SM_DropoffToken",1); //HACK: Zandronum Moment
			If (DodgeAttack) //We were firing while we were dodging, so specify that we're no longer MARINE_FIRING.
				SM_SetMarineState (0,MARINE_FIRING);
			If (MarineState & MARINE_IDLING) //We were bing chilling, go back to that.
				Return FindState ("Idle",True);
			
			Return SeeState; //Or go back to chasing I guess.
		}
		
		Return State (Null);
	}
	
	//Identical to KAI's IsPosReachable, but also accounts for the marines' ability to climb, if available.
	Bool SM_IsPosReachable (Vector3 TargetPos, Double DistCutoff = 0, Double Spacing = 0, Bool IgnoreActors = False)
	{
		Double RealStepHeight = MaxStepHeight;
		Double RealHeight = Height;
		If (!SM_IsRestricted(RESTRICT_CLIMBING)) MaxStepHeight = (Height*1.75); //Maximum height the marine can reach, by jumping and ledge grabbing.
		If (!SM_IsRestricted(RESTRICT_CROUCHING)) Height = MARINE_CROUCHHEIGHT;
		Bool Res = IsPosReachable (TargetPos, DistCutoff, Spacing, IgnoreActors);
		MaxStepHeight = RealStepHeight;
		Height = RealHeight;
		Return Res;
	}
	
	//Get the max health of actors or player pawn actors.
	Int SM_GetMaxHealth (Actor Other)
	{
		If (!Other)
			Return 0;
		
		If (Other.Player)
			Return Other.GetMaxHealth();
		
		Return Other.SpawnHealth();
	}
	
	//====|Non-AI functions|====\\
	//Handles the coloring of the marines. And if the string says "Random" returns a random available color string.
	String SM_HandleMarineColoring (String WhatColor)
	{
		If (!WhatColor || WhatColor ~== "") Return WhatColor; //Don't run the code if the string is empty.
		
		//Handles the random color choice that is performed if the color name given is "Random".
		If (WhatColor ~== "Random")
		{
			Static Const String ColorArray[] = {"Red","Gray","White","Black","Blue","Yellow","Orange","Pink","DarkGreen","DarkRed","Default"}; //Contains all the valid color names.
			
			WhatColor = ColorArray[Random(0,ColorArray.Size()-1)]; //Randomly picks a color string.
		}
		
		If (!(WhatColor ~== "Default"))
			A_SetTranslation (String.Format("Marine_%s", WhatColor));
		Else
			A_SetTranslation ('');
		
		Return WhatColor;
	}
	
	//Change what sprite frame to display based on the marines' pitch.
	Int SM_UpdateElevation (Int Down, Int Straight, Int Up, Int KneelDown = -1, Int KneelStraight = -1, Int KneelUp = -1, Int LyingDown = -1)
	{
		If (Crouching) //Don't update if crouching, since the marine has no aim sprites when crouching, obviously.
			Return CurState.Frame;
		
		If (MarineState & MARINE_LYINGDOWN)
			Return LyingDown;
		
		If (!(MarineState & MARINE_KNEELING))
		{
			If (Pitch <= -15)
				Return Up;
			Else If (Pitch >= 10)
				Return Down;
		}
		Else
		{
			If (Pitch <= -15)
				Return KneelUp;
			Else If (Pitch >= 10)
				Return KneelDown;
		}
		
		If (!(MarineState & MARINE_KNEELING))
			Return Straight;
		Else
			Return KneelStraight;
	}
	
	//Update height based on marine state, used when the marine is firing while kneeling or lying down, and in the future when crouching.
	Void SM_UpdateHeight ()
	{
		If (Crouching) Return; //Crouching doesn't need updating from here, that's KAI_HandleCrouching()'s and SM_UpdateCover()'s job.
		
		If (MarineState & MARINE_LYINGDOWN)
			A_SetSize (newheight:8);
		Else If (MarineState & MARINE_KNEELING)
			A_SetSize (newheight:32);
		Else If (MarineState & MARINE_INCOVER && MarineState & MARINE_RELOAD) //Marine is loading while behind cover, so he's reloading kneeling down.
			A_SetSize (newheight:32);
		Else
			A_SetSize (newheight:Default.Height);
	}
	
	Void SM_FireBullet ()
	{
		A_StartSound ("Marine/Fire",CHAN_WEAPON,attenuation:0.6);
		Double FireHeight = 42;
		Double Recoil = 0.25;
		If (MarineState & MARINE_LYINGDOWN)
		{
			FireHeight = 14;
			Recoil /= 3;
		}
		Else If (MarineState & MARINE_KNEELING)
		{
			FireHeight = 32;
			Recoil /= 2;
		}
		If (Crouching)
		{
			FireHeight = 25;
			Recoil /= 3;
		}
		If (MarineState & MARINE_INCOVER)
			Recoil = 0;
		
		Actor Bullet = A_SpawnProjectile ("SM_Bullet",FireHeight,-6,flags:CMF_AIMDIRECTION,Pitch);
		Double AccuracyBuff = SM_IsCrouched() ? 0.5 : 1.0; //Double the accuracy if the marine is sitting down and firing.
		If (IsInState(Self,"Jump.Dodge.Attack")) AccuracyBuff *= 1.5; //Accuracy debuff for when firing in mid-dodge.
		
		Switch (AttackType)
		{
			Case FIRE_BURST:
				AddProjectileSpread (Bullet,(0.7,-0.7)*AccuracyBuff,(0.7,-0.7)*AccuracyBuff);
				Break;
			Case FIRE_SINGLE:
				AddProjectileSpread (Bullet,(0.4,-0.4)*AccuracyBuff,(0.4,-0.4)*AccuracyBuff);
				Break;
			Case FIRE_FULLAUTO:
				AddProjectileSpread (Bullet,(1.75,-1.75)*AccuracyBuff,(1.75,-1.75)*AccuracyBuff);
				A_Recoil (Recoil);
				Break;
		}
		A_SpawnItemEx ("SM_BulletCasing",0,-6,FireHeight,FRandom (0,-1),FRandom (-4,-8),FRandom(1,5));
		AmmoCount--;
	}
	
	//End the marines' firing sequence. Used by both the Fire.End: state, and when the marine abruptly dies.
	Void SM_EndFiring()
	{
		SM_SetMarineState (0,MARINE_FIRING|MARINE_THROWING|MARINE_MELEE|MARINE_KNEELING|MARINE_LYINGDOWN);
		SM_UpdateHeight();
		
		If (!IsDead(Self))
		{
			NextFireDelay = GameTicRate*Random(2,4); //Only add the timer if you didn't stop shooting by dying.
			If (MarineState == MARINE_INCOVER)
				NextFireDelay /= 2; //Fire more frequently when hiding.
		}
		
		AimTimer = BurstCounter = BurstSize = 0; //Reset aim and burst counters.
		AttackType = FIRE_BURST; //Reset to default fire mode.
	}
	
	Enum RestrictableActions
	{
		RESTRICT_NOACTION, //We aren't checking any action ?
		RESTRICT_TAKECOVER, //Marine hiding behind cover.
		RESTRICT_CLIMBING, //Marine climbs over obstacles.
		RESTRICT_JUMPING, //Marine jumps over gaps.
		RESTRICT_CROUCHING, //Marine crouching under tight spaces.
		RESTRICT_SWIMMING, //Marine swimming over swimmable 3D floors.
		RESTRICT_DODGING, //Marine dodging incoming projectiles.
		RESTRICT_HEALING, //Marine occasionally giving stimpacks to allies.
		RESTRICT_WARNALLIES, //Marine warning nearby friendly marines.
	}
	
	//Check if the following action is restricted by a token given from a restriction zone, or a user variable.
	Bool SM_IsRestricted (Int MarineAction)
	{
		If (MarineAction == RESTRICT_NOACTION)
			Return False;
		
		Let Token = SM_RestrictionToken(FindInventory ("SM_RestrictionToken"));
		
		If (MarineAction == RESTRICT_TAKECOVER && (User_NoCover || Token && Token.NoCover))
			Return True;
		If (MarineAction == RESTRICT_CLIMBING && (User_NoParkour || Token && Token.NoClimb))
			Return True;
		If (MarineAction == RESTRICT_JUMPING && (User_NoParkour || Token && Token.NoJump))
			Return True;
		If (MarineAction == RESTRICT_CROUCHING && (User_NoParkour || Token && Token.NoCrouch))
			Return True;
		If (MarineAction == RESTRICT_SWIMMING && (User_NoParkour || Token && Token.NoSwim))
			Return True;
		If (MarineAction == RESTRICT_DODGING && Token && Token.NoDodge)
			Return True;
		If (MarineAction == RESTRICT_HEALING && (User_HealCooldown == 0 || Token && Token.NoHeal))
			Return True;
		If (MarineAction == RESTRICT_WARNALLIES && Token && Token.NoWarn)
			Return True;
		
		Return False;
	}
	
	//Ask what the dog is doing.
	Actor IsDogNearby (Double DogRange = 384)
	{
		Let DogSearch = BlockThingsIterator.Create (Self,DogRange);
		
		Actor Dog;
		While (DogSearch.Next())
		{
			Dog = DogSearch.Thing;
			If (!Dog || !(Dog Is "MBFHelperDog") || IsDead (Dog))
				Continue;
			
			If (IsActorHostile (Dog))
				Continue;
			
			If (Distance3DSquared (Dog) > DogRange*DogRange)
				Continue;
			
			If (!CheckSight (Dog,SF_IGNOREWATERBOUNDARY))
				Continue;
			
			Return Dog;
		}
		
		Return Null;
	}
	
	Int FindDeadDogs (Double DogRange = 384, Actor Killer = Null)
	{
		Let DogSearch = BlockThingsIterator.Create (Self,DogRange);
		
		Actor Dog;
		Int Dogs;
		While (DogSearch.Next())
		{
			Dog = DogSearch.Thing;
			If (!Dog || !(Dog Is "MBFHelperDog") || !IsDead (Dog) || !IsFriend(Dog))
				Continue;
			
			If (Killer && Dog.Target != Killer) //Only count dogs killed by the same actor.
				Continue;
			
			Dogs++;
		}
		Return Dogs;
	}
}

//Find the marines target in the line of fire, otherwise assume the LOF is bad.
Class SM_FindTargetInLOF : KAI_LOFRaycast
{
	Override ETraceStatus TraceCallback ()
	{
		If (Other && Results.HitActor == Other)
		{If (KAI_DebugPrintMessages)console.printf ("SM_FindTargetInLOF: %s found",Other.GetClassName());
			BadLOF = False;
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

//KLUDGE: Apparently LineTrace()'s LineTracer must be fucking broken because it does NOT return the 3D floor it found.
//Find and return the first 3DFloor you hit.
Class SM_Find3DFloor : KAI_LOFRaycast
{
	Bool HitSwimmable; //Hit swimmable 3D floors too.
	Override ETraceStatus TraceCallback ()
	{
		If (HitSwimmable && Results.Crossed3DWater)
		{
			If (KAI_DebugPrintMessages)console.printf ("hit swimmable water at %d %d %d",results.crossed3dwaterpos);
			Return Trace_Stop;
		}
		
		If (HitLevelGeometry (Results))
			Return Trace_Stop;
		
		Return Trace_Skip;
	}
}

//KLUDGE: Copied from the MVPs' UniversalFunctions mixin. Because they are supposed to work independent of each other.
Mixin Class SM_SplashFunctions
{
	Enum LiquidTypes
	{
		LIQUID_NONE = 0,
		LIQUID_WATER = 1,
		LIQUID_NUKAGE = 2,
		LIQUID_BLOOD = 3,
		LIQUID_LAVA = 4,
		LIQUID_SLIME = 5
	};
	
	Int CheckLiquid (TextureID Texture)
	{
		/*===============================================================
		This class stores the names of the different textures used for each type of liquid.
		These lists can be expanded as seen fit for your project, in case it has additional custom water/nukage/blood/lava/slime textures.
		The lists already contain some names of liquid flats that don't exist in the vanilla game, for built-in mod compatibility.
		Such as by having waterfall textures that don't exist like WFALL# and NFALL#.
		===============================================================*/
		Static Const String WaterTextures[] = {"FWATER1", "FWATER2", "FWATER3", "FWATER4", "WFALL1", "WFALL2", "WFALL3", "WFALL4"};
		Static Const String NukageTextures[] = {"NUKAGE1", "NUKAGE2", "NUKAGE3", "NFALL1", "NFALL2", "NFALL3", "NFALL4"};
		Static Const String BloodTextures[] = {"BLOOD1", "BLOOD2", "BLOOD3", "BFALL1", "BFALL2", "BFALL3", "BFALL4"};
		Static Const String LavaTextures[] = {"LAVA1","LAVA2", "LAVA3", "LAVA4", "DBRAIN1", "DBRAIN2", "DBRAIN3", "DBRAIN4", "LFALL1", "LFALL2", "LFALL3", "LFALL4"};
		Static Const String SlimeTextures[] = {"SLIME01","SLIME02", "SLIME03", "SLIME04", "SLIME05","SLIME06", "SLIME07", "SLIME08", "SFALL1", "SFALL2", "SFALL3", "SFALL4"};
		
		For (Int I = 0; I < WaterTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (WaterTextures[I]) == Texture)
				Return LIQUID_WATER;
		For (Int I = 0; I < NukageTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (NukageTextures[I]) == Texture)
				Return LIQUID_NUKAGE;
		For (Int I = 0; I < BloodTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (BloodTextures[I]) == Texture)
				Return LIQUID_BLOOD;
		For (Int I = 0; I < LavaTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (LavaTextures[I]) == Texture)
				Return LIQUID_LAVA;
		For (Int I = 0; I < SlimeTextures.Size()-1; I++)
			If (TexMan.CheckForTexture (SlimeTextures[I]) == Texture)
				Return LIQUID_SLIME;
		
		Return LIQUID_NONE;
	}
	
	//Allows to quickly set up a spawned liquid splash, and then returns a pointer the splash to allow for further modifications, like making it visually larger or calling A_QuakeEx from it.
	Actor SpawnLiquidSplash (Int LiquidType = LIQUID_WATER, Sound SplashSound = "SFX/LiquidExplosion", Double Volume = 1.0, Double Attenuation = 0.5,
	Int ExplosionDamage = 0, Double ExplosionRadius = 0, Double FullDamageRadius = 0, Name DamageType = "", Bool DontHarmSource = False)
	{
		Actor Splash = Spawn ("SM_LiquidSplash",Pos);
		
		If (Splash)
		{
			//Set the shooter of the projectile for DontHarmSource to work.
			If (bMissile)
				Splash.Target = Target; //Projectiles store their shooter in the target pointer, so transfer the shooter to the splash.
			Else
				Splash.Target = Self; //Otherwise set the shooter to the actor calling the function, if it's not a projectile somehow.
			
			SM_LiquidSplash(Splash).LiquidType = LiquidType;
			SM_LiquidSplash(Splash).SplashSound = SplashSound;
			SM_LiquidSplash(Splash).Volume = Volume;
			SM_LiquidSplash(Splash).Attenuation = Attenuation;
			SM_LiquidSplash(Splash).RadiusDamage = ExplosionDamage;
			SM_LiquidSplash(Splash).MaxTargetRange = ExplosionRadius;
			SM_LiquidSplash(Splash).MeleeRange = FullDamageRadius;
			SM_LiquidSplash(Splash).ExplosionDamageType = DamageType;
			SM_LiquidSplash(Splash).DontHarmSource = DontHarmSource;
			Return Splash;
		}
		
		Return Null;
	}
	
	F3DFloor FindWaterBelow (Double Distance = 8)
	{
		Let WaterCheck = New ("SM_Find3DFloor");
		WaterCheck.HitSwimmable = True; //We only care for swimmable floors.
		
		WaterCheck.Trace (Pos,CurSector,(0,0,-1),Distance,0);
		Let FFloor = WaterCheck.Results.Crossed3DWater;
		//If (HitPos != HitPos) HitPos = WaterCheck.Results.Crossed3DWaterPos;
		WaterCheck.Destroy();
		Return FFloor;
	}
}