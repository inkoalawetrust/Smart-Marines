//This service can be searched for by other mods to check if the marine NPC is loaded.
Class SM_SmartMarines : Service
{
	Override Int GetInt (String Request, string stringArg, int intArg, double doubleArg, Object objectArg)
	{
		Let Marine = SmartMarine(ObjectArg);
		If (!Marine)
			Return -1;
		
		Return Marine.OnTurret;
	}
}

Class SM_ProjectileHandler : EventHandler
{
	//Much faster alternative to just using a ThinkerIterator.
	Array <Actor> ProjectileList;
	
	Override Void WorldThingSpawned(WorldEvent E)
	{
		//Add every spawned projectile to a big list.
		If (E.Thing && E.Thing.bMissile && E.Thing.Damage > 0)
		{
			ProjectileList.Push(E.Thing);
		}
	}
	
	Override Void WorldThingDied (WorldEvent E)
	{
		//Delete any destroyed projectiles from the list.
		If (E.Thing)
		{
			ProjectileList.Delete(ProjectileList.Find(E.Thing));
		}
	}
	
	Override Void WorldThingDestroyed (WorldEvent E)
	{
		//Delete any removed projectiles from the list.
		If (E.Thing)
		{
			ProjectileList.Delete(ProjectileList.Find(E.Thing));
		}
	}
}

Class SM_LiquidTextureNameList : EventHandler
{
	/*===============================================================
	This event handler stores the names of the different textures used for each type of liquid.
	And is then accessed by the grenades and the marines' hitscan attack, to determine what splash to produce on impact, if any.
	These lists can be expanded as seen fit for your project, in case it has additional custom water/nukage/blood/lava/slime textures.
	The lists already contain some names of liquid flats that don't exist in the vanilla game, for built-in mod compatibility.
	Such as by having waterfall textures that don't exist like WFALL# and NFALL#.
	===============================================================*/
	Static Const String WaterTextures[] = {"FWATER1", "FWATER2", "FWATER3", "FWATER4", "WFALL1", "WFALL2", "WFALL3", "WFALL4"};
	Static Const String NukageTextures[] = {"NUKAGE1", "NUKAGE2", "NUKAGE3", "NFALL1", "NFALL2", "NFALL3", "NFALL4"};
	Static Const String BloodTextures[] = {"BLOOD1", "BLOOD2", "BLOOD3", "BFALL1", "BFALL2", "BFALL3", "BFALL4"};
	Static Const String LavaTextures[] = {"LAVA1","LAVA2", "LAVA3", "LAVA4", "DBRAIN1", "DBRAIN2", "DBRAIN3", "DBRAIN4", "LFALL1", "LFALL2", "LFALL3", "LFALL4"};
	Static Const String SlimeTextures[] = {"SLIME01","SLIME02", "SLIME03", "SLIME04", "SLIME05","SLIME06", "SLIME07", "SLIME08", "SFALL1", "SFALL2", "SFALL3", "SFALL4"};

}

//Boy, these functions are so basic, my next project should have more generic functions like these, that aren't reliant on any specific actor.
Mixin Class GrenadeFunctions
{
	//Checks if the calling actor is within a swimmable or non-solid 3D floor. Written by Boondorl.
	F3DFloor SM_GetSwimmable3DFloor()
	{
		if (waterLevel <= 0)
			return null;

		for (int i = 0; i < curSector.Get3DFloorCount(); i++)
		{
			F3DFloor ff = curSector.Get3DFloor(i);
			if (!(ff.flags & F3DFloor.FF_EXISTS) || (ff.flags & F3DFloor.FF_SOLID) || !(ff.flags & F3DFloor.FF_SWIMMABLE))
				continue;

			if (pos.z+height > ff.bottom.ZAtPoint(pos.xy) && pos.z < ff.top.ZAtPoint(pos.xy))
				return ff;
		}

		return null;
	}
	
	//This function doesn't really work with swimmable 3D floors, and since I've had no luck getting a raycast to detect swimmable floors using a Line Tracer class, this will have to do.
	F3DFloor SM_Find3DFloorBelow (Double CheckDistance = 32)
	{
		FLineTraceData ThreeDFloorCheck;
		LineTrace (0,CheckDistance,90,TRF_THRUACTORS,data:ThreeDFloorCheck);
		
		Return ThreeDFloorCheck.Hit3DFloor;
	}
	
	Int SM_GrenadeExplodedOnLiquid()
	{
		F3DFloor RORSector;
		F3DFloor RORSectorBelow;
		TextureID FloorTexture;
		TextureID FloorTextureBelow;
		
		Let LiquidList = SM_LiquidTextureNameList(EventHandler.Find("SM_LiquidTextureNameList"));
		
		RORSector = SM_GetSwimmable3DFloor();
		
		If (RORSector)
			FloorTexture = RORSector.GetTexture(0);
		
		RORSectorBelow = SM_Find3DFloorBelow();
				
		If (RORSectorBelow)
			FloorTextureBelow = RORSectorBelow.GetTexture(0);
		
		//Look through the list of water textures.
		For (Int I = 0; I < LiquidList.WaterTextures.Size(); I++)
		{
			//Are you inside or above a swimmable 3D floor with a water texture ?
			If (TexMan.CheckForTexture(LiquidList.WaterTextures[I]) == FloorTexture || TexMan.CheckForTexture(LiquidList.WaterTextures[I]) == FloorTextureBelow ||
			//If not, then check if the floor texture of the sector the grenade is in matches. And that you are close enough to the floor.
			TexMan.CheckForTexture(LiquidList.WaterTextures[I]) == FloorPic && (Pos.Z - FloorZ) <= 32)
				Return SM_HitWater;
		}
		
		//The rest is basically the same, except that it checks for different lists of textures.
		For (Int I = 0; I < LiquidList.NukageTextures.Size(); I++)
		{
			//Are you inside or above a swimmable 3D floor with a water texture ?
			If (TexMan.CheckForTexture(LiquidList.NukageTextures[I]) == FloorTexture || TexMan.CheckForTexture(LiquidList.NukageTextures[I]) == FloorTextureBelow ||
			//If not, then check if the floor texture of the sector the grenade is in matches. And that you are close enough to the floor.
			TexMan.CheckForTexture(LiquidList.NukageTextures[I]) == FloorPic && (Pos.Z - FloorZ) <= 32)
				Return SM_HitNukage;
		}
		
		For (Int I = 0; I < LiquidList.BloodTextures.Size(); I++)
		{
			//Are you inside or above a swimmable 3D floor with a water texture ?
			If (TexMan.CheckForTexture(LiquidList.BloodTextures[I]) == FloorTexture || TexMan.CheckForTexture(LiquidList.BloodTextures[I]) == FloorTextureBelow ||
			//If not, then check if the floor texture of the sector the grenade is in matches. And that you are close enough to the floor.
			TexMan.CheckForTexture(LiquidList.BloodTextures[I]) == FloorPic && (Pos.Z - FloorZ) <= 32)
				Return SM_HitBlood;
		}
		
		For (Int I = 0; I < LiquidList.LavaTextures.Size(); I++)
		{
			//Are you inside or above a swimmable 3D floor with a water texture ?
			If (TexMan.CheckForTexture(LiquidList.LavaTextures[I]) == FloorTexture || TexMan.CheckForTexture(LiquidList.LavaTextures[I]) == FloorTextureBelow ||
			//If not, then check if the floor texture of the sector the grenade is in matches. And that you are close enough to the floor.
			TexMan.CheckForTexture(LiquidList.LavaTextures[I]) == FloorPic && (Pos.Z - FloorZ) <= 32)
				Return SM_HitLava;
		}
		
		For (Int I = 0; I < LiquidList.SlimeTextures.Size(); I++)
		{
			//Are you inside or above a swimmable 3D floor with a water texture ?
			If (TexMan.CheckForTexture(LiquidList.SlimeTextures[I]) == FloorTexture || TexMan.CheckForTexture(LiquidList.SlimeTextures[I]) == FloorTextureBelow ||
			//If not, then check if the floor texture of the sector the grenade is in matches. And that you are close enough to the floor.
			TexMan.CheckForTexture(LiquidList.SlimeTextures[I]) == FloorPic && (Pos.Z - FloorZ) <= 32)
				Return SM_HitSlime;
		}
		
		Return SM_HitNoLiquid;
	}
}

Mixin Class MarineFunctions
{
	//Shorthand for checking what state the marine is in.
	Bool SM_IsInState (StateLabel CheckFor = "Spawn")
	{
		Return (InStateSequence(CurState,ResolveState (CheckFor)));
	}
	
	//Returns true if the specified actor doesn't have any flags that should make it unable to be targeted.
	Bool SM_CanBeTargeted (Actor Other)
	{
		If (!Other) Return False;
		Return (!Other.bNoTarget && !Other.bNeverTarget && !(Other.Player && Other.Player.Cheats & CF_NOTARGET));
	}
	
	//Returns true if the marine is busy with something, mostly to prevent those stupid delicate state sequences from breaking by an abrupt state change.
	Bool SM_IsBusy()
	{
		Return (GoingToTurret || OnTurret || RunningToReload || Evading || Crouching || SM_IsInState ("RunAway"));
	}
	
	Bool GrenadeAttackDecision (Double BlastRadius = 192, Double ThrowDistance = 1024, Double DangerDistance = 224)
	{
		Name VehicleBase = "MVP_BaseVehicle";
		Int ThrowChance;
		Actor Mobj;
		
		If (User_GrenadeThreshold == 256 || GrenadeDelay > 0) Return False; //Disable grenade throwing. Or don't throw a grenade if the delay isn't over yet.
		
		If (Target)
		{	
			If (Distance3DSquared (Target) <= DangerDistance*DangerDistance || Distance3DSquared(Target) > ThrowDistance*ThrowDistance) Return False; //If the target is close enough for you to get caught in the blast, or if the target is too far, don't throw.
			
			If (User_GrenadeThreshold == -1) Return True; //Always throw grenades.
			
			ThrowChance = Random (0,256);
			BlockThingsIterator FindTargets = BlockThingsIterator.Create (Target,BlastRadius);
			
			If (Crouching) ThrowChance += 20; //Marines behind cover are a bit more likely to throw grenades.
			If (Target.Health >= 10000) ThrowChance += 230;
			Else If (Target.Health >= 4000) ThrowChance += 80;
			Else If (Target.Player) ThrowChance += 20;
			Else If ((Target.Player && Target.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" || Target Is "SmartMarine" && SmartMarine(Target).OnTurret)) ThrowChance += 50;
			Else If (Target Is VehicleBase) ThrowChance += 50; //More likely to attack vehicles.
			
			While (FindTargets.Next())
			{
				Mobj = FindTargets.Thing;
				
				//If the found actor is a monster or player, is not your current target, is at or closer than the specified blast radius, has health over 10, and is hostile and visible to you.
				If ((Mobj.bIsMonster || Mobj Is "PlayerPawn") && Mobj != Target && Mobj.Distance3DSquared (Target) <= BlastRadius*BlastRadius && Mobj.Health >= 10 && IsHostile (Mobj) && IsVisible (Mobj,False))
				{
					ThrowChance += 5; //Increment the chance variable.
					
					//Additionally increment it by a different amounts based on how much health the found actor has.
					Switch (Mobj.Health)
					{
						Case 10000:
							ThrowChance += 300; //If an actor with this much health is near the target, then DEFINITELY throw a grenade.
							Break;
						Case 4000:
							ThrowChance += 80;
							Break;
						Case 2500:
							ThrowChance += 50;
							Break;
						Case 1000:
							ThrowChance += 35;
							Break;
						Case 500:
							ThrowChance += 25;
							Break;
						Case 150:
							ThrowChance += 10;
							Break;
						Case 50:
							ThrowChance += 5;
							Break;
						Default:
							Break;
					}
					//More likely to throw grenades if an enemy that would be caught in the blast is a marine or player on a turret.
					If (Mobj && (Mobj.Player && Mobj.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" || Mobj Is "SmartMarine" && SmartMarine(Mobj).OnTurret)) ThrowChance += 50;
					//also more likely to throw one if an enemy vehicle is in the blast radius.
					Else If (Mobj Is VehicleBase) ThrowChance += 60;
				}
				Else If (Mobj.bIsMonster && !IsHostile(Mobj) && IsVisible (Mobj,False) && Mobj != Self) //If the actor that was found is friendly to you, and ISN'T you.
					ThrowChance -= 15; //Then decrease the chance of throwing a grenade.
				Else If (Mobj.Player && !IsHostile (Mobj)) //If the actor found is a player friendly to you.
					ThrowChance -= 70; //Then be A LOT less likely to throw a grenade.
			}
						
			If (ThrowChance >= User_GrenadeThreshold)
				Return True;
		}
		
		Return False;
	}
	
	//Informs other marines to wait before throwing their own grenades, to not spam them while in groups.
	Void AnnounceGrenadeThrow()
	{
		Actor Mobj;
		BlockThingsIterator FindOtherMarines = BlockThingsIterator.Create (Self,256);
		
		While (FindOtherMarines.Next())
		{
			Mobj = FindOtherMarines.Thing;
			If (Mobj != Self && Mobj Is "SmartMarine" && Mobj.Health > 0 && !IsHostile (Mobj) && IsVisible (Mobj,True) && Distance3DSquared (Mobj) <= 256*256)
				SmartMarine(Mobj).GrenadeDelay = Random (35/2,40);
		}
	}
	
	//This function was written by Lewisk3.
	void FireGrenade(Actor toAct, class<Actor> nade, double maxPitch = 90, double aimSens = 1.0, double aimDist = 128)
	{
		if(!toAct) return;
		
		// Source and Destination
		vector3 fromPos = (
			pos.xy,
			pos.z + (height)
		);
		vector3 toPos = (
			toAct.pos.xy, 
			toAct.pos.z + (toAct.height * 0.5) 
		);
		
		vector3 diff = level.vec3diff(fromPos, toPos);
		
		// Spawn grenade, calculate values from instance.
		let nade = Spawn(nade, fromPos);
		if(!nade) return;    
		nade.target = self;
		
		// Modify toPos Z component based on how many units the thrown grenade
		// fall by the time it reaches the destination.
		double dist = diff.xy.Length();
		if(dist >= aimDist)
		{
			double grav = 1.0 + ceil(nade.GetGravity() * (level.gravity * 0.010769));
			double ticsDist = diff.Length() / double(max(nade.Speed,1.0));        
			double fallDist = ticsDist * grav;
			toPos.z += fallDist * aimSens;
		}
		
		// Recalculate differences.
		diff = level.vec3diff(fromPos, toPos);
		double aimPitch = VectorAngle( sqrt(diff.y*diff.y + diff.x*diff.x), diff.z );
		aimPitch = min(aimPitch, maxPitch);
		
		// Modify grenade velocity
		double a = AngleTo(toAct);
		double p = -aimPitch;
		nade.vel = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * nade.Speed;
	}
	
	//A_CustomBulletAttack() does this this really awesome thing where you cannot actually fucking offset the spawning position of the hitscan itself.
	//So I have to manually fire a custom hitscan, one that is far more likely than not broken, and doesn't behave like normal hitscans.
	//All so I can change the spawn height and horizontal offsets of the hitscans they fire.
	Void SM_MarineBulletAttack (Double SpawnHeight = 42)
	{
		Double XY_Spread;
		Double SlopeBullshit = 0.;
		Bool LiquidHit;
		
		A_StartSound(AttackSound, CHAN_WEAPON);
		
		SlopeBullshit = /*AimLineAttack (Angle,8192)*/ Pitch + BulletSpreadZ;
		
		XY_Spread = Angle + BulletSpreadXY;
		
		Actor Puff = LineAttack (XY_Spread,8192,SlopeBullshit,Random (6,10),"HitScan","SmartMarinePuff",LAF_OVERRIDEZ,offsetz:SpawnHeight,0,-6);
		
		//Bullet impact splash handling.
		//The splashes only work with solid surfaces because I tried getting them to work with swimmable 3D floors for 2 days straight to no avail.
		//Also, the rifle the marines drop doesn't produce splashes because calling this exact same code from the player produces pitch differences
		//between where the line trace is fired, and where the actual hitscan attack is fired because reasons I guess.
		FLineTraceData LiquidCheck;
		Actor Splash;
		Let LiquidList = SM_LiquidTextureNameList(EventHandler.Find("SM_LiquidTextureNameList"));	
		LineTrace (XY_Spread,8192,SlopeBullshit,0,SpawnHeight,0,-6,LiquidCheck);
		
		//Check the list of water textures.
		For (Int I = 0; I < LiquidList.WaterTextures.Size(); I++)
		{
			//Did we hit a solid sector or 3D floor, if yes, does its' texture match any of the ones on the list ?
			If (LiquidCheck.HitTexture == TexMan.CheckForTexture(LiquidList.WaterTextures[I]))
			{
				Splash = Spawn ("SM_BulletSplash",LiquidCheck.HitLocation);
				LiquidHit = True;
				Break;
			}
		}
		
		//Check the list of nukage textures.
		For (Int I = 0; I < LiquidList.NukageTextures.Size(); I++)
		{
			//Did we hit a solid sector or 3D floor, if yes, does its' texture match any of the ones on the list ?
			If (LiquidCheck.HitTexture == TexMan.CheckForTexture(LiquidList.NukageTextures[I]))
			{
				Splash = Spawn ("SM_BulletSplash",LiquidCheck.HitLocation);
				Splash.A_SetTranslation("SM_Splash_Nukage");
				LiquidHit = True;
				Break;
			}
		}
		
		//Check the list of blood textures.
		For (Int I = 0; I < LiquidList.BloodTextures.Size(); I++)
		{
			//Did we hit a solid sector or 3D floor, if yes, does its' texture match any of the ones on the list ?
			If (LiquidCheck.HitTexture == TexMan.CheckForTexture(LiquidList.BloodTextures[I]))
			{
				Splash = Spawn ("SM_BulletSplash",LiquidCheck.HitLocation);
				Splash.A_SetTranslation("SM_Splash_Blood");
				LiquidHit = True;
				Break;
			}
		}
		
		//Check the list of slime textures.
		For (Int I = 0; I < LiquidList.SlimeTextures.Size(); I++)
		{
			//Did we hit a solid sector or 3D floor, if yes, does its' texture match any of the ones on the list ?
			If (LiquidCheck.HitTexture == TexMan.CheckForTexture(LiquidList.SlimeTextures[I]))
			{
				Splash = Spawn ("SM_BulletSplash",LiquidCheck.HitLocation);
				Splash.A_SetTranslation("SM_Splash_Slime");
				LiquidHit = True;
				Break;
			}
		}
		
		//Check the list of lava textures.
		For (Int I = 0; I < LiquidList.LavaTextures.Size(); I++)
		{
			//Did we hit a solid sector or 3D floor, if yes, does its' texture match any of the ones on the list ?
			If (LiquidCheck.HitTexture == TexMan.CheckForTexture(LiquidList.LavaTextures[I]))
			{
				Splash = Spawn ("SM_BulletSplash",LiquidCheck.HitLocation);
				Splash.A_SetTranslation("SM_Splash_Lava");
				LiquidHit = True;
				Break;
			}
		}
		
		If (Puff)
		{
			//Don't play both the splash sound and impact at once, it wouldn't make sense, plus it's kinda annoying to hear both sounds at once.
			If (!LiquidHit)
				Puff.A_StartSound ("VRifle/Impact");
			Else
			{
				Puff.bAllowParticles = False;
				Puff.Alpha = 0; //Only show the liquid splash.
			}
		}
	}
	
	//Determines if the marine should be scared of its' current target.
	Void SM_ShouldBeScared()
	{
		If (User_FearDistance <= 0 || !Target) Return;
		
		//The marine must not have the frightened flag on when going to a turret, to not also avoid the turret they are going to.
		If (GoingToTurret)
		{
			bFrightened = False;
			Return;
		}
		
		//If the target is nearby, visible, and hostile, and has over 2500 health.
		If (IsHostile (Target) && Distance3DSquared (Target) <= ((User_FearDistance*FRandom (1.01,1.25))*(User_FearDistance*FRandom (1.01,1.25))) && Target.SpawnHealth() >= 2000 && IsVisible (Target,True)
		
		//Or if it is big enough and visible and close enough.
		|| (Target.Height >= 80 && Target.Radius >= 72) && Distance3DSquared (Target) <= ((User_FearDistance*FRandom (1.01,1.25))*(User_FearDistance*FRandom (1.01,1.25))) && IsVisible (Target,True)
		
		//Or it has any of these flags, along with being nearby and visible to you.
		|| (Target.bReflective && Target.bAimReflect || Target.bInvulnerable) && Distance3DSquared (Target) <= ((User_FearDistance*FRandom (1.01,1.25))*(User_FearDistance*FRandom (1.01,1.25))) && IsVisible (Target,True)
		
		//Or if is completely indestructible or noclipping at all, regardless of sight or distance.
		|| (Target.bNoDamage || Target.bNoclip))
		{
			SM_TurretUseDecision(); //Look for any turrets nearby.
			bFrightened = True; //Then be scared.
			MinMissileChance = 50; //Double the chance of attacking, to make up for all the running away.
		}
		//If your target is hostile, and is a player or marine that's on a turret. And they are in range and visible.
		/*This Else If is here so marines scared of an enemy on a turret, won't be any more likely to get on one themselves.
		Since protecting yourself from machine gun fire by getting to a stationary turret yourself is stupid, and MORE likely to get you killed.*/
		Else If ((Target.Player && Target.Player.ReadyWeapon && Target.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" && Distance3DSquared (Target) <= ((User_FearDistance*FRandom (1.01,1.25))*(User_FearDistance*FRandom (1.01,1.25))) && IsVisible (Target,True)||
		Target Is "SmartMarine" && SmartMarine(Target).OnTurret && Distance3DSquared (Target) <= ((User_FearDistance*FRandom (1.01,1.25))*(User_FearDistance*FRandom (1.01,1.25))) && IsVisible (Target,True)||
		Target Is "TurretMarine" && Distance3DSquared (Target) <= ((User_FearDistance*FRandom (1.01,1.25))*(User_FearDistance*FRandom (1.01,1.25))) && IsVisible (Target,True)))
		{
			bFrightened = True; 
			MinMissileChance = 50;
		}
		Else //If they don't meet any of those criteria, then stop being scared.
		{
			bFrightened = False;
			MinMissileChance = Default.MinMissileChance; //Go back to the normal firing chance.
		}
	}
	
	//Checks what directions the marine will be able to jump to, to avoid any incoming projectiles.
	//This (mostly) prevents marines from jumping into walls or off very tall ledges.
	Bool SM_ShouldDodgeProjectile (Double Distance = 384)
	{
		If (User_DodgeRange == -1 || bDormant) Return False;
		
		Bool LeftSafe;
		Bool RightSafe;
		Double OldAngle;
		
		If (SM_FindNearbyProjectile (Distance))
		{
			OldAngle = Angle; //Store the current angle before facing the projectile to dodge it.
			
			MaxDropOffHeight = 128; //Temporarily increase the maximum height the marine can drop from.
			
			A_Face (NearbyProjectile,flags:FAF_MIDDLE);
			//Check if it's safe to strafe 56 map units to the left or right, or both. Or none even, like in the case of crammed corridors.
			LeftSafe = CheckMove (Vec2Angle (56,Angle+90),PCM_DROPOFF);
			RightSafe = CheckMove (Vec2Angle (56,Angle-90),PCM_DROPOFF);
							
			If ((LeftSafe && RightSafe)) //Both directions are safe to strafe to.
				StrafeDirection = STRAFE_RANDOM;
			Else If ((!LeftSafe && !RightSafe)) //The area is too crammed to strafe anywhere here.
			{
				Angle = OldAngle; //Revert the marines' angle if you can't dodge.
				StrafeDirection = STRAFE_NONE; //Reset the strafe direction to none.
				MaxDropOffHeight = Default.MaxDropOffHeight; //Revert the property to the default again.
				Return False; //Don't break whatever state sequence the marine is currently in to tell him he can't dodge.
			}
			Else If (LeftSafe && !RightSafe) //Can only strafe left.
				StrafeDirection = STRAFE_LEFT;
			Else If (!LeftSafe && RightSafe) //Can only strafe right.
				StrafeDirection = STRAFE_RIGHT;
			
			MaxDropOffHeight = Default.MaxDropOffHeight; //Revert the property to the default again.
			Return True; //Found a direction to strafe at to dodge.
		}
		
		Return False; //Didn't even find a projectile to dodge.
	}
	
	//Checks if an enemy projectile, or one that should always be avoided, or a really harmful one, is approaching the marines' direction.
	//The IgnoredProjectiles and AlwaysAvoid arrays can be used to list what projectiles the marines should always avoid or ignore.
	Bool SM_FindNearbyProjectile (Double Range = 384)
	{
		Bool EpicFail; //Makes the function immediately stop running if the projectile is on the ignore list.
		Bool SkipAllyCheck;
		
		Static Const Name IgnoredProjectiles[] = //A list of enemy projectiles that they don't try avoiding.
		{
			"SM_Grenade" //Grenades have special handling.
		};
		
		Static Const Name AlwaysAvoid[] = //A list of projectiles to always avoid, even if fired by a friend.
		{
			"Rocket",
			"BFGBall"
			//"SM_Missile" //Future feature.
		};
		
		Let ProjectileHandler = SM_ProjectileHandler(EventHandler.Find("SM_ProjectileHandler"));
		
		If (ProjectileHandler)
		{
			For (Int I; I < ProjectileHandler.ProjectileList.Size(); I++)
			{
				Actor Projectile = ProjectileHandler.ProjectileList[I];
				
				//Null check.
				If (!Projectile) Continue;
				
				//Out of range.
				If (Distance3DSquared(Projectile) > Range*Range) Continue;
				
				//Don't keep dodging the same projectile.
				If (Projectile == PreviousProjectile) Continue;
				
				//Don't return true if it's part of the blacklist.
				For (Int I; I < IgnoredProjectiles.Size(); I++)
				{
					If (Projectile.GetClassName() == IgnoredProjectiles[I]) {EpicFail = True; Continue;}
				}
				
				If (EpicFail) Continue;
				
				//Hostile marines and any marines currently in cover will dodge all projectiles, except for ones on the Ignored Projectiles list.
				If (!bFriendly || Crouching) SkipAllyCheck = True;
				
				//If the projectile heading towards you will do way too much damage, then avoid it even if it was shot by a friend. This has to account for Doom's absurd damage variation.
				If (Projectile.bStrifeDamage && Projectile.Damage >= Health/3 || Projectile.Damage >= Health/6) {SkipAllyCheck = True;}
				
				For (Int I; I < AlwaysAvoid.Size(); I++)
				{
					If (Projectile.GetClassName() == AlwaysAvoid[I]) {SkipAllyCheck = True; Continue;}
				}
				
				If (!SkipAllyCheck && Projectile.Target && !IsHostile(Projectile.Target)) Continue;
				
				//Don't return true if the projectile isn't visible at all, or is too far away from the marines' peripheral vision. Or if it isn't so close that it's impossible not to notice it.
				If (!(IsVisible (Projectile,True) &&
				(AbsAngle (Angle,AngleTo(Projectile)) < 120.0 || !(Distance3DSquared(Projectile) > Range*Range/6))))
				Continue;
				
				//Is the projectile about to hit me ? Weird math nonsense written by RaveYard.
				bool projectile_is_flying_towards_me = (Vec3To(projectile).Unit() dot projectile.vel.Unit()) < -0.15;
				double projectileSafeRadius = sqrt(2 * ((projectile.radius + radius) ** 2.2));
				if(projectile_is_flying_towards_me && distance3dline(pos, projectile.pos, projectile.pos + projectile.vel) < projectileSafeRadius)
				{
					NearbyProjectile = Projectile;
					Return True;
				}
			}
		}
		Return False;
	}
	
	static double Distance3dLine(Vector3 a, Vector3 b, Vector3 c)
	{
		return (((A - B) cross (C - B))).length() / (C - B).length();
	}
	
	//Alerts nearby marines friendly to the calling one of the callers' target.
	Void SM_AlertNearbyMarines (Double Range = 256, Bool SkipCheck = False)
	{
		If (User_AlertRange == -1) Return;
		
		If ((Target && Goal && Target == Goal) && !GoingToTurret) Return; //Don't fuck things up by making other marines try and attack a patrol point. Or stoping them from going to a turret.
		
		Actor PotentialMarine;
		Bool FoundMarines;
		
		If (SkipCheck || !LastEnemy && Target) //If you had no prior enemy, like after giving up on your current target. Or if SkipCheck is true.
		{
			BlockThingsIterator AlertNearbyMarines = BlockThingsIterator.Create (Self,Range);
			
			While (AlertNearbyMarines.Next())
			{
				PotentialMarine = AlertNearbyMarines.Thing;
				
				If (PotentialMarine != Self && !PotentialMarine.bDormant && PotentialMarine.GetClassName() == "SmartMarine" && Distance3DSquared (PotentialMarine) <= Range*Range && PotentialMarine.Health > 0 && !IsHostile (PotentialMarine)) //If the actor is not dormant, a marine, in range, is not hostile to you, and has no target already.
				{
					//If the marine isn't running away from a grenade and has no target currently.
					If (!SmartMarine(PotentialMarine).SM_IsInState ("RunAway") && !PotentialMarine.Target)
					{
						PotentialMarine.LastHeard = PotentialMarine.Target = Target; //Have the marine share your target.
						FoundMarines = True; //A marine has been found.
						If (!SmartMarine(PotentialMarine).SM_IsInState ("See") && !SmartMarine(PotentialMarine).SM_IsBusy()) //Put the marine in his see state to begin chasing the target, if he isn't only it already and isn't busy.
						{
							PotentialMarine.SetStateLabel ("See"); //Then send them to it.
						}
					}
					//If he IS running away from a grenade. But has no target that he was attacking before running away from the grenade.
					Else If (SmartMarine(PotentialMarine).SM_IsInState ("RunAway") && !SmartMarine(PotentialMarine).OriginalTarget)
					{
						SmartMarine(PotentialMarine).OriginalTarget = PotentialMarine.LastHeard = Target; //Have the marine share your target.
						FoundMarines = True; //A marine has been found.
					}
				}
			}
			
			If (FoundMarines) //If at least one marine was found to alert.
			{
				If (Random (0,256) == Random (0,256))
					A_StartSound ("Marine/AlertAlliesAlt",CHAN_VOICE,attenuation:0.75);
				Else
					A_StartSound ("Marine/AlertAllies",CHAN_VOICE,attenuation:0.75);
			}
		}
	}
	
	//Searches for grenades that are about to explode near the marine.
	Bool SM_FindNearbyGrenade (Double SearchRadius = 256)
	{
		Inventory Token;
		If (bDormant) Return False;
		
		Token = FindInventory ("SM_ImInDanger");
		
		If (Token && Token.Master)
		{
			OriginalTarget = Target; //Keep the original target of the marine stored.
			Target = Token.Master; //Then change the target to the actor that droped the token.
			TakeInventory ("SM_ImInDanger",1); //Remove the token now, if the marine still needs to run, the warning source should give another token for the next function call.
			Return True; //And return true.
		}
		//The token is in the inventory, but has no master e.g it was given by a danger source, but the source was removed while the marine was already running away.
		Else If (Token && !Token.Master)
			TakeInventory ("SM_ImInDanger",1); //Just remove the token.
		
		Actor Mobj;
		BlockThingsIterator GrenadeSearch = BlockThingsIterator.Create (Self,SearchRadius);
		
		While (GrenadeSearch.Next())
		{
			Mobj = GrenadeSearch.Thing;
			//If the found actor is a grenade, that hasn't exploded already, but that will explode in about a second. And you are in the blast radius, and it's visible.
			If (Mobj.GetClassName() == "SM_Grenade" && !(SM_Grenade(Mobj).Exploded) && Mobj.ReactionTime <= 40 && Distance3DSquared (Mobj) <= SearchRadius*SearchRadius && IsVisible (Mobj,True))
			{
				OriginalTarget = Target; //Keep the original target of the marine stored.
				Target = Mobj; //Then change the target to the grenade that was found.
				Return True; //And return true.
			}
		}
		Return False; //No grenades were found near the marine.
	}
	
	//Returns if the marine can or cannot crouch.
	Bool SM_CanCrouch ()
	{
		FLineTraceData EyeLevel;
		FLineTraceData HipLevel;
		Bool EyeLevelUnblocked;
		Bool HipLevelBlocked;
		Int HasHit;
		Actor Mobj;
		
		If (User_NoCover || CrouchDelay)
			Return False;
		
		//Don't crouch if you have no target, or your target is your goal too. AKA you are patrolling.
		If (!Target || Target && (Target && Goal && Target == Goal))
			Return False;
		
		//If your target is this close to you, you probably can't crouch.
		If (Distance3DSquared(Target) <= 72*72)
			Return False;
		
		/*
		This fires two raycasts from the marines' eyes and hips. Then the Eye and HipLevelBlocked booleans return true or false.
		Based on whether or not they hit any level geometry before stopping. The distance that the raycasts travel double when
		the marine is already crouched, so they don't get out of cover even when their target hasn't breached said cover.
		*/
		
		If (!Crouching)
			LineTrace (AngleTo (Target),48,0,0,50,data:EyeLevel);
		Else
			LineTrace (AngleTo (Target),128,0,0,50,data:EyeLevel);
		
		EyeLevelUnblocked = SM_EyeLevelBlocked (EyeLevel);

		If (!Crouching)
			LineTrace (AngleTo (Target),48,0,TRF_THRUHITSCAN,18,data:HipLevel);
		Else //Run a longer range trace when crouched to not go out of cover as easily when behind strangely shaped cover like star shaped fountains.
			LineTrace (AngleTo (Target),128,0,TRF_THRUHITSCAN,18,data:HipLevel);
		
		HasHit = HipLevel.HitType;
		Mobj = HipLevel.HitActor;
		//Only take cover behind large enough actors that aren't other NPCs or players. And aren't about to break.
		If ((HasHit == TRACE_HitWall || HasHit == TRACE_HitFloor || HasHit == Trace_HitCeiling) ||
		(Mobj && !(Mobj.bIsMonster || Mobj.Player) && Mobj.Radius >= Radius && Mobj.Height < 40 && Mobj.Health >= 40))
			HipLevelBlocked = True;
		
		//Only run this if the marine is not crouched already, and also has a target, that isn't a patrol point.
		If (!Crouching)
		{
			If (EyelevelUnblocked && HipLevelBlocked && CheckSight (Target,SF_SEEPASTSHOOTABLELINES|SF_IGNOREWATERBOUNDARY))
				Return True;
		}
		
		//If you are crouching already and have a line of sight to your target.
		If (Crouching && CheckSight (Target,SF_SEEPASTSHOOTABLELINES|SF_IGNOREWATERBOUNDARY))
		{
			//Then return if you can crouch based on whether or not your hips are blocked by cover still.
			Return HipLevelBlocked;
		}
		
		//If none of the other checks are true, but you are crouching already, then just assume you can keep doing so.
		If (Crouching)
			Return True;
		
		Return False;
	}
	
    Bool SM_EyeLevelBlocked (FLineTraceData Data)
    {
        Int HasHit;
        
        HasHit = Data.HitType;
		
        If (Data.HitActor)
            Return False;
        
        If (HasHit == TRACE_HitWall)
            Return False;
        
        If (HasHit == TRACE_HitFloor)
            Return False;
		
		If (HasHit == Trace_HitCeiling)
			Return False;
        
        Return True;
    }
	
	//Makes the marine listen for any enemy marines playing the radio transmission sound, which is played when marines alert each other.
	Void SM_ListenForEnemyAlerts (Double HearingRadius = 1024)
	{
		If (User_EnemyAlertHearingRange == -1) Return; //Don't run this if the feature is turned off.
		
		If (!Target)
		{
			Actor Mobj;
			BlockThingsIterator ListenForEnemyMarines = BlockThingsIterator.Create (Self,HearingRadius);
			
			While (ListenForEnemyMarines.Next())
			{
				Mobj = ListenForEnemyMarines.Thing;
				If (Mobj.GetClassName() == "SmartMarine" && IsHostile (Mobj) && Distance3DSquared (Mobj) <= HearingRadius*HearingRadius && Mobj.IsActorPlayingSound (CHAN_VOICE,"Marine/AlertAllies") && Mobj.Health > 0)
				{
					Target = Mobj; //Target the enemy marine that alerted the others.
					SetStateLabel ("AlertOtherMarines");
					Break;
				}
			}
		}
	}
	
	//Checks the line of fire between the marine and the target. And returns true if an ally, or an actor or line that could block the shot is in the line of fire.
	Bool SM_CantHitTarget (Bool ProjectileAttack = False)
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		A_FaceTarget(0,0,flags:FAF_MIDDLE);
		
		//Not lying down, fire the raycast at normal eye height.
		If (!LieDown)
			LineTrace (Angle+BulletSpreadXY,8192+2,Pitch+BulletSpreadZ,0,42,0,-6,LOFCheck);
		//Lying down, lower the raycast spawn height
		Else
			LineTrace (Angle+BulletSpreadXY,8192+2,Pitch+BulletSpreadZ,0,8,0,-6,LOFCheck);
		
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		If (Mobj) //Only run this if an actor was hit by the raycast.
		{
			//If the actor is a shootable non-monster, with a width over 10 map units. Or it's a dormant monster.
			If ((!(Mobj.bIsMonster) && !(Mobj.Player) && Mobj.bShootable && Mobj.Radius > 5) || Mobj.bIsMonster && Mobj.bDormant)
			{
				Return (ProjectileAttack || Random[pr_monsterrefire](0,255) < 88); //Then have a random chance to eventually stop shooting, similar to A_MonsterRefire().
			}
			//If the actor is a monster or player, and is not hostile to you.
			If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile (Mobj) &&
			//And it is not targeting a marine that's currently your friend (Which could be yourself as well).
			!(Mobj.Target && Mobj.Target Is "SmartMarine" && !IsHostile (Mobj.Target)) &&
			//And it is not your current target.
			!(Target == Mobj))
			{
				Return (bFriendly && !IsHostile(Mobj)) || (!bFriendly && !Mobj.bFriendly); //Then return that the actor should not be shot if it isn't hostile to you.
			}
		}
		
		//Avoid firing your gun or throwing grenades if a linedef is between you and the target, that would block the projectile or hitscan attack.
		If ((!ProjectileAttack && HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKHITSCAN)) || //Check for hitscan blocking lines.
		(ProjectileAttack && HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE))) //Ditto, but for projectiles, AKA in case the marine is trying to toss a grenade.
		{Return True;}
		
		
		Return False;
	}
		
	//Decides if the marine should use a nearby turret, if there's any.
	Bool SM_TurretUseDecision (Double TurretRadius = 512, Double EnemyRadius = 4096)
	{
		If (User_TurretThreshold == -1 || (Goal || GoingToTurret)) Return False;
		
		Actor FoundTurret;
		Actor Mobj;
		Int UseChance;
		Bool FoundAllies;
		Name VehicleBase = 'MVP_BaseVehicle';
		
		LookExParams MarineSight;
		MarineSight.FOV = 180;
		MarineSight.MinDist = 0;
		MarineSight.MaxDist = 8192;
		MarineSight.MaxHearDist = 3072;
		
		BlockThingsIterator FindTurrets = BlockThingsIterator.Create (Self,TurretRadius);
		
		While (FindTurrets.Next())
		{
			If (FindTurrets.Thing Is "SmartMarineMGTurret" && !(SmartMarineMGTurret(FindTurrets.Thing).Operator) && IsVisible (FindTurrets.Thing,True) && Distance3DSquared (FindTurrets.Thing) <= TurretRadius*TurretRadius)
			{
				FoundTurret = FindTurrets.Thing;
				//Break;
			}
		}
		
		If (!FoundTurret) Return False; //Don't try deciding to use a turret, if there is none around.
		
		UseChance = Random (0,50);
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,EnemyRadius);
		
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			//If you found a monster or player, that is alive, hostile, close enough to you, and visible.
			If ((Mobj.bIsMonster || Mobj Is "PlayerPawn") && Mobj.Health > 0 && IsHostile (Mobj) && Mobj.Distance3DSquared (Target) <= EnemyRadius*EnemyRadius && IsVisible (Mobj,False,params:MarineSight))
			{
				Switch (Mobj.Health)
				{
					Case 2500:
						UseChance += 100;
						Break;
					Case 1000:
						UseChance += 35;
						Break;
					Case 500:
						UseChance += 25;
						Break;
					Case 150:
						UseChance += 10;
						Break;
					Case 10:
						UseChance += 5;
						Break;
					Case 1:
						UseChance += 1;
						Break;
					Default:
						Break;
				}
				
				//Players always trigger a very high chance of the marine using a nearby turret, since they are as powerful as the strongest bosses.
				If (Mobj.Player)
					UseChance += (User_TurretThreshold - 2) + Random (0,2);
				//Additional use chance for other enemy marines that were found.
				Else If (Mobj Is "SmartMarine")
					UseChance += 10;
				//Even higher additional use chance for enemy vehicles.
				Else If (Mobj Is VehicleBase)
					UseChance += 30;
			}
			
			//Also increase the chance for every ally you found around you, that could support you while you are stationary and vulnerable.
			If (bFriendly)
			{
				If (Mobj.Health >= 10 && !IsHostile (Mobj) && Mobj.Distance3DSquared (Target) <= ((EnemyRadius/2)*(EnemyRadius/2)))
				{
					If ((Mobj.bIsMonster && Mobj != Self)) {UseChance += 30; FoundAllies = True;}
					Else If (Mobj.Player) {UseChance += 60; FoundAllies = True;}
				}
			}
			//Since hostile monsters don't attack friendly ones on sight by default, hostile marines can't rely on other fellow hostile monsters, unless they have the SEEFRIENDLYMONSTERS flag enabled.
			Else If (!bFriendly && (Target.Player || Target.bFriendly))
			{
				If (Mobj.bSeeFriendlyMonsters && !IsHostile (Mobj) && Mobj.Distance3DSquared (Target) <= ((EnemyRadius/2)*(EnemyRadius/2)))
					{UseChance += 30; FoundAllies = True;}
			}
		}
		
		If (Health <= Default.Health/3) UseChance += 40; //High chance to use the turret if you are already close to dying.
		If (!FoundAllies) UseChance -= 60; //More unwilling to use turrets if no allies are around.
		If (UseChance >= User_TurretThreshold && FoundTurret)
		{
			SM_AlertNearbyMarines (User_AlertRange*2,True);
			GoingToTurret = True;
			Goal = Spawn ("SM_TurretLocationMarker",FoundTurret.Pos);
			Goal.Master = FoundTurret; //Make the turret the goals' master. So the goal will stay on the same position as the turret, if the turret is moved.
			bChaseGoal = True;
			Return True;
		}
		
		Return False;
	}
	
	//Similar to SM_CantHitTarget, returns true if there is something in the way of the target that should make the marine not shoot.
	Bool SM_TurretLOFCheck()
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		LineTrace (Angle,8192+2,Pitch,TRF_SOLIDACTORS|TRF_THRUHITSCAN,42,0,-6,LOFCheck);
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		
		If (Mobj)
		{
			If ((Mobj.bIsMonster || Mobj.Player) && IsHostile(Mobj)) Return False; Else If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile(Mobj)) Return True;
			If ((Mobj.bShootable && Mobj.ResolveState ("Death")) || Mobj.bSolid && !(Mobj.bShootable)) Return False; 
			If (Mobj.Radius <= 5 && Mobj.bShootable) Return False;
			Return True;
		}
		
		If (HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE)) Return True;
		
		Return False;
	}
	
	Void LeaveTurret ()
	{
		If (Turret && OnTurret)
		{
			Turret.A_ChangeLinkFlags (False,False);
			SmartMarineMGTurret(Turret).Operator = Null;
			Warp(Turret,-Turret.Radius*2,flags:WARPF_NOCHECKPOSITION); //Warp the marine at about the same position he is visibly at while on the turret.
			Turret.Angle = Angle;
			Turret = Null;
			ReactionTime = Default.ReactionTime;
			OnTurret = False;
			bNoPain = False;
			bDontThrust = False;
		}
	}
}

//Can't inherit from SmartMarine, because all the user variables from that actor would also appear on the turret marine, despite not doing anything.
Mixin Class TurretMarineFunctions
{
	Bool STM_IsInState (StateLabel CheckFor = "Spawn")
	{
		If (InStateSequence(CurState,ResolveState (CheckFor))) {Return True;}
		Return False;
	}
	
	Bool STM_TurretLOFCheck()
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		LineTrace (Angle,8192+2,Pitch,TRF_SOLIDACTORS|TRF_THRUHITSCAN,42,0,-6,LOFCheck);
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		
		If (Mobj)
		{
			If ((Mobj.bIsMonster || Mobj.Player) && IsHostile(Mobj)) Return False; Else If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile(Mobj)) Return True;
			If ((Mobj.bShootable && Mobj.ResolveState ("Death")) || Mobj.bSolid && !(Mobj.bShootable)) Return False;
			If (Mobj.Radius <= 5 && Mobj.bShootable) Return False;
			Return True;
		}
		
		If (HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE)) Return True;
		
		Return False;
	}
	
	//Searches for grenades that are about to explode near the marine.
	Bool STM_FindNearbyGrenade (Double SearchRadius = 256)
	{
		If (bDormant || !User_RunFromGrenades) Return False;
		Actor Mobj;
		BlockThingsIterator GrenadeSearch = BlockThingsIterator.Create (Self,SearchRadius);
		
		While (GrenadeSearch.Next())
		{
			Mobj = GrenadeSearch.Thing;
			If (Mobj.GetClassName() == "SM_Grenade" && !(SM_Grenade(Mobj).Exploded) && Mobj.ReactionTime <= 40 && Distance3DSquared (Mobj) <= SearchRadius*SearchRadius && IsVisible (Mobj,True))
			{
				Return True; //And return true.
			}
		}
		Return False; //No grenades were found near the marine.
	}
}