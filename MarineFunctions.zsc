Class SM_ProjectileHandler : EventHandler
{
	//Much faster alternative to just using a ThinkerIterator.
	Array <Actor> ProjectileList;
	
	Override Void WorldThingSpawned(WorldEvent E)
	{
		//Add every spawned projectile to a big list.
		If (E.Thing && E.Thing.bMissile)
		{
			ProjectileList.Push(E.Thing);
		}
	}
	
	Override Void WorldThingDied (WorldEvent E)
	{
		//Delete any destroyed projectiles from the list.
		If (E.Thing)
		{
			ProjectileList.Delete(ProjectileList.Find(E.Thing));
		}
	}
	
	Override Void WorldThingDestroyed (WorldEvent E)
	{
		//Delete any removed projectiles from the list.
		If (E.Thing)
		{
			ProjectileList.Delete(ProjectileList.Find(E.Thing));
		}
	}
}

Mixin Class MarineFunctions
{
	//Shorthand for checking what state the marine is in.
	Bool SM_IsInState (StateLabel CheckFor = "Spawn")
	{
		If (InStateSequence(CurState,ResolveState (CheckFor))) {Return True;}
		Return False;
	}
	
	Bool GrenadeAttackDecision (Double BlastRadius = 192, Double ThrowDistance = 1024, Double DangerDistance = 224)
	{
		Int ThrowChance;
		Actor Mobj;
		
		If (User_GrenadeThreshold == 256 || GrenadeDelay > 0) Return False; //Disable grenade throwing. Or don't throw a grenade if the delay isn't over yet.
		
		If (Target)
		{	
			If (Distance3D (Target) <= DangerDistance || Distance3D(Target) > ThrowDistance) Return False; //If the target is close enough for you to get caught in the blast, or if the target is too far, don't throw.
			
			If (User_GrenadeThreshold == -1) Return True; //Always throw grenades.
			
			ThrowChance = Random (0,256);
			BlockThingsIterator FindTargets = BlockThingsIterator.Create (Target,BlastRadius);
			
			If (Target.Health >= 10000) ThrowChance += 230;
			Else If (Target.Health >= 4000) ThrowChance += 80;
			Else If (Target.Player) ThrowChance += 20;
			Else If ((Target.Player && Target.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" || Target Is "SmartMarine" && SmartMarine(Target).OnTurret)) ThrowChance += 50;
			
			While (FindTargets.Next())
			{
				Mobj = FindTargets.Thing;
				
				//If the found actor is a monster or player, is not your current target, is at or closer than the specified blast radius, has health over 10, and is hostile and visible to you.
				If ((Mobj.bIsMonster || Mobj Is "PlayerPawn") && Mobj != Target && Mobj.Distance3D (Target) <= BlastRadius && Mobj.Health >= 10 && IsHostile (Mobj) && IsVisible (Mobj,False))
				{
					ThrowChance += 5; //Increment the chance variable.
					//Additionally increment it by a different amounts based on how much health the found actor has.
					If (Mobj.Health >= 10000) {ThrowChance += 300;} //If an actor with this much health is near the target, then DEFINITELY throw a grenade.
					Else If (Mobj.Health >= 4000) {ThrowChance += 80;}
					Else If (Mobj.Health >= 2500) {ThrowChance += 50;}
					Else If (Mobj.Health >= 1000) {ThrowChance += 35;}
					Else If (Mobj.Health >= 500) {ThrowChance += 25;}
					Else If (Mobj.Health >= 150) {ThrowChance += 10;}
					Else If (Mobj.Health >= 50) {ThrowChance += 5;}
					
					If (Mobj && (Mobj.Player && Mobj.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" || Mobj Is "SmartMarine" && SmartMarine(Mobj).OnTurret)) ThrowChance += 50;
				}
				Else If (Mobj.bIsMonster && !IsHostile(Mobj) && IsVisible (Mobj,False) && Mobj != Self) //If the actor that was found is friendly to you, and ISN'T you.
				{
					ThrowChance -= 15; //Then decrease the chance of throwing a grenade.
				}
				Else If (Mobj.Player && !IsHostile (Mobj)) //If the actor found is a player friendly to you.
				{
					ThrowChance -= 70; //Then be A LOT less likely to throw a grenade.
				}
			}
						
			If (ThrowChance >= User_GrenadeThreshold) //The number 240 should be replaced by a user variable that can modify their likelyhood of throwing a grenade.
			{
				Return True;
			}
		}
		
		Return False;
	}
	
	//Informs other marines to wait before throwing their own grenades, to not spam them while in groups.
	Void AnnounceGrenadeThrow()
	{
		Actor Mobj;
		BlockThingsIterator FindOtherMarines = BlockThingsIterator.Create (Self,256);
		
		While (FindOtherMarines.Next())
		{
			Mobj = FindOtherMarines.Thing;
			If (Mobj != Self && Mobj Is "SmartMarine" && Mobj.Health > 0 && !IsHostile (Mobj) && IsVisible (Mobj,True) && Distance3D (Mobj) <= 256)
			{
				SmartMarine(Mobj).GrenadeDelay = Random (35/2,40);
			}
		}
	}
	
	//This function was written by Lewisk3.
	void FireGrenade(Actor toAct, class<Actor> nade, double maxPitch = 90, double aimSens = 1.0, double aimDist = 128)
	{
		if(!toAct) return;
		
		// Source and Destination
		vector3 fromPos = (
			pos.xy,
			pos.z + (height)
		);
		vector3 toPos = (
			toAct.pos.xy, 
			toAct.pos.z + (toAct.height * 0.5) 
		);
		
		vector3 diff = level.vec3diff(fromPos, toPos);
		
		// Spawn grenade, calculate values from instance.
		let nade = Spawn(nade, fromPos);
		if(!nade) return;    
		nade.target = self;
		
		// Modify toPos Z component based on how many units the thrown grenade
		// fall by the time it reaches the destination.
		double dist = diff.xy.Length();
		if(dist >= aimDist)
		{
			double grav = 1.0 + ceil(nade.GetGravity() * (level.gravity * 0.010769));
			double ticsDist = diff.Length() / double(max(nade.Speed,1.0));        
			double fallDist = ticsDist * grav;
			toPos.z += fallDist * aimSens;
		}
		
		// Recalculate differences.
		diff = level.vec3diff(fromPos, toPos);
		double aimPitch = VectorAngle( sqrt(diff.y*diff.y + diff.x*diff.x), diff.z );
		aimPitch = min(aimPitch, maxPitch);
		
		// Modify grenade velocity
		double a = AngleTo(toAct);
		double p = -aimPitch;
		nade.vel = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * nade.Speed;
	}
	
	//Determines if the marine should be scared of its' current target.
	Void SM_ShouldBeScared()
	{
		If (User_FearDistance <= 0 || !Target) Return;
		//The marine must not have the frightened flag on when going to a turret, to not also avoid the turret they are going to.
		//If the target is nearby, visible, and hostile, and has over 2500 health.
		If (IsHostile (Target) && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && Target.SpawnHealth() >= 2000 && IsVisible (Target,True) && !GoingToTurret
		
		//Or if it is big enough and visible and close enough.
		|| (Target.Height >= 80 && Target.Radius >= 72) && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret
		
		//Or it has any of these flags, along with being nearby and visible to you.
		|| (Target.bReflective && Target.bAimReflect || Target.bInvulnerable) && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret
		
		//Or if is completely indestructible or noclipping at all, regardless of sight or distance.
		|| (Target.bNoDamage || Target.bNoclip))
		{
			SM_TurretUseDecision(); //Look for any turrets nearby.
			bFrightened = True; //Then be scared.
			MinMissileChance = 50; //Double the chance of attacking, to make up for all the running away.
		}
		//If your target is hostile, and is a player or marine that's on a turret. And they are in range and visible.
		/*This Else If is here so marines scared of an enemy on a turret, won't be any more likely to get on one themselves.
		Since protecting yourself from machine gun fire by getting to a stationary turret yourself is stupid, and MORE likely to get you killed.*/
		Else If ((Target.Player && Target.Player.ReadyWeapon && Target.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret ||
		Target Is "SmartMarine" && SmartMarine(Target).OnTurret && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret ||
		Target Is "TurretMarine" && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret))
		{
			bFrightened = True; 
			MinMissileChance = 50;
		}
		Else //If they don't meet any of those criteria, then stop being scared.
		{
			bFrightened = False;
			MinMissileChance = Default.MinMissileChance; //Go back to the normal firing chance.
		}
	}
	
	//Checks what directions the marine will be able to jump to, to avoid any incoming projectiles.
	//This (mostly) prevents marines from jumping into walls or off very tall ledges.
	Bool SM_ShouldDodgeProjectile (Double Distance = 384)
	{
		If (User_DodgeRange == -1) Return False;
		
		Bool LeftSafe;
		Bool RightSafe;
		Double OldAngle;
		
		If (SM_FindNearbyProjectile (Distance))
		{
			OldAngle = Angle; //Store the current angle before facing the projectile to dodge it.
			
			MaxDropOffHeight = 128; //Temporarily increase the maximum height the marine can drop from.
			
			A_Face (NearbyProjectile,flags:FAF_MIDDLE);
			//Check if it's safe to strafe 56 map units to the left or right, or both. Or none even, like in the case of crammed corridors.
			LeftSafe = CheckMove (Vec2Angle (56,Angle+90),PCM_DROPOFF);
			RightSafe = CheckMove (Vec2Angle (56,Angle-90),PCM_DROPOFF);
							
			If ((LeftSafe && RightSafe)) //Both directions are safe to strafe to.
				StrafeDirection = STRAFE_RANDOM;
			Else If ((!LeftSafe && !RightSafe)) //The area is too crammed to strafe anywhere here.
			{
				Angle = OldAngle; //Revert the marines' angle if you can't dodge.
				StrafeDirection = STRAFE_NONE; //Reset the strafe direction to none.
				MaxDropOffHeight = Default.MaxDropOffHeight; //Revert the property to the default again.
				Return False; //Don't break whatever state sequence the marine is currently in to tell him he can't dodge.
			}
			Else If (LeftSafe && !RightSafe) //Can only strafe left.
				StrafeDirection = STRAFE_LEFT;
			Else If (!LeftSafe && RightSafe) //Can only strafe right.
				StrafeDirection = STRAFE_RIGHT;
			
			MaxDropOffHeight = Default.MaxDropOffHeight; //Revert the property to the default again.
			Return True; //Found a direction to strafe at to dodge.
		}
		
		Return False; //Didn't even find a projectile to dodge.
	}
	
	//Checks if an enemy projectile, or one that should always be avoided, or a really harmful one, is approaching the marines' direction.
	//The IgnoredProjectiles and AlwaysAvoid arrays can be used to list what projectiles the marines should always avoid or ignore.
	Bool SM_FindNearbyProjectile (Double Range = 384)
	{
		
		Bool EpicFail; //Makes the function immediately stop running if the projectile is on the ignore list.
		Bool SkipAllyCheck;
		
		Static Const Name IgnoredProjectiles[] = //A list of enemy projectiles that they don't try avoiding.
		{
			"SM_Grenade" //Grenades have special handling.
		};
		
		Static Const Name AlwaysAvoid[] = //A list of projectiles to always avoid, even if fired by a friend.
		{
			"Rocket",
			"BFGBall"
			//"SM_Missile" //Future feature.
		};
		
		Let ProjectileHandler = SM_ProjectileHandler(EventHandler.Find("SM_ProjectileHandler"));
		
		If (ProjectileHandler)
		{
			For (Int I; I < ProjectileHandler.ProjectileList.Size(); I++)
			{
				Actor Projectile = ProjectileHandler.ProjectileList[I];
				
				//Null check.
				If (!Projectile) Continue;
				
				//Out of range.
				If (Distance3DSquared(Projectile) > Range*Range) Continue;
				
				//Don't keep dodging the same projectile.
				If (Projectile == PreviousProjectile) Continue;
				
				//Don't return true if it's part of the blacklist.
				For (Int I; I < IgnoredProjectiles.Size(); I++)
				{
					If (Projectile.GetClassName() == IgnoredProjectiles[I]) {EpicFail = True; Continue;}
				}
				
				If (EpicFail) Continue;
				
				If (!bFriendly) SkipAllyCheck = True; //As a hostile marine, just dodge ANY projectile not on the IgnoredProjectiles list.
				
				//If the projectile heading towards you will do way too much damage, then avoid it even if it was shot by a friend. This has to account for Doom's absurd damage variation.
				If (Projectile.bStrifeDamage && Projectile.Damage >= Health/3 || Projectile.Damage >= Health/6) {SkipAllyCheck = True;}
				
				For (Int I; I < AlwaysAvoid.Size(); I++)
				{
					If (Projectile.GetClassName() == AlwaysAvoid[I]) {SkipAllyCheck = True; Continue;}
				}
				
				If (!SkipAllyCheck && Projectile.Target && !IsHostile(Projectile.Target)) Continue;
				
				//Don't return true if the projectile isn't visible at all, or is too far away from the marines' peripheral vision. Or if it isn't so close that it's impossible not to notice it.
				If (!(IsVisible (Projectile,True) &&
				(AbsAngle (Angle,AngleTo(Projectile)) < 120.0 || !(Distance3DSquared(Projectile) > Range*Range/6))))
				Continue;
				
				//Is the projectile about to hit me ? Weird math nonsense written by RaveYard.
				bool projectile_is_flying_towards_me = (Vec3To(projectile).Unit() dot projectile.vel.Unit()) < -0.15;
				double projectileSafeRadius = sqrt(2 * ((projectile.radius + radius) ** 2.2));
				if(projectile_is_flying_towards_me && distance3dline(pos, projectile.pos, projectile.pos + projectile.vel) < projectileSafeRadius)
				{
					
					NearbyProjectile = Projectile;
					Return True;
				}
			}
		}
		Return False;
	}
	
	static double Distance3dLine(Vector3 a, Vector3 b, Vector3 c)
	{
		return (((A - B) cross (C - B))).length() / (C - B).length();
	}
		
	//Alerts nearby marines friendly to the calling one of the callers' target.
	Void SM_AlertNearbyMarines (Double Range = 256, Bool SkipCheck = False)
	{
		If (User_AlertRange == -1) Return;
		
		If (Target && Goal && Target == Goal) Return; //Don't fuck things up by making other marines try and attack a patrol point.
		
		Actor PotentialMarine;
		Bool FoundMarines;
		
		If (SkipCheck || !LastEnemy && Target) //If you had no prior enemy, like after giving up on your current target. Or if SkipCheck is true.
		{
			BlockThingsIterator AlertNearbyMarines = BlockThingsIterator.Create (Self,Range);
			
			While (AlertNearbyMarines.Next())
			{
				PotentialMarine = AlertNearbyMarines.Thing;
				
				If (!PotentialMarine.bDormant && PotentialMarine.GetClassName() == "SmartMarine" && Distance3D(PotentialMarine) <= Range && PotentialMarine.Health > 0 && !IsHostile (PotentialMarine) && !(PotentialMarine.Target)) //If the actor is not dormant, a marine, in range, is not hostile to you, and has no target already.
				{
					//Make sure the marine isn't in its' RunAway state, that state must NEVER be broken by being changed or having the marines' target changed during it.
					If (!(PotentialMarine.InStateSequence(PotentialMarine.CurState,ResolveState ("RunAway"))))
					{
						PotentialMarine.Target = Target; //Have the marine share your target.
						FoundMarines = True; //A marine has been found.
						If (!(PotentialMarine.InStateSequence(PotentialMarine.CurState,ResolveState ("See")))) //If the marine isn't in its' see state already, to chase the target.
						{
							PotentialMarine.SetStateLabel ("See"); //Then send them to it.
						}
					}
				}
			}
			
			If (FoundMarines) //If at least one marine was found to alert.
			{A_StartSound ("Marine/AlertAllies",CHAN_VOICE,attenuation:0.75);}
		}
	}
	
	//Searches for grenades that are about to explode near the marine.
	Bool SM_FindNearbyGrenade (Double SearchRadius = 256)
	{
		Actor Mobj;
		BlockThingsIterator GrenadeSearch = BlockThingsIterator.Create (Self,SearchRadius);
		
		While (GrenadeSearch.Next())
		{
			Mobj = GrenadeSearch.Thing;
			If (Mobj.GetClassName() == "SM_Grenade" && Mobj.ReactionTime <= 6 && Distance3D (Mobj) <= SearchRadius && IsVisible (Mobj,True)) //If the found actor is a grenade, that will explode in about a second. And you are in the blast radius and it's visible.
			{
				OriginalTarget = Target; //Keep the original target of the marine stored.
				Target = Mobj; //Then change the target to the grenade that was found.
				Return True; //And return true.
			}
		}
		Return False; //No grenades were found near the marine.
	}
	
	Void SM_ListenForEnemyAlerts (Double HearingRadius = 1024)
	{
		If (User_EnemyAlertHearingRange == -1) Return; //Don't run this if the feature is turned off.
		
		If (!Target)
		{
			Actor Mobj;
			BlockThingsIterator ListenForEnemyMarines = BlockThingsIterator.Create (Self,HearingRadius);
			
			While (ListenForEnemyMarines.Next())
			{
				Mobj = ListenForEnemyMarines.Thing;
				If (Mobj.GetClassName() == "SmartMarine" && IsHostile (Mobj) && Distance3D (Mobj) <= HearingRadius && Mobj.IsActorPlayingSound (CHAN_VOICE,"Marine/AlertAllies") && Mobj.Health > 0)
				{
					Target = Mobj; //Target the enemy marine that alerted the others.
					SetStateLabel ("AlertOtherMarines");
					Break;
				}
			}
		}
	}
	
	//Checks the line of fire between the marine and the target. And returns true if an ally, or an actor or line that could block the shot is in the line of fire.
	Bool SM_CantHitTarget (Bool ProjectileAttack = False)
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		A_FaceTarget(0,0,flags:FAF_MIDDLE);
		LineTrace (Angle+BulletSpreadXY,8192+2,Pitch+BulletSpreadZ,0,42,0,-6,LOFCheck);
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		If (Mobj) //Only run this if an actor was hit by the raycast.
		{
			
			//If the actor is a shootable non-monster, with a width over 10 map units. Or it's a dormant monster.
			If ((!(Mobj.bIsMonster) && !(Mobj.Player) && Mobj.bShootable && Mobj.Radius > 5) || Mobj.bIsMonster && Mobj.bDormant)
			{
				Return (ProjectileAttack || Random[pr_monsterrefire](0,255) < 88); //Then have a random chance to eventually stop shooting, similar to A_MonsterRefire().
			}
			//If the actor is a monster or player, and is not hostile to you.
			If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile (Mobj) &&
			//And it is not targeting a marine that's currently your friend (Which could be yourself as well).
			!(Mobj.Target && Mobj.Target Is "SmartMarine" && !IsHostile (Mobj.Target)) &&
			//And it is not your current target.
			!(Target == Mobj))
			{
				Return (bFriendly && !IsHostile(Mobj)) || (!bFriendly && !Mobj.bFriendly); //Then return that the actor should not be shot if it isn't hostile to you.
			}
		}
		
		//Avoid firing your gun or throwing grenades if a linedef is between you and the target, that would block the projectile or hitscan attack.
		If ((!ProjectileAttack && HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKHITSCAN)) || //Check for hitscan blocking lines.
		(ProjectileAttack && HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE))) //Ditto, but for projectiles, AKA in case the marine is trying to toss a grenade.
		{Return True;}
		
		
		Return False;
	}
		
	//Decides if the marine should use a nearby turret, if there's any.
	Bool SM_TurretUseDecision (Double TurretRadius = 512, Double EnemyRadius = 4096)
	{
		If (User_TurretThreshold == -1 || (Goal || GoingToTurret)) Return False;
		
		Actor FoundTurret;
		Actor Mobj;
		Int UseChance;
		Bool FoundAllies;
		
		LookExParams MarineSight;
		MarineSight.FOV = 180;
		MarineSight.MinDist = 0;
		MarineSight.MaxDist = 8192;
		MarineSight.MaxHearDist = 3072;
		
		BlockThingsIterator FindTurrets = BlockThingsIterator.Create (Self,TurretRadius);
		
		While (FindTurrets.Next())
		{
			If (FindTurrets.Thing Is "SmartMarineMGTurret" && !(SmartMarineMGTurret(FindTurrets.Thing).Occupied) && IsVisible (FindTurrets.Thing,True) && Distance3D (FindTurrets.Thing) <= TurretRadius)
			{
				FoundTurret = FindTurrets.Thing;
				//Break;
			}
		}
		
		If (!FoundTurret) Return False; //Don't try deciding to use a turret, if there is none around.
		
		UseChance = Random (0,50);
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,EnemyRadius);
		
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			//If you found a monster or player, that is alive, hostile, close enough to you, and visible.
			If ((Mobj.bIsMonster || Mobj Is "PlayerPawn") && Mobj.Health > 0 && IsHostile (Mobj) && Mobj.Distance3D (Target) <= EnemyRadius && IsVisible (Mobj,False,params:MarineSight))
			{
				If (Mobj.Health >= 2500) {UseChance += 100;}
				Else If (Mobj.Player) {UseChance += 98+Random (0,2);}
				Else If (Mobj.Health >= 1000) {UseChance += 35;}
				Else If (Mobj.Health >= 500) {UseChance += 25;}
				Else If (Mobj.Health >= 150 || Mobj Is "SmartMarine") {UseChance += 10;}
				Else If (Mobj.Health >= 10) {UseChance += 5;}
				Else If (Mobj.Health >= 1) {UseChance += 1;}
			}
			//Also increase the chance for every ally you found around you, that could support you while you are stationary and vulnerable.
			If (bFriendly || !bFriendly && Target.Player)
			{
				If (Mobj.Health >= 10 && !IsHostile (Mobj) && Mobj.Distance3D (Target) <= EnemyRadius/2 && IsVisible (Mobj,True))
				{
					If ((Mobj.bIsMonster && Mobj != Self)) {UseChance += 30; FoundAllies = True;}
					Else If (Mobj.Player) {UseChance += 60; FoundAllies = True;}
				}
			}
			//Since hostile monsters don't attack friendly ones on sight by default, hostile marines can't rely on other fellow hostile monsters, besides other marines.
			Else
			{
				If (Mobj Is "SmartMarine" && !IsHostile (Mobj) && Mobj.Distance3D (Target) <= EnemyRadius/2 && IsVisible (Mobj,True))
				{
					UseChance += 30;
				}
			}
		}
		
		If (Health <= Default.Health/3) {UseChance += 40;} //High chance to use the turret if you are already close to dying.
		If (!FoundAllies) UseChance -= 60; //More unwilling to use turrets if no allies are around, maybe this could be turned off by the User_Fearless variable ?
		If (UseChance >= User_TurretThreshold && FoundTurret)
		{
			SM_AlertNearbyMarines (User_AlertRange*2,True);
			GoingToTurret = True;
			Goal = Spawn ("SM_TurretLocationMarker",FoundTurret.Pos);
			Goal.Master = FoundTurret; //Make the turret the goals' master. So the goal will stay on the same position as the turret, if the turret is moved.
			bChaseGoal = True;
			Return True;
		}
		
		Return False;
	}
	
	//Similar to SM_CantHitTarget, returns true if there is something in the way of the target that should make the marine not shoot.
	Bool SM_TurretLOFCheck()
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		LineTrace (Angle,8192+2,Pitch,TRF_SOLIDACTORS|TRF_THRUHITSCAN,42,0,-6,LOFCheck);
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		
		If (Mobj)
		{
			If ((Mobj.bIsMonster || Mobj.Player) && IsHostile(Mobj)) Return False; Else If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile(Mobj)) Return True;
			If ((Mobj.bShootable && Mobj.ResolveState ("Death")) || Mobj.bSolid && !(Mobj.bShootable)) Return False; 
			If (Mobj.Radius <= 5 && Mobj.bShootable) Return False;
			Return True;
		}
		
		If (HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE)) Return True;
		
		Return False;
	}
	
	Void LeaveTurret ()
	{
		If (Turret && OnTurret)
		{
			Turret.A_ChangeLinkFlags (False,False);
			SmartMarineMGTurret(Turret).Occupied = False;
			Warp(Turret,-Turret.Radius*2,flags:WARPF_NOCHECKPOSITION); //Warp the marine at about the same position he is visibly at while on the turret.
			Turret.Angle = Self.Angle;
			Turret = Null;
			ReactionTime = Default.ReactionTime;
			OnTurret = False;
			bNoPain = False;
			bDontThrust = False;
		}
	}
	
	//This code was written by RaveYard, to allow hostile marines to see and attack friendly NPCs.
	Actor FindFriendlyMonster(double distance = 8192)
	{
		BlockThingsIterator it = BlockThingsIterator.Create(self, distance);

		while (it.Next())
		{
			if (!it.thing || it.thing == self || it.thing.bNotarget || it.thing.bNeverTarget || it.thing.bDormant || !it.thing.bShootable) { continue; }

			if (!it.thing.bFriendly || it.thing.health <= 0 || (!it.thing.bIsMonster && !it.thing.player)) { continue; }

			// Player specific things such as: notarget and voodoo dolls
			if (it.thing.player && (it.thing.player.cheats & CF_NOTARGET || it.thing.player.mo != it.thing)) { continue; }

			if (IsVisible (it.thing, false) && IsHostile (it.thing))
			{
				return it.thing;
			}
		}
		return null;
	}

	private bool LookForFriendlyMonster()
	{
		let ptr = FindFriendlyMonster();
		if(ptr)
		{
			target = ptr;
			
			if(SM_IsInState ("Idle") || SM_IsInState ("Spawn"))
			{
				SetStateLabel ("AlertOtherMarines"); // Goto see
			}
			else
			{
				SM_AlertNearbyMarines(User_AlertRange);
			}
			return true;
		}
		return false;
	}

	private bool IsAlerted()
	{
		return !(SM_IsInState ("Idle") || SM_IsInState ("Spawn"));
	}

	// A_LookEx + more
	//		forceTryNewTarget - look for new target even if you already have one
	void SM_LookForTarget(bool forceTryNewTarget = false)
	{
		bStandStill = True; //The flag is used between the A_LookEx call, so the marine doesn't get alerted because the player made a sound.

		if(!target || forceTryNewTarget)
		{
			if(bFriendly)
			{
				A_LookEx (IsAlerted() ? LOF_NOJUMP | LOF_NOSEESOUND : 0, maxseedist:8192, 3072, 160, "AlertOtherMarines");
			}
			else
			{
				bool found = LookForFriendlyMonster();

				if(!found || Random(0, 2))
				{
					// Try targeting the player instead
					A_LookEx (IsAlerted() ? LOF_NOJUMP | LOF_NOSEESOUND : 0, maxseedist:8192, 3072, 160, "AlertOtherMarines");
				}
			}
		}

		bStandStill = False;
	}

	// Manually update the target	
	void SM_UpdateTarget()
	{
		if(!target || target.health <= 0 || !CheckIfTargetInLOS(360))
		{
			SM_LookForTarget(true);
		}
	}
}

//I had to make the stationary turret marine inherit from Actor, instead of the main marine class, so all the user variables of the main class.
//That are not needed for the turret marine, won't also appear for him in UDB and SLADE. But I still needed these functions below.
//So I have to duplicate them in this mixin, to not get startup errors from the afformentioned vestigial user variables not existing on the turret marine.
//No, you don't need to lecture me on how fucking repulsive this is.
Mixin Class TurretMarineFunctions
{
	Bool STM_IsInState (StateLabel CheckFor = "Spawn")
	{
		If (InStateSequence(CurState,ResolveState (CheckFor))) {Return True;}
		Return False;
	}
	
	Bool STM_TurretLOFCheck()
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		LineTrace (Angle,8192+2,Pitch,TRF_SOLIDACTORS|TRF_THRUHITSCAN,42,0,-6,LOFCheck);
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		
		If (Mobj)
		{
			If ((Mobj.bIsMonster || Mobj.Player) && IsHostile(Mobj)) Return False; Else If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile(Mobj)) Return True;
			If ((Mobj.bShootable && Mobj.ResolveState ("Death")) || Mobj.bSolid && !(Mobj.bShootable)) Return False;
			If (Mobj.Radius <= 5 && Mobj.bShootable) Return False;
			Return True;
		}
		
		If (HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE)) Return True;
		
		Return False;
	}
	
	//Searches for grenades that are about to explode near the marine.
	Bool STM_FindNearbyGrenade (Double SearchRadius = 256)
	{
		If (!User_RunFromGrenades) Return False;
		
		Actor Mobj;
		BlockThingsIterator GrenadeSearch = BlockThingsIterator.Create (Self,SearchRadius);
		
		While (GrenadeSearch.Next())
		{
			Mobj = GrenadeSearch.Thing;
			If (Mobj.GetClassName() == "SM_Grenade" && Mobj.ReactionTime <= 6 && Distance3D (Mobj) <= SearchRadius && IsVisible (Mobj,True)) //If the found actor is a grenade, that will explode in about a second. And you are in the blast radius and it's visible.
			{
				Return True; //And return true.
			}
		}
		Return False; //No grenades were found near the marine.
	}
	
	//This code was written by RaveYard, to allow hostile marines to see and attack friendly NPCs. Deja vu.
	Actor STM_FindFriendlyMonster(double distance = 8192)
	{
		BlockThingsIterator it = BlockThingsIterator.Create(self, distance);

		while (it.Next())
		{
			if (!it.thing || it.thing == self || it.thing.bNotarget || it.thing.bNeverTarget || it.thing.bDormant || !it.thing.bShootable) { continue; }

			if (!it.thing.bFriendly || it.thing.health <= 0 || (!it.thing.bIsMonster && !it.thing.player)) { continue; }

			// Player specific things such as: notarget and voodoo dolls
			if (it.thing.player && (it.thing.player.cheats & CF_NOTARGET || it.thing.player.mo != it.thing)) { continue; }

			if (IsVisible (it.thing, false) && IsHostile (it.thing))
			{
				return it.thing;
			}
		}
		return null;
	}

	private bool STM_LookForFriendlyMonster()
	{
		let ptr = STM_FindFriendlyMonster();
		if(ptr)
		{
			target = ptr;

			if(STM_IsInState ("Idle") || STM_IsInState ("Spawn"))
			{
				SetStateLabel ("See"); // Goto see
			}
			return true;
		}
		return false;
	}

	private bool IsAlerted()
	{
		return !(STM_IsInState ("Idle") || STM_IsInState ("Spawn"));
	}

	// A_LookEx + more
	//		forceTryNewTarget - look for new target even if you already have one
	void STM_LookForTarget(bool forceTryNewTarget = false)
	{
		bStandStill = True; //The flag is used between the A_LookEx call, so the marine doesn't get alerted because the player made a sound.

		if(!target || forceTryNewTarget)
		{
			if(bFriendly)
			{
				A_LookEx (IsAlerted() ? LOF_NOJUMP | LOF_NOSEESOUND : 0, maxseedist:8192, 3072, 160, "See");
			}
			else
			{
				bool found = STM_LookForFriendlyMonster();

				if(!found || Random(0, 2))
				{
					// Try targeting the player instead
					A_LookEx (IsAlerted() ? LOF_NOJUMP | LOF_NOSEESOUND : 0, maxseedist:8192, 3072, 160, "See");
				}
			}
		}

		bStandStill = False;
	}

	// Manually update the target	
	void STM_UpdateTarget()
	{
		if(!target || target.health <= 0 || !CheckIfTargetInLOS(360))
		{
			STM_LookForTarget(true);
		}
	}
}