Mixin Class MarineFunctions
{
	//Shorthand for checking what state the marine is in.
	Bool SM_IsInState (StateLabel CheckFor = "Spawn")
	{
		If (InStateSequence(CurState,ResolveState (CheckFor))) {Return True;}
		Return False;
	}
	
	Bool GrenadeAttackDecision (Double BlastRadius = 192, Double ThrowDistance = 1024, Double DangerDistance = 224)
	{
		Int ThrowChance;
		Actor Mobj;
		
		If (User_GrenadeThreshold == 256) Return False; //Disable grenade throwing.
		If (Target)
		{	
			If (Distance3D (Target) <= DangerDistance || Distance3D(Target) > ThrowDistance) {a_log ("too far, or close");Return False;} //If the target is close enough for you to get caught in the blast, or if the target is too far, don't throw.
			If (User_GrenadeThreshold == -1) Return True; //Always throw grenades.
			
			ThrowChance = Random (0,256);
			//console.printf ("the initial throwing chance is %d",ThrowChance);
			BlockThingsIterator FindTargets = BlockThingsIterator.Create (Target,BlastRadius);
			
			If (Target.Health >= 10000) {ThrowChance += 230; /*a_log ("my target has A LOT of health, so ill definitely throw");*/}
			Else If (Target.Health >= 4000) {ThrowChance += 80; /*a_log ("my target has plenty of health, so ill probably throw");*/}
			Else If (Target.Player) ThrowChance += 20;
			Else If ((Target.Player && Target.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" || Target Is "SmartMarine" && SmartMarine(Target).OnTurret)) ThrowChance += 50;
			
			While (FindTargets.Next())
			{
				Mobj = FindTargets.Thing;
				
				//If the found actor is a monster or player, is not your current target, is at or closer than the specified blast radius, has health over 10, and is hostile and visible to you.
				If ((Mobj.bIsMonster || Mobj Is "PlayerPawn") && Mobj != Target && Mobj.Distance3D (Target) <= BlastRadius && Mobj.Health >= 10 && IsHostile (Mobj) && IsVisible (Mobj,False))
				{
					ThrowChance += 5; //Increment the chance variable.
					//Additionally increment it by a different amounts based on how much health the found actor has.
					If (Mobj.Health >= 10000) {ThrowChance += 300;} //If an actor with this much health is near the target, then DEFINITELY throw a grenade.
					Else If (Mobj.Health >= 4000) {ThrowChance += 80;}
					Else If (Mobj.Health >= 2500) {ThrowChance += 50;}
					Else If (Mobj.Health >= 1000) {ThrowChance += 35;}
					Else If (Mobj.Health >= 500) {ThrowChance += 25;}
					Else If (Mobj.Health >= 150) {ThrowChance += 10;}
					Else If (Mobj.Health >= 50) {ThrowChance += 5;}
					
					If ((Mobj.Player && Mobj.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" || Mobj Is "SmartMarine" && SmartMarine(Mobj).OnTurret)) ThrowChance += 50;
				}
				Else If (Mobj.bIsMonster && !IsHostile(Mobj) && IsVisible (Mobj,False) && Mobj != Self) //If the actor that was found is friendly to you, and ISN'T you.
				{
					//a_log ("a friendly npc is near the blast radius");
					ThrowChance -= 15; //Then decrease the chance of throwing a grenade.
				}
				Else If (Mobj Is "PlayerPawn" && !IsHostile (Mobj)) //If the actor found is a player friendly to you.
				{
					//a_log ("a friendly player is near the blast radius, so i think i wont throw the grenade");
					ThrowChance -= 70; //Then be A LOT less likely to throw a grenade.
				}
				
				//console.printf ("the throwing chance is now %d",ThrowChance);
			}
						
			If (ThrowChance >= User_GrenadeThreshold) //The number 240 should be replaced by a user variable that can modify their likelyhood of throwing a grenade.
			{
				//a_log ("im gonna throw a grenade");
				Return True;
			}
		}
		
		//a_log ("i decided to not throw a grenade");
		Return False;
	}
	
	//This function was written by Lewisk3.
	void FireGrenade(Actor toAct, class<Actor> nade, double maxPitch = 90, double aimSens = 1.0, double aimDist = 128)
	{
		if(!toAct) return;
		
		// Source and Destination
		vector3 fromPos = (
			pos.xy,
			pos.z + (height)
		);
		vector3 toPos = (
			toAct.pos.xy, 
			toAct.pos.z + (toAct.height * 0.5) 
		);
		
		vector3 diff = level.vec3diff(fromPos, toPos);
		
		// Spawn grenade, calculate values from instance.
		let nade = Spawn(nade, fromPos);
		if(!nade) return;    
		nade.target = self;
		
		// Modify toPos Z component based on how many units the thrown grenade
		// fall by the time it reaches the destination.
		double dist = diff.xy.Length();
		if(dist >= aimDist)
		{
			double grav = 1.0 + ceil(nade.GetGravity() * (level.gravity * 0.010769));
			double ticsDist = diff.Length() / double(max(nade.Speed,1.0));        
			double fallDist = ticsDist * grav;
			toPos.z += fallDist * aimSens;
		}
		
		// Recalculate differences.
		diff = level.vec3diff(fromPos, toPos);
		double aimPitch = VectorAngle( sqrt(diff.y*diff.y + diff.x*diff.x), diff.z );
		aimPitch = min(aimPitch, maxPitch);
		
		// Modify grenade velocity
		double a = AngleTo(toAct);
		double p = -aimPitch;
		nade.vel = (
			cos(a) * cos(p),
			sin(a) * cos(p),
			-sin(p)
		) * nade.Speed;
	}
	
	//Determines if the marine should be scared of its' current target.
	Void SM_ShouldBeScared()
	{
		If (User_FearDistance <= 0 || !Target) {Return;}
		//The marine must not have the frightened flag on when going to a turret, to not also avoid the turret they are going to.
		//If the target is nearby, visible, and hostile, and has over 2500 health.
		If (IsHostile (Target) && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && Target.Health >= 2500 && IsVisible (Target,True) && !GoingToTurret
		
		//Or if it is big enough and visible and close enough.
		|| (Target.Height >= 80 && Target.Radius >= 72) && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret
		
		//Or it has any of these flags, along with being nearby and visible to you.
		|| (Target.bReflective && Target.bAimReflect || Target.bInvulnerable) && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret
		
		//Or if is completely indestructible or noclipping at all, regardless of sight or distance.
		|| (Target.bNoDamage || Target.bNoclip))
		{
			//a_log ("my target is spooky");
			SM_TurretUseDecision(); //Look for any turrets nearby.
			bFrightened = True; //Then be scared.
			MinMissileChance = 50; //Double the chance of attacking, to make up for all the running away.
			//console.printf ("MinMissileChance is now %d.",MinMissileChance);
		}
		//If your target is hostile, and is a player or marine that's on a turret. And they are in range and visible.
		/*This Else If is here so marines scared of an enemy on a turret, won't be any more likely to get on one themselves.
		Since protecting yourself from machine gun fire by getting to a stationary turret yourself is stupid, and MORE likely to get you killed.*/
		Else If ((Target.Player && Target.Player.ReadyWeapon.GetClassName() == "SmartMarineMGWeapon" && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret ||
		Target Is "SmartMarine" && SmartMarine(Target).OnTurret && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret ||
		Target Is "TurretMarine" && Distance3D (Target) <= User_FearDistance*FRandom (1.01,1.25) && IsVisible (Target,True) && !GoingToTurret))
		{
			bFrightened = True; 
			MinMissileChance = 50;
		}
		Else //If they don't meet any of those criteria, then stop being scared.
		{
			/*a_log ("my target is not spooky");*/
			bFrightened = False;
			MinMissileChance = Default.MinMissileChance; //Go back to the normal firing chance.
			//console.printf ("MinMissileChance is now %d again.",MinMissileChance);
		}
	}
		
	//Alerts nearby marines friendly to the calling one of the callers' target.
	Void SM_AlertNearbyMarines (Double Range = 256, Bool SkipCheck = False)
	{
		If (User_AlertRange == -1) Return;
		
		If (Target && Goal && Target == Goal) Return; //Don't fuck things up by making other marines try and attack a patrol point.
		
		Actor PotentialMarine;
		Bool FoundMarines;
		
		If (SkipCheck || !LastEnemy && Target) //If you had no prior enemy, like after giving up on your current target. Or if SkipCheck is true.
		{
			BlockThingsIterator AlertNearbyMarines = BlockThingsIterator.Create (Self,Range);
			
			While (AlertNearbyMarines.Next())
			{
				PotentialMarine = AlertNearbyMarines.Thing;
				
				If (PotentialMarine.GetClassName() == "SmartMarine" && Distance3D(PotentialMarine) <= Range && PotentialMarine.Health > 0 && !IsHostile (PotentialMarine) && !(PotentialMarine.Target)) //If the actor is a marine, in range, is not hostile to you, and has no target already.
				{
					//Make sure the marine isn't in its' RunAway state, that state must NEVER be broken by being changed or having the marines' target changed during it.
					If (!(PotentialMarine.InStateSequence(PotentialMarine.CurState,ResolveState ("RunAway"))))
					{
						//console.printf ("Switched a nearby friendly marines' target to %s",Target.GetClassName());
						//spawn ("SmartMarineWanderingMessage",potentialmarine.pos); //Debug sprite, to show which marines were also alerted.
						PotentialMarine.Target = Target; //Have the marine share your target.
						FoundMarines = True; //A marine has been found.
						If (!(PotentialMarine.InStateSequence(PotentialMarine.CurState,ResolveState ("See")))) //If the marine isn't in its' see state already, to chase the target.
						{
							//A_log ("Also put him to the See state.");
							//spawn ("SmartMarineStandingMessage",potentialmarine.pos); //distringuishes marines whose state was also changed
							PotentialMarine.SetStateLabel ("See"); //Then send them to it.
						}
					}
				}
				//Else
				//{A_Log ("Not a marine + not friendly + has a target + you fell off + ratio");}
			}
			
			If (FoundMarines) //If at least one marine was found to alert.
			{A_StartSound ("Marine/AlertAllies",CHAN_VOICE,attenuation:0.75);}
		}
	}
	
	//Searches for grenades that are about to explode near the marine.
	Bool SM_FindNearbyGrenade (Double SearchRadius = 256)
	{
		Actor Mobj;
		BlockThingsIterator GrenadeSearch = BlockThingsIterator.Create (Self,SearchRadius);
		
		While (GrenadeSearch.Next())
		{
			Mobj = GrenadeSearch.Thing;
			//a_log ("looking for grenades");
			If (Mobj.GetClassName() == "SM_Grenade" && Mobj.ReactionTime <= 6 && Distance3D (Mobj) <= SearchRadius && IsVisible (Mobj,True)) //If the found actor is a grenade, that will explode in about a second. And you are in the blast radius and it's visible.
			{
				OriginalTarget = Target; //Keep the original target of the marine stored.
				Target = Mobj; //Then change the target to the grenade that was found.
				//a_log ("found a grenade");
				Return True; //And return true.
			}
		}
		//a_log ("no grenades found");
		Return False; //No grenades were found near the marine.
	}
	
	Void SM_ListenForEnemyAlerts (Double HearingRadius = 1024)
	{
		If (User_EnemyAlertHearingRange == -1) Return; //Don't run this if the feature is turned off.
		
		If (!Target)
		{
			Actor Mobj;
			BlockThingsIterator ListenForEnemyMarines = BlockThingsIterator.Create (Self,HearingRadius);
			
			While (ListenForEnemyMarines.Next())
			{
				Mobj = ListenForEnemyMarines.Thing;
				If (Mobj.GetClassName() == "SmartMarine" && IsHostile (Mobj) && Distance3D (Mobj) <= HearingRadius && Mobj.IsActorPlayingSound (CHAN_VOICE,"Marine/AlertAllies") && Mobj.Health > 0)
				{
					A_Log ("I heard an enemy marine alert his buddies.");
					Target = Mobj; //Target the enemy marine that alerted the others.
					SetStateLabel ("AlertOtherMarines");
					Break;
				}
			}
		}
	}
	
	//Checks the line of fire between the marine and the target. And returns true if an ally, or an actor or line that could block the shot is in the line of fire.
	Bool SM_CantHitTarget (Bool ProjectileAttack = False)
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		A_FaceTarget(0,0,flags:FAF_MIDDLE);
		LineTrace (Angle+BulletSpreadXY,8192+2,Pitch+BulletSpreadZ,0,42,0,-6,LOFCheck);
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		If (Mobj) //Only run this if an actor was hit by the raycast.
		{
			//a_log ("an actor was hit by the raycast");
			
			//If the actor is a shootable non-monster, with a width over 10 map units. Or it's a dormant monster.
			If ((!(Mobj.bIsMonster) && !(Mobj.Player) && Mobj.bShootable && Mobj.Radius > 5) || Mobj.bIsMonster && Mobj.bDormant)
			{
			a_log ("im aiming at a shootable decoration over 10 mu thick, or a dormant monster");
				Return (ProjectileAttack || Random[pr_monsterrefire](0,256) < 88); //Then have a random chance to eventually stop shooting, similar to A_MonsterRefire().
			}
			//If the actor is a monster or player, and is not hostile to you.
			If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile (Mobj) &&
			//And it is not targeting a marine that's currently your friend (Which could be yourself as well).
			!(Mobj.Target && Mobj.Target Is "SmartMarine" && !IsHostile (Mobj.Target)) &&
			//And it is not your current target.
			!(Target == Mobj))
			{
				a_log ("im aiming at a friend");
				Return True; //Then return that the actor should not be shot.
			}
		}
		
		//Avoid firing your gun or throwing grenades if a linedef is between you and the target, that would block the projectile or hitscan attack.
		If ((!ProjectileAttack && HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKHITSCAN)) || //Check for hitscan blocking lines.
		(ProjectileAttack && HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE))) //Ditto, but for projectiles, AKA in case the marine is trying to toss a grenade.
		{Return True;}
		
		
		Return False;
	}
		
	//Decides if the marine should use a nearby turret, if there's any.
	Bool SM_TurretUseDecision (Double TurretRadius = 512, Double EnemyRadius = 4096)
	{
		If (User_TurretThreshold == -1 || (Goal || GoingToTurret)) {a_log ("i already have a goal, or am going to a turret");Return False;}
		
		Actor FoundTurret;
		Actor Mobj;
		Int UseChance;
		Bool FoundAllies;
		
		LookExParams MarineSight;
		MarineSight.FOV = 180;
		MarineSight.MinDist = 0;
		MarineSight.MaxDist = 8192;
		MarineSight.MaxHearDist = 3072;
		
		BlockThingsIterator FindTurrets = BlockThingsIterator.Create (Self,TurretRadius);
		
		While (FindTurrets.Next())
		{
			If (FindTurrets.Thing Is "SmartMarineMGTurret" && !(SmartMarineMGTurret(FindTurrets.Thing).Occupied) && IsVisible (FindTurrets.Thing,True) && Distance3D (FindTurrets.Thing) <= TurretRadius)
			{
				FoundTurret = FindTurrets.Thing;
				a_log ("i found a turret");
				//Break;
			}
		}
		
		If (!FoundTurret) {a_log ("i havent even found a turret");Return False;} //Don't try deciding to use a turret, if there is none around.
		
		UseChance = Random (0,50); console.printf ("the initial random use chance is now %d",UseChance);
		
		BlockThingsIterator FindEnemies = BlockThingsIterator.Create (Self,EnemyRadius);
		
		While (FindEnemies.Next())
		{
			Mobj = FindEnemies.Thing;
			
			//If you found a monster or player, that is alive, hostile, close enough to you, and visible.
			If ((Mobj.bIsMonster || Mobj Is "PlayerPawn") && Mobj.Health > 0 && IsHostile (Mobj) && Mobj.Distance3D (Target) <= EnemyRadius && IsVisible (Mobj,False,params:MarineSight))
			{
				If (Mobj.Health >= 2500) {UseChance += 100; a_log ("oh shit");}
				Else If (Mobj.Player) {UseChance += 98+Random (0,2);}
				Else If (Mobj.Health >= 1000) {UseChance += 35;}
				Else If (Mobj.Health >= 500) {UseChance += 25;}
				Else If (Mobj.Health >= 150 || Mobj Is "SmartMarine") {UseChance += 10;}
				Else If (Mobj.Health >= 10) {UseChance += 5;}
				Else If (Mobj.Health >= 1) {UseChance += 1;}
				console.printf ("my chance of using a turret is now %d",usechance);
			}
			//Also increase the chance for every ally you found around you, that could support you while you are stationary and vulnerable.
			If (bFriendly)
			{
				If (Mobj.Health >= 10 && !IsHostile (Mobj) && Mobj.Distance3D (Target) <= EnemyRadius/2 && IsVisible (Mobj,True))
				{
					If ((Mobj.bIsMonster && !IsHostile (Mobj) && Mobj != Self)) {UseChance += 30; FoundAllies = True;a_log ("npc friend found");}
					Else If (Mobj.Player) {UseChance += 60; FoundAllies = True;a_log ("friendly player found");}
				}
			}
			//Since hostile monsters don't attack friendly ones on sight by default, hostile marines can't rely on other fellow hostile monsters, besides other marines.
			Else
			{
				If (Mobj Is "SmartMarine" && !IsHostile (Mobj) && Mobj.Distance3D (Target) <= EnemyRadius/2 && IsVisible (Mobj,True))
				{
					UseChance += 30;
				}
			}
		}
		
		If (Health <= Default.Health/3) {UseChance += 40;} //High chance to use the turret if you are already close to dying, will probably better to only make this occur with User_Fearless on.
		If (!FoundAllies) UseChance -= 60; //More unwilling to use turrets if no allies are around, maybe this could be turned off by the User_Fearless variable ?
		console.printf ("The use chance, while also accounting for any allies found, is now %d",UseChance);
		If (UseChance >= User_TurretThreshold && FoundTurret)
		{
			a_log ("i decided to use the turret i found");
			SM_AlertNearbyMarines (User_AlertRange*2,True);
			GoingToTurret = True;
			Goal = Spawn ("SM_TurretLocationMarker",FoundTurret.Pos);
			Goal.Master = FoundTurret; //Make the turret the goals' master. So the goal will stay on the same position as the turret, if the turret is moved.
			bChaseGoal = True;
			Return True;
		}
		
		Return False;
	}
	
	//Similar to SM_CantHitTarget, returns true if there is something in the way of the target that should make the marine not shoot.
	Bool SM_TurretLOFCheck()
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		LineTrace (Angle,8192+2,Pitch,TRF_SOLIDACTORS|TRF_THRUHITSCAN,42,0,-6,LOFCheck);
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		
		If (Mobj)
		{
			If ((Mobj.bIsMonster || Mobj.Player) && IsHostile(Mobj)) {a_log ("enemy hit");Return False;} Else If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile(Mobj)) {a_log ("option1");Return True;}
			If ((Mobj.bShootable && Mobj.ResolveState ("Death")) || Mobj.bSolid && !(Mobj.bShootable)) {a_log ("option2");Return False; }
			If (Mobj.Radius <= 5 && Mobj.bShootable) {a_log ("option3");Return False;}
			Return True;
		}
		
		If (HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE)) Return True;
		
		Return False;
	}
	
	Void LeaveTurret ()
	{
		If (Turret && OnTurret)
		{
			Turret.A_ChangeLinkFlags (False,False);
			SmartMarineMGTurret(Turret).Occupied = False;
			Warp(Turret,-Turret.Radius*2,flags:WARPF_NOCHECKPOSITION); //Warp the marine at about the same position he is visibly at while on the turret.
			console.printf ("my angle is %d",angle);
			Turret.Angle = Self.Angle;
			console.printf ("my turrets' angle is %d",turret.angle);
			Turret = Null;
			ReactionTime = Default.ReactionTime;
			OnTurret = False;
			bNoPain = False;
			bDontThrust = False;
		}
	}
	
	//This code was written by RaveYard, to allow hostile marines to see and attack friendly NPCs.
	Actor FindFriendlyMonster(double distance = 8192)
	{
		BlockThingsIterator it = BlockThingsIterator.Create(self, distance);

		while (it.Next())
		{
			if (!it.thing || it.thing == self || it.thing.bNotarget || it.thing.bNeverTarget || it.thing.bDormant || !it.thing.bShootable) { continue; }

			if (!it.thing.bFriendly || it.thing.health <= 0 || (!it.thing.bIsMonster && !it.thing.player)) { continue; }

			// Player specific things such as: notarget and voodoo dolls
			if (it.thing.player && (it.thing.player.cheats & CF_NOTARGET || it.thing.player.mo != it.thing)) { continue; }

			if (IsVisible (it.thing, false) && IsHostile (it.thing))
			{
				return it.thing;
			}
		}
		return null;
	}

	private bool LookForFriendlyMonster()
	{
		let ptr = FindFriendlyMonster();
		if(ptr)
		{
			target = ptr;

			//a_log ("i found a friendly monster while being hostile myself.");

			if(SM_IsInState ("Idle") || SM_IsInState ("Spawn"))
			{
				SetStateLabel ("AlertOtherMarines"); // Goto see
			}
			else
			{
				SM_AlertNearbyMarines(User_AlertRange);
			}
			return true;
		}
		return false;
	}

	private bool IsAlerted()
	{
		return !(SM_IsInState ("Idle") || SM_IsInState ("Spawn"));
	}

	// A_LookEx + more
	//		forceTryNewTarget - look for new target even if you already have one
	void SM_LookForTarget(bool forceTryNewTarget = false)
	{
		bStandStill = True; //The flag is used between the A_LookEx call, so the marine doesn't get alerted because the player made a sound.

		if(!target || forceTryNewTarget)
		{
			if(bFriendly)
			{
				A_LookEx (IsAlerted() ? LOF_NOJUMP | LOF_NOSEESOUND : 0, maxseedist:8192, 3072, 160, "AlertOtherMarines");
			}
			else
			{
				bool found = LookForFriendlyMonster();

				if(!found || Random(0, 2))
				{
					// Try targeting the player instead
					A_LookEx (IsAlerted() ? LOF_NOJUMP | LOF_NOSEESOUND : 0, maxseedist:8192, 3072, 160, "AlertOtherMarines");
				}
			}
		}

		bStandStill = False;
	}

	// Manually update the target	
	void SM_UpdateTarget()
	{
		if(!target || target.health <= 0 || !CheckIfTargetInLOS(360))
		{
			SM_LookForTarget(true);
		}
	}
}

//I had to make the stationary turret marine inherit from Actor, instead of the main marine class, so all the user variables of the main class.
//That are not needed for the turret marine, won't also appear for him in UDB and SLADE. But I still needed these functions below.
//So I have to duplicate them in this mixin, to not get startup errors from the afformentioned vestigial user variables not existing on the turret marine.
//No, you don't need to lecture me on how fucking repulsive this is.
Mixin Class TurretMarineFunctions
{
	Bool STM_IsInState (StateLabel CheckFor = "Spawn")
	{
		If (InStateSequence(CurState,ResolveState (CheckFor))) {Return True;}
		Return False;
	}
	
	Bool STM_TurretLOFCheck()
	{
		Actor Mobj;
		Line HitLine;
		FLineTraceData LOFCheck;
		
		LineTrace (Angle,8192+2,Pitch,TRF_SOLIDACTORS|TRF_THRUHITSCAN,42,0,-6,LOFCheck);
		Mobj = LOFCheck.HitActor;
		HitLine = LOFCheck.HitLine;
		
		If (Mobj)
		{
			If ((Mobj.bIsMonster || Mobj.Player) && IsHostile(Mobj)) {a_log ("enemy hit");Return False;} Else If ((Mobj.bIsMonster || Mobj.Player) && !IsHostile(Mobj)) {a_log ("option1");Return True;}
			If ((Mobj.bShootable && Mobj.ResolveState ("Death")) || Mobj.bSolid && !(Mobj.bShootable)) {a_log ("option2");Return False; }
			If (Mobj.Radius <= 5 && Mobj.bShootable) {a_log ("option3");Return False;}
			Return True;
		}
		
		If (HitLine && (HitLine.ML_BLOCKEVERYTHING || HitLine.ML_BLOCKPROJECTILE)) Return True;
		
		Return False;
	}
	
	//Searches for grenades that are about to explode near the marine.
	Bool STM_FindNearbyGrenade (Double SearchRadius = 256)
	{
		If (!User_RunFromGrenades) Return False;
		
		Actor Mobj;
		BlockThingsIterator GrenadeSearch = BlockThingsIterator.Create (Self,SearchRadius);
		
		While (GrenadeSearch.Next())
		{
			Mobj = GrenadeSearch.Thing;
			//a_log ("looking for grenades");
			If (Mobj.GetClassName() == "SM_Grenade" && Mobj.ReactionTime <= 6 && Distance3D (Mobj) <= SearchRadius && IsVisible (Mobj,True)) //If the found actor is a grenade, that will explode in about a second. And you are in the blast radius and it's visible.
			{
				a_log ("Time to spawn a marine !");
				Return True; //And return true.
			}
		}
		Return False; //No grenades were found near the marine.
	}
	
	//This code was written by RaveYard, to allow hostile marines to see and attack friendly NPCs. Deja vu.
	Actor STM_FindFriendlyMonster(double distance = 8192)
	{
		BlockThingsIterator it = BlockThingsIterator.Create(self, distance);

		while (it.Next())
		{
			if (!it.thing || it.thing == self || it.thing.bNotarget || it.thing.bNeverTarget || it.thing.bDormant || !it.thing.bShootable) { continue; }

			if (!it.thing.bFriendly || it.thing.health <= 0 || (!it.thing.bIsMonster && !it.thing.player)) { continue; }

			// Player specific things such as: notarget and voodoo dolls
			if (it.thing.player && (it.thing.player.cheats & CF_NOTARGET || it.thing.player.mo != it.thing)) { continue; }

			if (IsVisible (it.thing, false) && IsHostile (it.thing))
			{
				return it.thing;
			}
		}
		return null;
	}

	private bool STM_LookForFriendlyMonster()
	{
		let ptr = STM_FindFriendlyMonster();
		if(ptr)
		{
			target = ptr;

			//a_log ("i found a friendly monster while being hostile myself.");

			if(STM_IsInState ("Idle") || STM_IsInState ("Spawn"))
			{
				SetStateLabel ("See"); // Goto see
			}
			return true;
		}
		return false;
	}

	private bool IsAlerted()
	{
		return !(STM_IsInState ("Idle") || STM_IsInState ("Spawn"));
	}

	// A_LookEx + more
	//		forceTryNewTarget - look for new target even if you already have one
	void STM_LookForTarget(bool forceTryNewTarget = false)
	{
		bStandStill = True; //The flag is used between the A_LookEx call, so the marine doesn't get alerted because the player made a sound.

		if(!target || forceTryNewTarget)
		{
			if(bFriendly)
			{
				A_LookEx (IsAlerted() ? LOF_NOJUMP | LOF_NOSEESOUND : 0, maxseedist:8192, 3072, 160, "See");
			}
			else
			{
				bool found = STM_LookForFriendlyMonster();

				if(!found || Random(0, 2))
				{
					// Try targeting the player instead
					A_LookEx (IsAlerted() ? LOF_NOJUMP | LOF_NOSEESOUND : 0, maxseedist:8192, 3072, 160, "See");
				}
			}
		}

		bStandStill = False;
	}

	// Manually update the target	
	void STM_UpdateTarget()
	{
		if(!target || target.health <= 0 || !CheckIfTargetInLOS(360))
		{
			STM_LookForTarget(true);
		}
	}
}